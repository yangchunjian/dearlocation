<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://dearlocation.com/rss.xml" rel="self" type="application/rss+xml"/>
    <title></title>
    <link>https://dearlocation.com/</link>
    <description></description>
    <language>en-US</language>
    <pubDate>Tue, 28 Jun 2022 11:47:54 GMT</pubDate>
    <lastBuildDate>Tue, 28 Jun 2022 11:47:54 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>使用指南</category>
    <category>最少必要面试题</category>
    <category>我</category>
    <category>vpn</category>
    <category>Java练手项目</category>
    <category>币</category>
    <category>idea</category>
    <category>mysql</category>
    <category>nacos</category>
    <category>python</category>
    <category>redis</category>
    <category>CategoryA</category>
    <category>CategoryB</category>
    <item>
      <title>Intro Page</title>
      <link>https://dearlocation.com/intro.html</link>
      <guid>https://dearlocation.com/intro.html</guid>
      <source url="https://dearlocation.com/rss.xml">Intro Page</source>
      <pubDate>Tue, 28 Jun 2022 11:46:24 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="intro-page" tabindex="-1"> Intro Page</h1>
<p>Place your introducation and profile here.</p>
]]></content:encoded>
    </item>
    <item>
      <title>幻灯片页</title>
      <link>https://dearlocation.com/slide.html</link>
      <guid>https://dearlocation.com/slide.html</guid>
      <source url="https://dearlocation.com/rss.xml">幻灯片页</source>
      <pubDate>Tue, 28 Jun 2022 11:46:24 GMT</pubDate>
      <content:encoded><![CDATA[
<i>Content not supported</i>]]></content:encoded>
      <enclosure url="https://dearlocation.com/javapub-logo.svg" type="image/svg+xml"/>
    </item>
    <item>
      <title>主要功能与配置演示</title>
      <link>https://dearlocation.com/guide/</link>
      <guid>https://dearlocation.com/guide/</guid>
      <source url="https://dearlocation.com/rss.xml">主要功能与配置演示</source>
      <category>使用指南</category>
      <pubDate>Tue, 28 Jun 2022 11:46:24 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="主要功能与配置演示" tabindex="-1"> 主要功能与配置演示</h1>
<ul>
<li>
<p><a href="/guide/page.html">页面展示</a></p>
</li>
<li>
<p><a href="/guide/markdown.html">Markdown 展示</a></p>
</li>
<li>
<p><a href="/guide/disable.html">禁用展示</a></p>
</li>
<li>
<p><a href="/guide/encrypt.html">加密展示</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>组件禁用</title>
      <link>https://dearlocation.com/guide/disable.html</link>
      <guid>https://dearlocation.com/guide/disable.html</guid>
      <source url="https://dearlocation.com/rss.xml">组件禁用</source>
      <description>你可以通过设置页面的 Frontmatter，在页面禁用一些功能。
</description>
      <category>使用指南</category>
      <pubDate>Tue, 28 Jun 2022 11:46:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>你可以通过设置页面的 Frontmatter，在页面禁用一些功能。</p>

<p>本页面应当禁用了:</p>
<ul>
<li>导航栏</li>
<li>侧边栏</li>
<li>路径导航</li>
<li>页面信息</li>
<li>贡献者</li>
<li>编辑此页链接</li>
<li>更新时间</li>
<li>上一篇/下一篇 链接</li>
<li>评论</li>
<li>页脚</li>
<li>返回顶部按钮</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>密码加密的文章</title>
      <link>https://dearlocation.com/guide/encrypt.html</link>
      <guid>https://dearlocation.com/guide/encrypt.html</guid>
      <source url="https://dearlocation.com/rss.xml">密码加密的文章</source>
      <category>使用指南</category>
      <pubDate>Tue, 28 Jun 2022 11:46:24 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="密码加密的文章" tabindex="-1"> 密码加密的文章</h1>
<p>实际的文章内容。</p>
<p>段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。</p>
<p>段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Markdown 增强</title>
      <link>https://dearlocation.com/guide/markdown.html</link>
      <guid>https://dearlocation.com/guide/markdown.html</guid>
      <source url="https://dearlocation.com/rss.xml">Markdown 增强</source>
      <description>VuePress 的每个文档页面都是由 Markdown 渲染而成。所以你需要通过在相应路径创建编写 Markdown 建立你的文档或博客页面。
</description>
      <category>使用指南</category>
      <pubDate>Tue, 28 Jun 2022 11:46:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>VuePress 的每个文档页面都是由 Markdown 渲染而成。所以你需要通过在相应路径创建编写 Markdown 建立你的文档或博客页面。</p>

<h2 id="markdown-介绍" tabindex="-1"> Markdown 介绍</h2>
<p>如果你是一个新手，还不会编写 Markdown，请先阅读 <a href="https://vuepress-theme-hope.github.io/v2/zh/basic/markdown/README.html" target="_blank" rel="noopener noreferrer">Markdown 介绍</a> 和 <a href="https://vuepress-theme-hope.github.io/v2/zh/basic/markdown/demo.html" target="_blank" rel="noopener noreferrer">Markdown 演示</a>。</p>
<div><p>Frontmatter</p>
<p>Frontmatter 是 VuePress 中很重要的一个概念，如果你不了解它，你需要阅读 <a href="https://vuepress-theme-hope.github.io/v2/zh/basic/vuepress/page.html#front-matter" target="_blank" rel="noopener noreferrer">Frontmatter 介绍</a>。</p>
</div>
<h2 id="vuepress-扩展" tabindex="-1"> VuePress 扩展</h2>
<p>为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。</p>
<p>关于这些扩展，请阅读 <a href="https://vuepress-theme-hope.github.io/v2/zh/basic/vuepress/markdown.html" target="_blank" rel="noopener noreferrer">VuePress 中的 Markdown 扩展</a>。</p>
<h2 id="主题扩展" tabindex="-1"> 主题扩展</h2>
<h3 id="一键启用" tabindex="-1"> 一键启用</h3>
<p>你可以设置 <code>themeconfig.plugins.htmlEnhance.enableAll</code> 启用 <a href="https://vuepress-theme-hope.github.io/v2/md-enhance" target="_blank" rel="noopener noreferrer">md-enhance</a> 插件的所有功能。</p>
<div><pre><code>module.exports = {
  themeConfig: {
    plugins: {
      mdEnhance: {
        enableAll: true,
      },
    },
  },
};
</code></pre><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br></div><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="自定义容器" tabindex="-1"> 自定义容器</h3>
<div>
<p>安全的在 Markdown 中使用 {{ variable }}。</p>
</div>
<div><p>自定义标题</p>
<p>信息容器，包含 <code>代码</code> 与 。</p>
<div><pre><code><span>const</span> a <span>=</span> <span>1</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div></div>
<div><p>自定义标题</p>
<p>提示容器</p>
</div>
<div><p>自定义标题</p>
<p>警告容器</p>
</div>
<div><p>自定义标题</p>
<p>危险容器</p>
</div>
<details><summary>自定义标题</summary>
<p>详情容器</p>
</details>
<details><summary>代码</summary>
<div><pre><code>:::

安全的在 Markdown 中使用 {{ variable }}。

:::

::: info 自定义标题

信息容器

:::

::: tip 自定义标题

提示容器

:::

::: warning 自定义标题

警告容器

:::

::: danger 自定义标题

危险容器

:::

::: details 自定义标题

详情容器

:::
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/container.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="代码块" tabindex="-1"> 代码块</h3>
<p>:::: code-group</p>
<p>::: code-group-item yarn</p>
<div><pre><code><span>yarn</span> <span>add</span> -D vuepress-theme-hope
</code></pre><div aria-hidden="true"><div></div></div></div><p>:::</p>
<p>::: code-group-item npm:active</p>
<div><pre><code><span>npm</span> i -D vuepress-theme-hope
</code></pre><div aria-hidden="true"><div></div></div></div><p>:::</p>
<p>::::</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/code-group.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="自定义对齐" tabindex="-1"> 自定义对齐</h3>
<div style="text-align: center"><p>我是居中的</p>
</div>
<div style="text-align: right"><p>我在右对齐</p>
</div>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/align.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="上下角标" tabindex="-1"> 上下角标</h3>
<p>19<sup>th</sup> H<sub>2</sub>O</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/sup-sub.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="脚注" tabindex="-1"> 脚注</h3>
<p>此文字有脚注<sup></sup>.</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/footnote.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="标记" tabindex="-1"> 标记</h3>
<p>你可以标记 <mark>重要的内容</mark> 。</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/mark.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="任务列表" tabindex="-1"> 任务列表</h3>
<ul>
<li>
<p><input type="checkbox" id="task-item-0" checked="checked" disabled="disabled"><label for="task-item-0"> 计划 1</label></p>
</li>
<li>
<p><input type="checkbox" id="task-item-1" disabled="disabled"><label for="task-item-1"> 计划 2</label></p>
</li>
<li>
<p><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/tasklist.html" target="_blank" rel="noopener noreferrer">查看详情</a></p>
</li>
</ul>
<h3 id="图表" tabindex="-1"> 图表</h3>
<i>Content not supported</i><ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/chart.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="流程图" tabindex="-1"> 流程图</h3>
<i>Content not supported</i><ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/flowchart.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="mermaid" tabindex="-1"> Mermaid</h3>
<i>Content not supported</i><ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/mermaid.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="tex-语法" tabindex="-1"> Tex 语法</h3>
<p class='katex-block'><span><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:2.4em;vertical-align:-0.95em;"></span><span><span></span><span><span><span><span style="height:1.3714em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.05556em;">∂</span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.5904em;"><span style="top:-2.989em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.05556em;">∂</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="margin-right:0.1667em;"></span><span><span style="top:0em;"><span>(</span></span><span><span></span><span><span><span><span style="height:1.3414em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:3.0277em;vertical-align:-1.2777em;"></span><span><span style="top:0em;"><span>(</span></span><span><span></span><span><span><span><span style="height:1.3414em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.1667em;"></span><span><span style="top:0em;"><span>{</span></span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.03588em;">y</span><span><span>)</span><span><span><span><span style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span><span><span><span><span style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span style="top:-3.05em;"><span style="height:3.05em;"></span><span><span>∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span style="height:3.05em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span><span>​</span></span><span><span style="height:1.2777em;"><span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span><span></span><span><span><span><span style="height:1.5017em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.7507em;"><span style="top:-2.989em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span>(</span><span>−</span><span>1</span><span><span>)</span><span><span><span><span style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span></span></span></span></span><span style="margin-right:0.02778em;">r</span><span style="margin-right:0.1667em;"></span><span>⋯</span><span style="margin-right:0.1667em;"></span><span>(</span><span style="margin-right:0.02778em;">r</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span><span>i</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span><span>1</span><span>)</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.03588em;">y</span><span><span>)</span><span><span><span><span style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.02778em;">r</span><span>−</span><span>i</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>}</span></span></span></span></span></span></span></p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/tex.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="代码演示" tabindex="-1"> 代码演示</h3>
<p>::: demo 一个普通 Demo</p>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>VuePress Theme Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>"</span>very<span>"</span></span><span>></span></span>非常<span><span><span>&lt;/</span>span</span><span>></span></span>强大!<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><div><pre><code>document<span>.</span><span>querySelector</span><span>(</span><span>"#very"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>alert</span><span>(</span><span>"非常强大"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><div><pre><code><span>span</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>:::</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/demo.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="幻灯片" tabindex="-1"> 幻灯片</h3>
<i>Content not supported</i><ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/presentation.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<hr>
<section>
<ol>
<li id="footnote1"><p>这是脚注内容 </p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>页面配置</title>
      <link>https://dearlocation.com/guide/page.html</link>
      <guid>https://dearlocation.com/guide/page.html</guid>
      <source url="https://dearlocation.com/rss.xml">页面配置</source>
      <description>more 注释之前的内容被视为文章摘要。
</description>
      <category>使用指南</category>
      <pubDate>Wed, 01 Jan 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><code>more</code> 注释之前的内容被视为文章摘要。</p>

<h2 id="页面信息" tabindex="-1"> 页面信息</h2>
<p>你可以在 Markdown 的 Frontmatter 中设置页面信息。</p>
<ul>
<li>
<p>作者设置为 Ms.Hope。</p>
</li>
<li>
<p>写作时间应为 2020 年 1 月 1 日</p>
</li>
<li>
<p>分类为 “使用指南”</p>
</li>
<li>
<p>标签为 “页面配置” 和 “使用指南”</p>
</li>
</ul>
<h2 id="页面内容" tabindex="-1"> 页面内容</h2>
<p>你可以自由在这里书写你的 Markdown。</p>
<div><p>Tips</p>
<ul>
<li>
<p>Markdown 文件夹的图片请使用相对链接 <code>./</code> 进行引用。</p>
</li>
<li>
<p><code>.vuepress/public</code> 文件夹的图片，请使用绝对链接 <code>/</code> 进行引用</p>
</li>
</ul>
</div>
<p>主题包含了一个自定义徽章章可以使用:</p>
<blockquote>
<p>文字结尾应该有深蓝色的 徽章文字 徽章。 <i>Content not supported</i></p>
</blockquote>
<h2 id="页面结构" tabindex="-1"> 页面结构</h2>
<p>此页面应当包含：</p>
<ul>
<li>返回顶部按钮</li>
<li>路径导航</li>
<li>评论</li>
<li>页脚</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>公众号</title>
      <link>https://dearlocation.com/me/</link>
      <guid>https://dearlocation.com/me/</guid>
      <source url="https://dearlocation.com/rss.xml">公众号</source>
      <pubDate>Tue, 28 Jun 2022 11:46:24 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本站完善中，谢谢你的关注</p>
</blockquote>
<p>关于我</p>
<h2 id="目录" tabindex="-1"> 目录</h2>
<p><a href="/me/2022-04/essay.html">2022-04</a></p>
<h1 id="公众号" tabindex="-1"> 公众号</h1>
<p>推荐一波~</p>
<p><img src="https://www.yangchunjian.com/docbook/imgs/qrcode_for_gh_8756901e5b12_344.jpg" alt="公众号" loading="lazy"></p>
<hr>
<h2 id="联系我" tabindex="-1"> 联系我</h2>
<p>交流/加群/互看朋友圈，欢迎添加我的微信（备注“DearLocation”即可）。</p>
<p><img src="https://javainterview.cn/img/weixin.jpeg" alt="微信" loading="lazy"></p>
]]></content:encoded>
      <enclosure url="https://www.yangchunjian.com/docbook/imgs/qrcode_for_gh_8756901e5b12_344.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>10道不得不会的缓存面试题</title>
      <link>https://dearlocation.com/willbe/0-cache-interview-must.html</link>
      <guid>https://dearlocation.com/willbe/0-cache-interview-must.html</guid>
      <source url="https://dearlocation.com/rss.xml">10道不得不会的缓存面试题</source>
      <description>缓存
</description>
      <category>最少必要面试题</category>
      <pubDate>Wed, 15 Jun 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>缓存</p>

<p>10道不得不会的 缓存 面试题</p>
<p>以下是 缓存 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。<strong>DearLocation</strong>在这里整理这些容易忘记的重点知识及<strong>解答</strong>，<code>建议收藏，经常温习查阅</code>。</p>
<p>评论区见</p>
<p>什么是缓存穿透？怎么解决？</p>
<p>缓存雪崩</p>
<p>怎么保证缓存和数据库数据的一致性？</p>
<p>@[toc]</p>
<h3 id="_1" tabindex="-1"> 1. ？</h3>
<h3 id="" tabindex="-1"> </h3>
<h3 id="-1" tabindex="-1"> </h3>
<h3 id="-2" tabindex="-1"> </h3>
<h3 id="-3" tabindex="-1"> </h3>
<h3 id="-4" tabindex="-1"> </h3>
<h3 id="-5" tabindex="-1"> </h3>
<h3 id="-6" tabindex="-1"> </h3>
<h2 id="推荐阅读" tabindex="-1"> 推荐阅读：</h2>
<p><a href="/willbe/java-basics-interview-must.html">【Java基础】10道不得不会的Java基础面试题</a></p>
<p><a href="java-concurrent-interview-must">【Java并发】10道不得不会的Java并发基础面试题</a></p>
<p><a href="/willbe/mysql-interview-must.html">【MySQL】10道不得不会的MySQL基础面试题</a></p>
<p><a href="/willbe/elasticsearch-interview-must.html">【ElasticSearch】10道不得不会的ElasticSearch面试题</a></p>
<p><a href="/willbe/jvm-interview-must.html">【JVM】10道不得不会的JVM面试题</a></p>
<p><a href="/willbe/willbe/spring-interview-must.html">【Spring】10道不得不会的Spring面试题</a></p>
<p><a href="https://github.com/yangchunjian" target="_blank" rel="noopener noreferrer">GItHub</a>|<a href="https://gitee.com/yangchunjian" target="_blank" rel="noopener noreferrer">GitEE</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>10道不得不会的Java容器面试题</title>
      <link>https://dearlocation.com/willbe/0-java-container-interview-must.html</link>
      <guid>https://dearlocation.com/willbe/0-java-container-interview-must.html</guid>
      <source url="https://dearlocation.com/rss.xml">10道不得不会的Java容器面试题</source>
      <description>Java 容器
</description>
      <category>最少必要面试题</category>
      <pubDate>Sat, 23 Apr 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Java 容器</p>

<p>10道不得不会的Java容器面试题</p>
<p>以下都是 <strong>Java容器常见面试题</strong>，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。<strong>DearLocation</strong>在这里整理这些容易忘记的重点知识及<strong>解答</strong>，<code>建议收藏，经常温习查阅</code>。</p>
<p>评论区见</p>
<p>[toc]</p>
<p><a href="https://mp.weixin.qq.com/s/3Nviyml0cvnX_HHkZ5DjWg" target="_blank" rel="noopener noreferrer">【Java基础】10道不得不会的Java基础面试题</a></p>
<p><a href="https://mp.weixin.qq.com/s/h2tTwDVqL15rCI6rftgn9A" target="_blank" rel="noopener noreferrer">【Java并发】10道不得不会的Java并发基础面试题</a></p>
<p><a href="https://mp.weixin.qq.com/s/yVPwCoSQ-8OYvhw8bH0PtA" target="_blank" rel="noopener noreferrer">【MySQL】10道不得不会的MySQL基础面试题</a></p>
<p><a href="https://mp.weixin.qq.com/s/z3D37HqeTUmwrdheUL_Efw" target="_blank" rel="noopener noreferrer">【ElasticSearch】10道不得不会的ElasticSearch面试题</a></p>
<p><a href="/willbe/jvm-interview-must.html">【JVM】10道不得不会的JVM面试题</a></p>
<p><a href="/willbe/spring-interview-must.html">【Spring】10道不得不会的Spring面试题</a></p>
<p><a href="https://github.com/yangchunjian" target="_blank" rel="noopener noreferrer">GItHub</a>|<a href="https://gitee.com/yangchunjian" target="_blank" rel="noopener noreferrer">GitEE</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>10道不得不会的 Zookeeper 面试题</title>
      <link>https://dearlocation.com/willbe/0-zookeeper-interview-must.html</link>
      <guid>https://dearlocation.com/willbe/0-zookeeper-interview-must.html</guid>
      <source url="https://dearlocation.com/rss.xml">10道不得不会的 Zookeeper 面试题</source>
      <description>Zookeeper
</description>
      <category>最少必要面试题</category>
      <pubDate>Thu, 23 Jun 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Zookeeper</p>

<p>10道不得不会的 Zookeeper 面试题</p>
<p>我是DearLocation，专注于面试、副业，技术人的成长记录。</p>
<p>以下是 Zookeeper 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。<strong>DearLocation</strong>在这里整理这些容易忘记的重点知识及<strong>解答</strong>，<code>建议收藏，经常温习查阅</code>。</p>
<p>评论区见</p>
<p>@[toc]</p>
<h1 id="zookeeper" tabindex="-1"> Zookeeper</h1>
<p>本系列<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzNDUyOTY0Nw==&amp;action=getalbum&amp;album_id=2344061143381508097#wechat_redirect" target="_blank" rel="noopener noreferrer">《最少必要面试题》</a></p>
<h3 id="_1-什么是-zookeeper" tabindex="-1"> 1. 什么是 Zookeeper</h3>
<p>低谷蓄力</p>
<p><strong>《最少必要面试题》</strong></p>
<p><a href="https://javapub.blog.csdn.net/article/details/122011870" target="_blank" rel="noopener noreferrer">10道不得不会的Java基础面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/122159231" target="_blank" rel="noopener noreferrer">10道不得不会的Java并发基础面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/124008535" target="_blank" rel="noopener noreferrer">10道不得不会的JVM面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/122087243" target="_blank" rel="noopener noreferrer">10道不得不会的MySQL基础面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的MyBatis面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的Spring面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/123761794" target="_blank" rel="noopener noreferrer">10道不得不会的ElasticSearch面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的Redis面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的Kafka面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的Zookeeper面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的Docker面试题</a></p>
<p><img src="https://tvax3.sinaimg.cn/large/007F3CC8ly1h3i5qc8fnyj30j708qq4k.jpg" alt="image" loading="lazy"></p>
]]></content:encoded>
      <enclosure url="https://tvax3.sinaimg.cn/large/007F3CC8ly1h3i5qc8fnyj30j708qq4k.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>10道不得不会的 Docker 面试题</title>
      <link>https://dearlocation.com/willbe/docker-interview-must.html</link>
      <guid>https://dearlocation.com/willbe/docker-interview-must.html</guid>
      <source url="https://dearlocation.com/rss.xml">10道不得不会的 Docker 面试题</source>
      <description>Docker
</description>
      <category>最少必要面试题</category>
      <pubDate>Sun, 19 Jun 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Docker</p>

<p>10道不得不会的 Docker 面试题</p>
<p>我是DearLocation，专注于面试、副业，技术人的成长记录。</p>
<p>以下是 Docker 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。<strong>DearLocation</strong>在这里整理这些容易忘记的重点知识及<strong>解答</strong>，<code>建议收藏，经常温习查阅</code>。</p>
<p>评论区见</p>
<p>@[toc]</p>
<h1 id="docker" tabindex="-1"> Docker</h1>
<p>以下是一些docker的基础面试题，下一篇docker进阶面试题。本系列《最少必要面试题》</p>
<h3 id="_1-什么是-docker-容器" tabindex="-1"> 1. 什么是 Docker 容器？</h3>
<p>Docker 是一种流行的开源软件平台，可简化创建、管理、运行和分发应用程序的过程。它使用容器来打包应用程序及其依赖项。我们也可以将容器视为 Docker 镜像的运行时实例。</p>
<h3 id="_2-docker-和虚拟机有什么不同" tabindex="-1"> 2. Docker 和虚拟机有什么不同？</h3>
<p>Docker 是轻量级的沙盒，在其中运行的只是应用，虚拟机里面还有额外的系统。</p>
<h3 id="_3-什么是-dockerfile" tabindex="-1"> 3. 什么是 DockerFile？</h3>
<p>Dockerfile 是一个文本文件，其中包含我们需要运行以构建 Docker 镜像的所有命令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。Docker 使用 Dockerfile 中的指令自动构建镜像。我们可以 <code>docker build</code> 用来创建按顺序执行多个命令行指令的自动构建。</p>
<p><strong>一些最常用的指令如下：</strong></p>
<div><pre><code>FROM ：使用 FROM 为后续的指令建立基础映像。在所有有效的 Dockerfile 中， FROM 是第一条指令。

LABEL： LABEL 指令用于组织项目映像，模块，许可等。在自动化布署方面 LABEL 也有很大用途。在 LABEL 中指定一组键值对，可用于程序化配置或布署 Docker 。

RUN： RUN 指令可在映像当前层执行任何命令并创建一个新层，用于在映像层中添加功能层，也许最来的层会依赖它。

CMD： 使用 CMD 指令为执行的容器提供默认值。在 Dockerfile 文件中，若添加多个 CMD 指令，只有最后的 CMD 指令运行。
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="_4-使用docker-compose时如何保证容器a先于容器b运行" tabindex="-1"> 4. 使用Docker Compose时如何保证容器A先于容器B运行？</h3>
<blockquote>
<p>Docker Compose 是一个用来定义和运行复杂应用的Docker工具。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。Compose 通过一个配置文件来管理多个Docker容器。简单理解：Docker Compose 是docker的管理工具。</p>
</blockquote>
<p>Docker Compose 在继续下一个容器之前不会等待容器准备就绪。为了控制我们的执行顺序，我们可以使用“<strong>取决于</strong>”条件，<code>depends_on</code> 。这是在 docker-compose.yml 文件中使用的示例</p>
<div><pre><code><span>version</span><span>:</span> <span>"2.4"</span>

<span>services</span><span>:</span>

 <span>backend</span><span>:</span>

   <span>build</span><span>:</span> .    <span># 构建自定义镜像</span>

   <span>depends_on</span><span>:</span>

     <span>-</span> db

 <span>db</span><span>:</span>

   <span>image</span><span>:</span> mysql
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>用 <code>docker-compose up</code> 命令将按照我们指定的依赖顺序启动和运行服务。</p>
<h3 id="_5-一个完整的docker由哪些部分组成" tabindex="-1"> 5. 一个完整的Docker由哪些部分组成?</h3>
<ul>
<li>DockerClient 客户端</li>
<li>Docker Daemon 守护进程</li>
<li>Docker Image 镜像</li>
<li>DockerContainer 容器</li>
</ul>
<h3 id="_6-docker常用命令" tabindex="-1"> 6. docker常用命令</h3>
<blockquote>
<p>命令建议在本地安装做一个实操，记忆会更深刻。
也可以克隆基于docker的俩万（springboot+vue）项目练手，提供视频+完善文档。地址：<a href="https://gitee.com/yangchunjian/liawan-vue" target="_blank" rel="noopener noreferrer">https://gitee.com/yangchunjian/liawan-vue</a></p>
</blockquote>
<ol>
<li>查看本地主机的所用镜像：`docker images``</li>
<li>搜索镜像：`docker search mysql``</li>
<li>下载镜像：<code>docker pull mysql</code>，没写 tag 就默认下载最新的 lastest</li>
<li>下载指定版本的镜像：`docker pull mysql:5.7``</li>
<li>删除镜像：`docker rmi -f 镜像id 镜像id 镜像id``</li>
</ol>
<h3 id="_7-描述-docker-容器的生命周期。" tabindex="-1"> 7. 描述 Docker 容器的生命周期。</h3>
<p>Docker 容器经历以下阶段：</p>
<ul>
<li>创建容器</li>
<li>运行容器</li>
<li>暂停容器（可选）</li>
<li>取消暂停容器（可选）</li>
<li>启动容器</li>
<li>停止容器</li>
<li>重启容器</li>
<li>杀死容器</li>
<li>销毁容器</li>
</ul>
<h3 id="_8-docker容器之间怎么隔离" tabindex="-1"> 8. docker容器之间怎么隔离?</h3>
<blockquote>
<p>这是一道涉猎很广泛的题目，理解性阅读。</p>
</blockquote>
<p>Linux中的PID、IPC、网络等资源是全局的，而Linux的NameSpace机制是一种资源隔离方案，在该机制下这些资源就不再是全局的了，而是属于某个特定的NameSpace，各个NameSpace下的资源互不干扰。</p>
<p>​​**Namespace实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容​​。**对于宿主机来说，这些被“隔离”了的进程跟其他进程并没有区别。</p>
<p>虽然有了NameSpace技术可以实现资源隔离，但进程还是可以不受控的访问系统资源，比如CPU、内存、磁盘、网络等，为了控制容器中进程对资源的访问，Docker采用control groups技术(也就是cgroup)，有了cgroup就可以控制容器中进程对系统资源的消耗了，比如你可以限制某个容器使用内存的上限、可以在哪些CPU上运行等等。</p>
<p>有了这两项技术，容器看起来就真的像是独立的操作系统了。</p>
<blockquote>
<p>强烈建议大家实操，才能更好的理解docker。</p>
</blockquote>
<p>低谷蓄力</p>
<p><strong>《最少必要面试题》</strong></p>
<p><a href="https://javapub.blog.csdn.net/article/details/122011870" target="_blank" rel="noopener noreferrer">10道不得不会的Java基础面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/122087243" target="_blank" rel="noopener noreferrer">10道不得不会的MySQL基础面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/122159231" target="_blank" rel="noopener noreferrer">10道不得不会的Java并发基础面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/124008535" target="_blank" rel="noopener noreferrer">10道不得不会的JVM面试题</a></p>
<p><a href="https://blog.csdn.net/qq_40374604/article/details/123761794" target="_blank" rel="noopener noreferrer">10道不得不会的ElasticSearch面试题</a></p>
<p><a href="https://blog.csdn.net/qq_40374604/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的Spring面试题</a></p>
<p><a href="https://blog.csdn.net/qq_40374604/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的 Redis 面试题</a></p>
<p><a href="https://blog.csdn.net/qq_40374604/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的 Kafka 面试题</a></p>
<p><a href="https://blog.csdn.net/qq_40374604/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的 MyBatis 面试题</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>10道不得不会的ElasticSearch面试题</title>
      <link>https://dearlocation.com/willbe/elasticsearch-interview-must.html</link>
      <guid>https://dearlocation.com/willbe/elasticsearch-interview-must.html</guid>
      <source url="https://dearlocation.com/rss.xml">10道不得不会的ElasticSearch面试题</source>
      <description>Elastic Search
</description>
      <category>最少必要面试题</category>
      <pubDate>Thu, 21 Apr 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Elastic Search</p>

<p>10道不得不会的ElasticSearch面试题</p>
<p>以下是 ElasticSearch 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。<strong>DearLocation</strong>在这里整理这些容易忘记的重点知识及<strong>解答</strong>，<code>建议收藏，经常温习查阅</code>。</p>
<p>评论区见</p>
<p><code>关于es的面试，建议使用名词用官方语言描述会更准确。</code></p>
<p>@[toc]</p>
<h2 id="_1-说说你们公司-es-的集群架构-索引数据大小-分片有多少-以及一些调优手段-。" tabindex="-1"> 1. 说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段 。</h2>
<p>节点数、分片数、副本数，尽量根据自己公司使用情况回答，当然适当放大也可行。</p>
<p>调优手段是现在很常见的面试题，下面这几种调优手段一定要了解懂。当然，下面的每一条都可以当做调优的一部分。</p>
<p><strong>设计调优</strong></p>
<p>参考：
<a href="https://www.cnblogs.com/sanduzxcvbnm/p/12084012.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/sanduzxcvbnm/p/12084012.html</a></p>
<p>a. 根据业务增量需求，采取基于日期模板创建索引，通过 <code>rollover API</code> 滚动索引；(rollover API我会单独写一个代码案例做讲解，公众号：DearLocation)
b. 使用别名进行索引管理；（es的索引名不能改变，提供的别名机制使用非常广泛。）
c. 每天凌晨定时对索引做force_merge操作，以释放空间；
d. 采取冷热分离机制，热数据存储到SSD，提高检索效率；冷数据定期进行shrink操作，以缩减存储；
e. 采取curator进行索引的生命周期管理；
f. 仅针对需要分词的字段，合理的设置分词器；
g. Mapping阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。</p>
<p>进100+原创文章：<a href="https://gitee.com/yangchunjian/DearLocation" target="_blank" rel="noopener noreferrer">https://gitee.com/yangchunjian/DearLocation</a></p>
<p><strong>写入调优</strong></p>
<ol>
<li>写入前副本数设置为0；</li>
<li>写入前关闭refresh_interval设置为-1，禁用刷新机制；</li>
<li>写入过程中：采取bulk批量写入；</li>
<li>写入后恢复副本数和刷新间隔；</li>
<li>尽量使用自动生成的id。</li>
</ol>
<p><strong>查询调优</strong></p>
<ol>
<li>禁用wildcard；（通配符模式，类似于%like%）</li>
<li>禁用批量terms（成百上千的场景）；</li>
<li>充分利用倒排索引机制，能keyword类型尽量keyword；</li>
<li>数据量大时候，可以先基于时间敲定索引再检索；</li>
<li>设置合理的路由机制。</li>
</ol>
<h2 id="_2-elasticsearch-的倒排索引是什么" tabindex="-1"> 2. elasticsearch 的倒排索引是什么</h2>
<p>倒排索引也就是单词到文档的映射，当然不只是存里文档id这么简单。还包括：词频（TF，Term Frequency）、偏移量（offset）、位置（Posting）。</p>
<h2 id="_3-elasticsearch-是如何实现-master-选举的" tabindex="-1"> 3. elasticsearch 是如何实现 master 选举的</h2>
<blockquote>
<p>ElasticSearch 的选主是 ZenDiscovery 模块负责，源码分析将首发在。 <a href="https://gitee.com/yangchunjian/DearLocation" target="_blank" rel="noopener noreferrer">https://gitee.com/yangchunjian/DearLocation</a></p>
</blockquote>
<ol>
<li>对所有可以成为 Master 的节点（node.master: true）根据 nodeId 排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是 Master 节点。</li>
<li>如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举。
(当然也可以自己设定一个值，最小值设定为超过能成为Master节点的n/2+1，否则会出现脑裂问题。discovery.zen.minimum_master_nodes)</li>
</ol>
<h2 id="_5-描述一下-elasticsearch-索引文档的过程" tabindex="-1"> 5. 描述一下 Elasticsearch 索引文档的过程</h2>
<p><img src="https://tva3.sinaimg.cn/large/007F3CC8ly1h0niy8fcitj30ku09d3zr.jpg" alt="在这里插入图片描述" loading="lazy"></p>
<ol>
<li>客户端向 Node 1 发送新建、索引或者删除请求。</li>
<li>节点使用文档的 _id 确定文档属于分片 0 。请求会被转发到 Node 3，因为分片 0 的主分片目前被分配在 Node 3 上。</li>
<li>Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。</li>
</ol>
<p><strong>一图胜千文，记住这幅图，上面是文档在节点间分发的过程，接着说一下文档从接收到写入磁盘过程。</strong>
协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合适的分片。</p>
<blockquote>
<p>shard = hash(document_id) % (num_of_primary_shards)</p>
</blockquote>
<ol>
<li>当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 MemoryBuffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache，这个从 MomeryBuffer 到 Filesystem Cache 的过程就叫做 refresh；</li>
<li>当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会丢失，ES 是通过 translog 的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中，当 Filesystem cache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 flush；</li>
<li>在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。</li>
<li>flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认为 512M）时；</li>
</ol>
<div><pre><code><span>1</span>. translog 可以理解为就是一个文件，一直追加。
<span>2</span>. MemoryBuffer 应用缓存。
<span>3</span>. Filesystem Cache 系统缓冲区。
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>延伸阅读：Lucene 的 <code>Segement</code>:</p>
<blockquote>
<ol>
<li>Lucene 索引是由多个段组成，段本身是一个功能齐全的倒排索引。</li>
<li>段是不可变的，允许 Lucene 将新的文档增量地添加到索引中，而不用从头重建索引。</li>
<li>对于每一个搜索请求而言，索引中的所有段都会被搜索，并且每个段会消耗CPU 的时钟周、文件句柄和内存。这意味着段的数量越多，搜索性能会越低。</li>
<li>为了解决这个问题，Elasticsearch 会合并小段到一个较大的段，提交新的合并段到磁盘，并删除那些旧的小段。</li>
</ol>
</blockquote>
<h2 id="_4-详细描述一下-elasticsearch-搜索的过程" tabindex="-1"> 4. 详细描述一下 Elasticsearch 搜索的过程？</h2>
<blockquote>
<p>es作为一个分布式的存储和检索系统，每个文档根据 _id 字段做路由分发被转发到对应的shard上。</p>
</blockquote>
<p>搜索执行阶段过程分俩个部分，我们称之为 Query Then Fetch。</p>
<p><strong>4.1 query-查询阶段</strong></p>
<p>当一个search请求发出的时候，这个query会被广播到索引里面的每一个shard（主shard或副本shard），每个shard会在本地执行查询请求后会生成一个命中文档的优先级队列。</p>
<p>这个队列是一个排序好的top N数据的列表，它的size等于from+size的和，也就是说如果你的from是10，size是10，那么这个队列的size就是20，所以这也是为什么深度分页不能用from+size这种方式，因为from越大，性能就越低。</p>
<p>es里面分布式search的查询流程如下：</p>
<p><img src="https://tva2.sinaimg.cn/large/007F3CC8ly1h0niv378zsj30lh08z75i.jpg" alt="es里面分布式search的查询流程" loading="lazy"></p>
<p>查询阶段包含以下三个步骤:</p>
<ol>
<li>客户端发送一个 search 请求到 Node 3 ， Node 3 会创建一个大小为 from + size 的空优先队列。</li>
<li>Node 3 将查询请求转发到索引的每个主分片或副本分片中。每个分片在本地执行查询并添加结果到大小为 from + size 的本地有序优先队列中。</li>
<li>每个分片返回各自优先队列中所有文档的 ID 和排序值给协调节点，也就是 Node 3 ，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</li>
</ol>
<p><strong>4.2 fetch - 读取阶段 / 取回阶段</strong></p>
<p><img src="https://tva3.sinaimg.cn/large/007F3CC8ly1h0niuhpty3j30ka08mdh1.jpg" alt="在这里插入图片描述" loading="lazy"></p>
<p>分布式阶段由以下步骤构成：</p>
<ol>
<li>协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。</li>
<li>每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。</li>
<li>一旦所有的文档都被取回了，协调节点返回结果给客户端。</li>
</ol>
<p>协调节点首先决定哪些文档 确实 需要被取回。例如，如果我们的查询指定了 { &quot;from&quot;: 90, &quot;size&quot;: 10 } ，最初的90个结果会被丢弃，只有从第91个开始的10个结果需要被取回。这些文档可能来自和最初搜索请求有关的一个、多个甚至全部分片。</p>
<p>协调节点给持有相关文档的每个分片创建一个 multi-get request ，并发送请求给同样处理查询阶段的分片副本。</p>
<p>分片加载文档体-- _source 字段—​如果有需要，用元数据和 search snippet highlighting 丰富结果文档。 一旦协调节点接收到所有的结果文档，它就组装这些结果为单个响应返回给客户端。</p>
<div><pre><code>拓展阅读：
深翻页（Deep Pagination）
---
先查后取的过程支持用 from 和 size 参数分页，但是这是 有限制的 。 要记住需要传递信息给协调节点的每个分片必须先创建一个 from + size 长度的队列，协调节点需要根据 number_of_shards * <span>(</span>from + size<span>)</span> 排序文档，来找到被包含在 size 里的文档。

取决于你的文档的大小，分片的数量和你使用的硬件，给 <span>10,000</span> 到 <span>50,000</span> 的结果文档深分页（ <span>1,000</span> 到 <span>5,000</span> 页）是完全可行的。但是使用足够大的 from 值，排序过程可能会变得非常沉重，使用大量的CPU、内存和带宽。因为这个原因，我们强烈建议你不要使用深分页。

实际上， “深分页” 很少符合人的行为。当2到3页过去以后，人会停止翻页，并且改变搜索标准。会不知疲倦地一页一页的获取网页直到你的服务崩溃的罪魁祸首一般是机器人或者web spider。

如果你 确实 需要从你的集群取回大量的文档，你可以通过用 scroll 查询禁用排序使这个取回行为更有效率，我们会在 later <span>in</span> this chapter 进行讨论。
注：https://www.elastic.co/guide/cn/elasticsearch/guide/current/scroll.html
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_5-elasticsearch-在部署时-对-linux-的设置有哪些优化方法" tabindex="-1"> 5. Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法</h2>
<ol>
<li>关闭缓存swap;</li>
</ol>
<blockquote>
<p>原因：大多数操作系统会将内存使用到文件系统缓存，会将应用程序未用到的内存交换出去。会导致jvm的堆内存交换到磁盘上。交换会导致性能问题。会导致内存垃圾回收延长。会导致集群节点响应时间变慢，或者从集群中断开。</p>
</blockquote>
<ol start="2">
<li>
<p>堆内存设置为：Min（节点内存/2, 32GB）;</p>
</li>
<li>
<p>设置最大文件句柄数；</p>
</li>
</ol>
<p><strong>后俩点不懂可以先说有一定了解，关注DearLocation会做详细讲解。</strong></p>
<ol start="4">
<li>
<p>调整线程池和队列大小</p>
</li>
<li>
<p>磁盘存储 raid 方式——存储有条件使用 RAID6，增加单节点性能以及避免单节点存储故障。</p>
</li>
</ol>
<blockquote>
<p><a href="https://www.elastic.co/cn/blog/how-to-design-your-elasticsearch-data-storage-architecture-for-scale#raid56" target="_blank" rel="noopener noreferrer">https://www.elastic.co/cn/blog/how-to-design-your-elasticsearch-data-storage-architecture-for-scale#raid56</a></p>
</blockquote>
<h2 id="_6-elasticsearch-中的节点-比如共-20-个-其中的-10-个选了一个-master-另外-10-个选了另一个-master-怎么办" tabindex="-1"> 6. Elasticsearch 中的节点（比如共 20 个），其中的 10 个选了一个 master，另外 10 个选了另一个 master，怎么办？</h2>
<ol>
<li>
<p>当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题；</p>
</li>
<li>
<p>当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data节点，避免脑裂问题。</p>
</li>
</ol>
<h2 id="_7-客户端在和集群连接时-如何选择特定的节点执行请求的" tabindex="-1"> 7. 客户端在和集群连接时，如何选择特定的节点执行请求的？</h2>
<p>client 远程连接连接一个 elasticsearch 集群。它并不加入到集群中，只是获得一个或者多个初始化的地址，并以轮询的方式与这些地址进行通信。</p>
<h2 id="_8-详细描述一下-elasticsearch-更新和删除文档的过程。" tabindex="-1"> 8. 详细描述一下 Elasticsearch 更新和删除文档的过程。</h2>
<ol>
<li>删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更；(根本原因是底层lucene的segment段文件不可更新删除)</li>
<li>磁盘上的每个段都有一个相应的 .del 文件。当删除请求发送后，文档并没有真 的被删除，而是在 <code>.del</code> 文件中被标记为删除。该文档依然能匹配查询，但是会在 结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入 新段。</li>
<li>在新的文档被创建时，Elasticsearch 会为该文档指定一个版本号，当执行更新 时，旧版本的文档在.del 文件中被标记为删除，新版本的文档被索引到一个新段。</li>
</ol>
<p>旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</p>
<h2 id="_9-elasticsearch-对于大数据量-上亿量级-的聚合如何实现" tabindex="-1"> 9. Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？</h2>
<blockquote>
<p>这道题目较难，相信大家看到很多类似这种回答</p>
</blockquote>
<p>Elasticsearch 提供的首个近似聚合是cardinality 度量。它提供一个字段的基数，即该字段的distinct或者unique值的数目。它是基于HLL算法的。HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</p>
<p><strong>科普&amp;拓展</strong>：</p>
<div><pre><code>HyperLogLog：
下面简称为HLL，它是 LogLog 算法的升级版，作用是能够提供不精确的去重计数。存在以下的特点：
<span>1</span>. 能够使用极少的内存来统计巨量的数据，在 Redis 中实现的 HyperLogLog，只需要12K内存就能统计2^64个数据。
<span>2</span>. 计数存在一定的误差，误差率整体较低。标准误差为 <span>0.81</span>% 。
<span>3</span>. 误差可以被设置辅助计算因子进行降低。
---
应用场景：
<span>1</span>. 基数不大，数据量不大就用不上，会有点大材小用浪费空间
<span>2</span>. 有局限性，就是只能统计基数数量，而没办法去知道具体的内容是什么
<span>3</span>. 和bitmap相比，属于两种特定统计情况，简单来说，HyperLogLog 去重比 bitmap 方便很多
<span>4</span>. 一般可以bitmap和hyperloglog配合使用，bitmap标识哪些用户活跃，hyperloglog计数
---
应用场景：
<span>1</span>. 基数不大，数据量不大就用不上，会有点大材小用浪费空间
<span>2</span>. 有局限性，就是只能统计基数数量，而没办法去知道具体的内容是什么
<span>3</span>. 和bitmap相比，属于两种特定统计情况，简单来说，HyperLogLog 去重比 bitmap 方便很多
<span>4</span>. 一般可以bitmap和hyperloglog配合使用，bitmap标识哪些用户活跃，hyperloglog计数
来源：刷刷面试
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_10-在并发情况下-elasticsearch-如果保证读写一致" tabindex="-1"> 10. 在并发情况下，Elasticsearch 如果保证读写一致？</h2>
<blockquote>
<p>首先要了解什么是一致性，在分布式系统中，我们一般通过CPA理论分析。</p>
</blockquote>
<p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。
<img src="https://tvax4.sinaimg.cn/large/007F3CC8ly1h0nitw2kjwj30nk0l5goe.jpg" alt="分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。" loading="lazy"></p>
<ol>
<li>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</li>
<li>另外对于写操作，一致性级别支持 quorum/one/all，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</li>
<li>对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查询主分片，确保文档是最新版本。</li>
</ol>
<h2 id="_11-介绍一下你们的个性化搜索方案" tabindex="-1"> 11. 介绍一下你们的个性化搜索方案？</h2>
<blockquote>
<p>如果你没有很多实战经验，可以基于 word2vec 做一些练习，我的博客提供了 word2vec Java版的一些Demo。</p>
</blockquote>
<p>基于 word2vec 和 Elasticsearch 实现个性化搜索，它有以下优点：</p>
<ol>
<li>基于word2vec的商品向量还有一个可用之处，就是可以用来实现相似商品的推荐；</li>
</ol>
<h2 id="推荐阅读" tabindex="-1"> 推荐阅读：</h2>
<p><a href="/willbe/java-basics-interview-must.html">【Java基础】10道不得不会的Java基础面试题</a></p>
<p><a href="java-concurrent-interview-must">【Java并发】10道不得不会的Java并发基础面试题</a></p>
<p><a href="/willbe/mysql-interview-must.html">【MySQL】10道不得不会的MySQL基础面试题</a></p>
<p><a href="/willbe/elasticsearch-interview-must.html">【ElasticSearch】10道不得不会的ElasticSearch面试题</a></p>
<p><a href="/willbe/jvm-interview-must.html">【JVM】10道不得不会的JVM面试题</a></p>
<p><a href="/willbe/willbe/spring-interview-must.html">【Spring】10道不得不会的Spring面试题</a></p>
<p><a href="https://github.com/yangchunjian" target="_blank" rel="noopener noreferrer">GItHub</a>|<a href="https://gitee.com/yangchunjian" target="_blank" rel="noopener noreferrer">GitEE</a></p>
]]></content:encoded>
      <enclosure url="https://tva3.sinaimg.cn/large/007F3CC8ly1h0niy8fcitj30ku09d3zr.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>10道不得不会的Java基础面试题</title>
      <link>https://dearlocation.com/willbe/java-basics-interview-must.html</link>
      <guid>https://dearlocation.com/willbe/java-basics-interview-must.html</guid>
      <source url="https://dearlocation.com/rss.xml">10道不得不会的Java基础面试题</source>
      <description>Java 基础
</description>
      <category>最少必要面试题</category>
      <pubDate>Thu, 21 Apr 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Java 基础</p>

<p>10道不得不会的Java基础面试题</p>
<p>以下都是Java的基础面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。<strong>DearLocation</strong>在这里整理这些容易忘记的重点知识及<strong>解答</strong>，<code>建议收藏，经常温习查阅</code>。</p>
<p>评论区见</p>
<hr>
<hr>
<p>@[toc]</p>
<h2 id="_1-instanceof-关键字的作用" tabindex="-1"> 1. instanceof 关键字的作用</h2>
<p>instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p>
<div><pre><code><span>boolean</span> result <span>=</span> obj <span>instanceof</span> <span>class</span> 
</code></pre><div aria-hidden="true"><div></div></div></div><p>当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。</p>
<p>注意一点：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</p>
<p>obj 必须为引用类型，只能作为对象的判断，不能是基本类型。</p>
<div><pre><code><span>int</span> i <span>=</span> <span>0</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i <span>instanceof</span> <span>Integer</span><span>)</span><span>;</span><span>//编译不通过</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i <span>instanceof</span> <span>Object</span><span>)</span><span>;</span><span>//编译不通过</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>源码参考：JavaSE 8 instanceof 的实现算法：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.instanceof" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.instanceof</a></p>
<h2 id="_2-java自动装箱和拆箱" tabindex="-1"> 2. Java自动装箱和拆箱</h2>
<p>什么是装箱拆箱，这里不做源码层面解读，源码解读在DearLocation公众号发出。这里通过讲解 int 和 Interger 区别，解答Java自动装箱和拆箱。</p>
<blockquote>
<p>自动装箱 ----- 基本类型的值 → 包装类的实例</p>
<p>自动拆箱 ----- 基本类型的值 ← 包装类的实例</p>
</blockquote>
<ol>
<li>Integer变量必须实例化后才能使用，而int变量不需要</li>
<li>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 。</li>
<li>Integer的默认值是null，int的默认值是0</li>
</ol>
<p>Java中8种基本数据类型。左边基本类型，右边包装类型。
<img src="https://img-blog.csdnimg.cn/fa68ecc8af4e4b679e48c2703cf897c7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASmF2YVB1Yi1yb2RlcnQ=,size_8,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>在面试中：</strong></p>
<p>下面这段代码的输出结果是什么？</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
         
        <span>Integer</span> i1 <span>=</span> <span>100</span><span>;</span>
        <span>Integer</span> i2 <span>=</span> <span>100</span><span>;</span>
        <span>Integer</span> i3 <span>=</span> <span>200</span><span>;</span>
        <span>Integer</span> i4 <span>=</span> <span>200</span><span>;</span>
         
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1<span>==</span>i2<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i3<span>==</span>i4<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
 
<span>//true</span>
<span>//false</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：</p>
<div><pre><code><span>public</span> <span>static</span> <span>Integer</span> <span>valueOf</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>
        <span>if</span><span>(</span>i <span>>=</span> <span>-</span><span>128</span> <span>&amp;&amp;</span> i <span>&lt;=</span> <span>IntegerCache</span><span>.</span>high<span>)</span>
            <span>return</span> <span>IntegerCache</span><span>.</span>cache<span>[</span>i <span>+</span> <span>128</span><span>]</span><span>;</span>
        <span>else</span>
            <span>return</span> <span>new</span> <span>Integer</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>private</span> <span>static</span> <span>class</span> <span>IntegerCache</span> <span>{</span>
        <span>static</span> <span>final</span> <span>int</span> high<span>;</span>
        <span>static</span> <span>final</span> <span>Integer</span> cache<span>[</span><span>]</span><span>;</span>
 
        <span>static</span> <span>{</span>
            <span>final</span> <span>int</span> low <span>=</span> <span>-</span><span>128</span><span>;</span>
 
            <span>// high value may be configured by property</span>
            <span>int</span> h <span>=</span> <span>127</span><span>;</span>
            <span>if</span> <span>(</span>integerCacheHighPropValue <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                <span>// Use Long.decode here to avoid invoking methods that</span>
                <span>// require Integer's autoboxing cache to be initialized</span>
                <span>int</span> i <span>=</span> <span>Long</span><span>.</span><span>decode</span><span>(</span>integerCacheHighPropValue<span>)</span><span>.</span><span>intValue</span><span>(</span><span>)</span><span>;</span>
                i <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>i<span>,</span> <span>127</span><span>)</span><span>;</span>
                <span>// Maximum array size is Integer.MAX_VALUE</span>
                h <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>i<span>,</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>-</span>low<span>)</span><span>;</span>
            <span>}</span>
            high <span>=</span> h<span>;</span>
 
            cache <span>=</span> <span>new</span> <span>Integer</span><span>[</span><span>(</span>high <span>-</span> low<span>)</span> <span>+</span> <span>1</span><span>]</span><span>;</span>
            <span>int</span> j <span>=</span> low<span>;</span>
            <span>for</span><span>(</span><span>int</span> k <span>=</span> <span>0</span><span>;</span> k <span>&lt;</span> cache<span>.</span>length<span>;</span> k<span>++</span><span>)</span>
                cache<span>[</span>k<span>]</span> <span>=</span> <span>new</span> <span>Integer</span><span>(</span>j<span>++</span><span>)</span><span>;</span>
        <span>}</span>
 
        <span>private</span> <span>IntegerCache</span><span>(</span><span>)</span> <span>{</span><span>}</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>从这2段代码可以看出，在通过<strong>valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</strong></p>
</blockquote>
<p><strong>上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。</strong></p>
<p><code>注意，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。 Double、Float的valueOf方法的实现是类似的（没有缓存数值，这里的数值想想都有很多，不适合缓存）。</code></p>
<hr>
<h2 id="_3-重载和重写区别" tabindex="-1"> 3. 重载和重写区别</h2>
<p>重载和重写是一个特别好理解的概念，这里说一个通俗的解答方式</p>
<p><strong>重载（Overload）</strong>:首先是位于一个类之中或者其子类中，具有相同的方法名，但是方法的参数不同，返回值类型可以相同也可以不同。</p>
<ol>
<li>方法名必须相同</li>
<li>方法的参数列表一定不一样。</li>
<li>访问修饰符和返回值类型可以相同也可以不同。</li>
</ol>
<p>其实简单而言：重载就是对于不同的情况写不同的方法。 比如，同一个类中，写不同的构造函数用于初始化不同的参数。</p>
<div><pre><code><span>public</span> <span>class</span> <span>DearLocationTest</span> <span>{</span>
    <span>public</span> <span>void</span> <span>out</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"参数"</span><span>+</span><span>null</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//参数数目不同</span>
    <span>public</span> <span>void</span> <span>out</span><span>(</span><span>Integer</span> n<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"参数"</span><span>+</span>n<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
 
    <span>//参数类型不同</span>
    <span>public</span> <span>void</span> <span>out</span><span>(</span><span>String</span> string<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"参数"</span><span>+</span>string<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
 
    <span>public</span> <span>void</span> <span>out</span><span>(</span><span>Integer</span> n <span>,</span><span>String</span> string<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"参数"</span><span>+</span>n<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>","</span><span>+</span>string<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//参数顺序不同</span>
    <span>public</span> <span>void</span> <span>out</span><span>(</span><span>String</span> string<span>,</span><span>Integer</span> n<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"参数"</span><span>+</span>string<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>","</span><span>+</span>n<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
    
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>DearLocationTest</span> javaPubTest <span>=</span> <span>new</span> <span>DearLocationTest</span><span>(</span><span>)</span><span>;</span>
        javaPubTest<span>.</span><span>out</span><span>(</span><span>)</span><span>;</span>
        javaPubTest<span>.</span><span>out</span><span>(</span><span>1</span><span>)</span><span>;</span>
        javaPubTest<span>.</span><span>out</span><span>(</span><span>"string"</span><span>)</span><span>;</span>
        javaPubTest<span>.</span><span>out</span><span>(</span><span>1</span><span>,</span><span>"string"</span><span>)</span><span>;</span>
        javaPubTest<span>.</span><span>out</span><span>(</span><span>"string"</span><span>,</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>**重写（Overriding）**发生在父类子类之间，比如所有类都是继承与Object类的，Object类中本身就有equals、hashcode、toString方法等。在任意子类中定义了重名和同样的参数列表就构成方法重写。</p>
<ol>
<li>方法名必须相同，返回值类型必须相同。</li>
<li>参数列表必须相同。</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li>
<li>构造方法不能被重写。</li>
</ol>
<hr>
<h2 id="_4-equals与-区别" tabindex="-1"> 4. equals与==区别</h2>
<p><strong>&quot;==&quot;是判断两个变量或实例是不是指向同一个内存空间。</strong>
<strong>&quot;equals&quot;是判断两个变量或实例所指向的内存空间的值是不是相同。</strong></p>
<p>除了这俩点，这个问题大概率会引出以下问题：</p>
<blockquote>
<p>为什么重写equals还要重写hashcode?</p>
</blockquote>
<p>通过上面俩条我们知道 <strong>&quot;equals&quot;是判断两个变量或实例所指向的内存空间的值是不是相同。</strong> 但是一些特殊场景，我们需要对比俩个对象是否相等，例如：<code>User user1 = new User();</code> <code>User user2 = new User();</code> user1 和 user2 对比。这是我们就需要重写 equals 方法。</p>
<p>所以可以通过重写equals()方法来判断对象的值是否相等，但是有一个要求：<strong>equals()方法实现了等价关系</strong>，即：</p>
<ul>
<li>自反性：对于任何非空引用x，x.equals(x)应该返回true；</li>
<li>对称性：对于任何引用x和y，如果x.equals(y)返回true，那么y.equals(x)也应该返回true；</li>
<li>传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true；</li>
<li>一致性：如果x和y引用的对象没有发生变化，那么反复调用x.equals(y)应该返回同样的结果；</li>
<li>非空性：对于任意非空引用x，x.equals(null)应该返回false；</li>
</ul>
<p>到这里也是一个很正常的操作，但是当我们要用到 HashSet 等集合时。存储的对象我们需要用 <code>hashcode 判断对象是否存在</code>，如果使用 Object 默认的hashcode方法，那我们同样属性的俩个用户一定是不相等的(例如下面user3、user4)，因为内存地址不同，这并不符合我们的业务，所以决定了重写 hashcode 的必要性。</p>
<div><pre><code><span>User</span> user3 <span>=</span> <span>new</span> <span>User</span><span>(</span><span>"DearLocation"</span><span>,</span> <span>"man"</span><span>,</span> <span>"1996-08-28"</span><span>)</span>
<span>User</span> user4 <span>=</span> <span>new</span> <span>User</span><span>(</span><span>"DearLocation"</span><span>,</span> <span>"man"</span><span>,</span> <span>"1996-08-28"</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><hr>
<h2 id="_5-谈谈nio和bio区别" tabindex="-1"> 5. 谈谈NIO和BIO区别</h2>
<p>致力于大白话说清楚。NIO和BIO是一个相对有点抽象的概念，如果你对网络有点了解，理解起来可能会更顺畅。首先说一下基本</p>
<p><strong>BIO</strong>：同步阻塞IO，每一个客户端连接，服务端都会对应一个处理线程，对于没有分配到处理线程的连接就会被阻塞或者拒绝。相当于是<code>一个连接一个线程</code>。</p>
<p><strong>NIO</strong>：同步非阻塞IO，基于Reactor模型，客户端和channel进行通信，channel可以进行读写操作，通过多路复用器selector来轮询注册在其上的channel，而后再进行IO操作。这样的话，在进行IO操作的时候再用一个线程去处理就可以了，也就是<code>一个请求一个线程</code>。</p>
<blockquote>
<p>Reactor模型是什么?</p>
<ol>
<li>基于池化思想，避免为每个连接创建线程，连接完成后将业务处理交给线程池处理</li>
<li>基于IO复用模型，多个连接共用同一个阻塞对象，不用等待所有的连接。遍历到有新数据可以处理时，操作系统会通知程序，线程跳出阻塞状态，进行业务逻辑处理
.</li>
</ol>
<p>简单来说：Reactor线程模型的思想就是基于IO复用和线程池的结合。</p>
</blockquote>
<p><strong>AIO</strong>：（一般都会把AIO和NIO、BIO放一块比较，这里简单提一下。）异步非阻塞IO，相比NIO更进一步，完全由操作系统来完成请求的处理，然后通知服务端开启线程去进行处理，因此是<code>一个有效请求一个线程</code>。</p>
<p><strong>那么怎么理解同步和阻塞？</strong></p>
<p>首先，可以认为一个IO操作包含两个部分：</p>
<ol>
<li>发起IO请求</li>
<li>实际的IO读写操作</li>
</ol>
<p>同步和异步在于第二个，实际的IO读写操作，如果操作系统帮你完成了再通知你，那就是异步，否则都叫做同步。</p>
<p>阻塞和非阻塞在于第一个，发起IO请求，对于NIO来说通过channel发起IO操作请求后，其实就返回了，所以是非阻塞。</p>
<p>NIO和BIO是非常重要的计算机知识，学习后会对整个计算机的理解更近一步，一次学会终身受益。DearLocation会单独写一篇深入图解NIO和BIO。</p>
<p>网上看到一个例子（一定要看，会对你有所帮助）：</p>
<div><pre><code>一辆从 A 开往 B 的公共汽车上，路上有很多点可能会有人下车。司机不知道哪些点会有哪些人会下车，对于需要下车的人，如何处理更好？   

1. 司机过程中定时询问每个乘客是否到达目的地，若有人说到了，那么司机停车，乘客下车。 ( 类似阻塞式 )   

2. 每个人告诉售票员自己的目的地，然后睡觉，司机只和售票员交互，到了某个点由售票员通知乘客下车。 ( 类似非阻塞 )     

很显然，每个人要到达某个目的地可以认为是一个线程，司机可以认为是 CPU 。在阻塞式里面，每个线程需要不断的轮询，上下文切换，以达到找到目的地的结果。而在非阻塞方式里，每个乘客 ( 线程 ) 都在睡觉 ( 休眠 ) ，只在真正外部环境准备好了才唤醒，这样的唤醒肯定不会阻塞。
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>建议阅读：
<a href="https://www.cnblogs.com/aspirant/p/6877350.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/aspirant/p/6877350.html</a>
<a href="https://www.cnblogs.com/shoshana-kong/p/11228555.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/shoshana-kong/p/11228555.html</a></p>
<hr>
<h2 id="_6-string、stringbuffer、stringbuilder-的区别是什么" tabindex="-1"> 6. String、StringBuffer、StringBuilder 的区别是什么？</h2>
<p><strong>String</strong>是Immutable类的典型实现，被声明为 final class，除了hash这个属性其它属性都声明为final。它的不可变性，所以例如拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。</p>
<p>StringBuffer、StringBuilder就是解决String的这个性能问题。</p>
<p><strong>StringBuffer</strong> 是线程安全的，本质是一个线程安全的可修改的字符序列，把所有修改数据的方法都加上synchronized。</p>
<p><strong>StringBuffer</strong> 线程不安全，但是性能更好。</p>
<hr>
<h2 id="_7-泛型是什么-有什么特点" tabindex="-1"> 7. 泛型是什么，有什么特点</h2>
<p>泛型在编码中有非常广泛的使用（jdk5引入），你一定经常能见到类似这种写法 <code>&lt;T&gt;</code> 。</p>
<p>泛型提供了编译时类型安全检测机制，允许在编译时检测到非法的类型。<strong>本质</strong>是参数化类型。</p>
<ol>
<li>把类型当作是参数一样传递</li>
<li>&lt;数据类型&gt;只能是引用类型</li>
</ol>
<p>泛型：就是一种不确定的数据类型。</p>
<p>泛型的好处：</p>
<ol>
<li>省略了强转的代码。</li>
<li>可以把运行时的问题提前到编译时期。</li>
</ol>
<blockquote>
<p>引入泛型主要想实现一个通用的、可以处理不同类型的方法</p>
</blockquote>
<p><strong>泛型擦除:</strong></p>
<p>泛型时提供给javac编译器使用的，用于限定集合的输入类型，让编译器在源代码级别上，避免向集合中插入非法数据。但编译器编译完带有泛型的java程序后，生成的class文件中不再带有泛型信息，以此使程序运行效率不受影响，这个过程称为擦除。</p>
<p>JVM并不知道泛型的存在，因为泛型在编译阶段就已经被处理成普通的类和方法； 处理机制是通过类型擦除，擦除规则：</p>
<ul>
<li>
<p>若泛型类型没有指定具体类型，用Object作为原始类型；</p>
</li>
<li>
<p>若有限定类型&lt; T exnteds XClass &gt;，使用XClass作为原始类型；</p>
</li>
<li>
<p>若有多个限定&lt; T exnteds XClass1 &amp; XClass2 &gt;，使用第一个边界类型XClass1作为原始类型；</p>
</li>
</ul>
<hr>
<h2 id="_8-final-有哪些用法" tabindex="-1"> 8. final 有哪些用法</h2>
<p>final关键字有四个常见用法。</p>
<p><strong>final修饰一个类</strong></p>
<p>当 final 关键字用来修饰一个类的时候，表明这个类不能有任何的子类，也就是说这个类不能被继承。</p>
<p>final类中的所有成员方法都会被隐式地指定为final方法，也就是说一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写。</p>
<div><pre><code>     <span>public</span> <span>final</span> <span>class</span> 类名称 <span>{</span>

      　　<span>// ...</span>

      <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>final修饰一个方法</strong></p>
<p>当 final 关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。</p>
<div><pre><code>    修饰符 <span>final</span> 返回值类型 方法名称<span>(</span>参数列表<span>)</span> <span>{</span>

     　　<span>// 方法体</span>

     <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>注意：对于类、方法来说，abstract 关键字和 final 关键字不能同时使用，因为矛盾。</p>
<p><strong>final修饰一个局部变量</strong></p>
<p>一旦使用 final 用来修饰局部变量，那么这个变量就不能进行更改「一次赋值，终生不变」。</p>
<ol>
<li>对于基本类型来说，不可变说的是变量当中的数据不可改变；</li>
<li>对于引用类型来说，不可变说的是变量当中的地址值不可改变。</li>
</ol>
<p><strong>final修饰一个成员变量</strong></p>
<p>对于成员变量来说，如果使用 final 关键字修饰，那么这个变量也照样是不可变。</p>
<ol>
<li>由于成员变量具有默认值，所以用了 final 之后<strong>必须</strong>手动赋值，不会再给默认值了；</li>
<li>对于 final 的成员变量，要么使用直接赋值，要么通过构造方法赋值，<strong>必须</strong>二者选其一；</li>
<li><strong>必须</strong>保证类当中所有重载的构造方法都最终会对 final 的成员变量进行赋值。</li>
</ol>
<hr>
<h2 id="_9-说一下java注解" tabindex="-1"> 9. 说一下Java注解</h2>
<p>在Java编程中，注解非常常见，注解的本质是什么？</p>
<p>注解大致分为以下三种：</p>
<ol>
<li>
<p>Java原生注解 如@Override，@Deprecated 等。大多用于 [标记] 和 [检查] 。</p>
</li>
<li>
<p>第三方注解，如 Spring、Mybatis等定义的注解（@Controller，@Data）。</p>
</li>
<li>
<p>自定义注解。</p>
</li>
</ol>
<p>Java原生除了提供基本注解，还提供了 meta-annotation（元注解）。这些类型和它们所支持的类在java.lang.annotation包中可以找到。</p>
<ol>
<li>@Target</li>
<li>@Retention</li>
<li>@Documented</li>
<li>@Inherited</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/1b035a1306d5426b9fdba1bd07bb57a4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASmF2YVB1Yi1yb2RlcnQ=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"></p>
<p>一般比较常用的有 @Target，@Retention。<code>@Target</code>表示这个注解可以修饰那些地方（比如类、方法、成员变量），<code>@Retention</code> 主要是设置注解的生命周期。</p>
<blockquote>
<p>这是你一定会被问，</p>
<ol>
<li>有使用过注解吗？</li>
<li>你是怎么使用的？</li>
</ol>
</blockquote>
<p>注解有一个非常常见的使用场景，大家可以用这个来理解学习。</p>
<p><strong>场景一：自定义注解+拦截器 实现登录校验</strong></p>
<p>实现功能：</p>
<p>接下来，我们使用springboot拦截器实现这样一个功能，如果方法上加了@LoginRequired，则提示用户该接口需要登录才能访问，否则不需要登录。</p>
<p>首先定义一个LoginRequired注解</p>
<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>METHOD<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
	<span>public</span> <span>@interface</span> <span>LoginRequired</span> <span>{</span>
    
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>然后写两个简单的接口，访问sourceA，sourceB资源</p>
<div><pre><code><span>@RestController</span>
<span>public</span> <span>class</span> <span>IndexController</span> <span>{</span>

    <span>@GetMapping</span><span>(</span><span>"/sourceA"</span><span>)</span>
    <span>public</span> <span>String</span> <span>sourceA</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>"你正在访问sourceA资源"</span><span>;</span>
    <span>}</span>

    <span>@GetMapping</span><span>(</span><span>"/sourceB"</span><span>)</span>
    <span>public</span> <span>String</span> <span>sourceB</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>"你正在访问sourceB资源"</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>很简单的俩个接口，没添加拦截器之前成功访问</p>
<p><img src="https://img-blog.csdnimg.cn/237de5087d2e46fd9c2388a293ddd690.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASmF2YVB1Yi1yb2RlcnQ=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"></p>
<p>实现 spring 的 HandlerInterceptor 类先实现拦截器，但不拦截，只是简单打印日志，如下：</p>
<div><pre><code><span>public</span> <span>class</span> <span>SourceAccessInterceptor</span> <span>implements</span> <span>HandlerInterceptor</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>preHandle</span><span>(</span><span>HttpServletRequest</span> request<span>,</span> <span>HttpServletResponse</span> response<span>,</span> <span>Object</span> handler<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"进入拦截器了"</span><span>)</span><span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>postHandle</span><span>(</span><span>HttpServletRequest</span> request<span>,</span> <span>HttpServletResponse</span> response<span>,</span> <span>Object</span> handler<span>,</span> <span>ModelAndView</span> modelAndView<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>

    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>afterCompletion</span><span>(</span><span>HttpServletRequest</span> request<span>,</span> <span>HttpServletResponse</span> response<span>,</span> <span>Object</span> handler<span>,</span> <span>Exception</span> ex<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>

    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>实现spring类 WebMvcConfigurer，创建配置类把拦截器添加到拦截器链中</p>
<div><pre><code><span>@Configuration</span>
<span>public</span> <span>class</span> <span>InterceptorTrainConfigurer</span> <span>implements</span> <span>WebMvcConfigurer</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>addInterceptors</span><span>(</span><span>InterceptorRegistry</span> registry<span>)</span> <span>{</span>
        registry<span>.</span><span>addInterceptor</span><span>(</span><span>new</span> <span>SourceAccessInterceptor</span><span>(</span><span>)</span><span>)</span><span>.</span><span>addPathPatterns</span><span>(</span><span>"/**"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>拦截成功如下</p>
<p><img src="https://img-blog.csdnimg.cn/8c2a2de1a354426e99a709d9939e2295.png" alt="在这里插入图片描述" loading="lazy">
在 sourceB 方法上添加我们的登录注解 @LoginRequired</p>
<div><pre><code><span>@RestController</span>
<span>public</span> <span>class</span> <span>IndexController</span> <span>{</span>

    <span>@GetMapping</span><span>(</span><span>"/sourceA"</span><span>)</span>
    <span>public</span> <span>String</span> <span>sourceA</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>"你正在访问sourceA资源"</span><span>;</span>
    <span>}</span>

    <span>@LoginRequired</span>
    <span>@GetMapping</span><span>(</span><span>"/sourceB"</span><span>)</span>
    <span>public</span> <span>String</span> <span>sourceB</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>"你正在访问sourceB资源"</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>简单实现登录拦截逻辑</p>
<div><pre><code>	<span>@Override</span>
    <span>public</span> <span>boolean</span> <span>preHandle</span><span>(</span><span>HttpServletRequest</span> request<span>,</span> <span>HttpServletResponse</span> response<span>,</span> <span>Object</span> handler<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"进入拦截器了"</span><span>)</span><span>;</span>

        <span>// 反射获取方法上的LoginRequred注解</span>
        <span>HandlerMethod</span> handlerMethod <span>=</span> <span>(</span><span>HandlerMethod</span><span>)</span>handler<span>;</span>
        <span>LoginRequired</span> loginRequired <span>=</span> handlerMethod<span>.</span><span>getMethod</span><span>(</span><span>)</span><span>.</span><span>getAnnotation</span><span>(</span><span>LoginRequired</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>if</span><span>(</span>loginRequired <span>==</span> <span>null</span><span>)</span><span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>

        <span>// 有LoginRequired注解说明需要登录，提示用户登录</span>
        response<span>.</span><span>setContentType</span><span>(</span><span>"application/json; charset=utf-8"</span><span>)</span><span>;</span>
        response<span>.</span><span>getWriter</span><span>(</span><span>)</span><span>.</span><span>print</span><span>(</span><span>"你访问的资源需要登录"</span><span>)</span><span>;</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>运行成功，访问sourceB时需要登录了，访问sourceA则不用登录。
<img src="https://img-blog.csdnimg.cn/5f621d02dfbc4d36ac3965acd2b4607f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASmF2YVB1Yi1yb2RlcnQ=,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy">
<img src="https://img-blog.csdnimg.cn/87a44ae94b5a4ec685cec7918d419d6b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASmF2YVB1Yi1yb2RlcnQ=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>场景二：自定义注解+AOP 实现日志打印</strong></p>
<p>先导入切面需要的依赖包</p>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
      <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
     <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-aop<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>定义一个注解@MyLog</p>
<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>METHOD<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>public</span> <span>@interface</span> <span>MyLog</span> <span>{</span>
    
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>定义一个切面类，见如下代码注释理解：</p>
<div><pre><code><span>@Aspect</span> <span>// 1.表明这是一个切面类</span>
<span>@Component</span>
<span>public</span> <span>class</span> <span>MyLogAspect</span> <span>{</span>

    <span>// 2. PointCut表示这是一个切点，@annotation表示这个切点切到一个注解上，后面带该注解的全类名</span>
    <span>// 切面最主要的就是切点，所有的故事都围绕切点发生</span>
    <span>// logPointCut()代表切点名称</span>
    <span>@Pointcut</span><span>(</span><span>"@annotation(com.javapub.blog.MyLog)"</span><span>)</span>
    <span>public</span> <span>void</span> <span>logPointCut</span><span>(</span><span>)</span><span>{</span><span>}</span><span>;</span>

    <span>// 3. 环绕通知</span>
    <span>@Around</span><span>(</span><span>"logPointCut()"</span><span>)</span>
    <span>public</span> <span>void</span> <span>logAround</span><span>(</span><span>ProceedingJoinPoint</span> joinPoint<span>)</span><span>{</span>
        <span>// 获取方法名称</span>
        <span>String</span> methodName <span>=</span> joinPoint<span>.</span><span>getSignature</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>
        <span>// 获取入参</span>
        <span>Object</span><span>[</span><span>]</span> param <span>=</span> joinPoint<span>.</span><span>getArgs</span><span>(</span><span>)</span><span>;</span>

        <span>StringBuilder</span> sb <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
        <span>for</span><span>(</span><span>Object</span> o <span>:</span> param<span>)</span><span>{</span>
            sb<span>.</span><span>append</span><span>(</span>o <span>+</span> <span>"; "</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"进入["</span> <span>+</span> methodName <span>+</span> <span>"]方法,参数为:"</span> <span>+</span> sb<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// 继续执行方法</span>
        <span>try</span> <span>{</span>
            joinPoint<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> throwable<span>)</span> <span>{</span>
            throwable<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>methodName <span>+</span> <span>"方法执行结束"</span><span>)</span><span>;</span>

    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在步骤二中的IndexController写一个sourceC进行测试，加上我们的自定义注解：</p>
<div><pre><code>    <span>@MyLog</span>
    <span>@GetMapping</span><span>(</span><span>"/sourceC/{source_name}"</span><span>)</span>
    <span>public</span> <span>String</span> <span>sourceC</span><span>(</span><span>@PathVariable</span><span>(</span><span>"source_name"</span><span>)</span> <span>String</span> sourceName<span>)</span><span>{</span>
        <span>return</span> <span>"你正在访问sourceC资源"</span><span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>启动springboot web项目，输入访问地址</p>
<p><img src="https://img-blog.csdnimg.cn/699f926567e74423902434d50cabf81f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASmF2YVB1Yi1yb2RlcnQ=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy">
<img src="https://img-blog.csdnimg.cn/04e37829274044c0b297fa9b97bb5915.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>有些面试官喜欢问，注解三要素是哪些：</p>
<ol>
<li>注解声明、</li>
<li>使用注解的元素、</li>
<li>操作注解使其起作用(注解处理器)</li>
</ol>
<hr>
<h2 id="_10-java创建对象有几种方式" tabindex="-1"> 10. Java创建对象有几种方式</h2>
<p>Java中有5种创建对象的方式，下面给出它们的例子</p>
<p><img src="https://img-blog.csdnimg.cn/44e70dbb3062498fbbfbaa9045c0f8d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASmF2YVB1Yi1yb2RlcnQ=,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy">
<strong>使用new关键字</strong></p>
<div><pre><code><span>User</span> user <span>=</span> <span>new</span> <span>User</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>使用Class类的newInstance方法</strong></p>
<p>我们也可以使用Class类的newInstance方法创建对象。这个newInstance方法调用无参的构造函数创建对象。</p>
<div><pre><code><span>Employee</span> emp <span>=</span> <span>(</span><span>Employee</span><span>)</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"org.javapub.blog.Employee"</span><span>)</span><span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
或者
<span>Employee</span> emp2 <span>=</span> <span>Employee</span><span>.</span><span>class</span><span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><strong>使用Constructor类的newInstance方法</strong></p>
<p>和Class类的newInstance方法很像， java.lang.reflect.Constructor类里也有一个newInstance方法可以创建对象。我们可以通过这个newInstance方法调用有参数的和私有的构造函数。</p>
<div><pre><code><span>Constructor</span><span><span>&lt;</span><span>Employee</span><span>></span></span> constructor <span>=</span> <span>Employee</span><span>.</span><span>class</span><span>.</span><span>getConstructor</span><span>(</span><span>)</span><span>;</span>
<span>Employee</span> emp3 <span>=</span> constructor<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><strong>使用clone方法</strong></p>
<p>无论何时我们调用一个对象的clone方法，jvm就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数。</p>
<p>要使用clone方法，我们需要先实现Cloneable接口并实现其定义的clone方法。</p>
<div><pre><code><span>Employee</span> emp4 <span>=</span> <span>(</span><span>Employee</span><span>)</span> emp3<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>使用反序列化</strong></p>
<p>当我们序列化和反序列化一个对象，jvm会给我们创建一个单独的对象。在反序列化时，jvm创建对象并不会调用任何构造函数。</p>
<p>为了反序列化一个对象，我们需要让我们的类实现Serializable接口</p>
<div><pre><code><span>ObjectInputStream</span> in <span>=</span> <span>new</span> <span>ObjectInputStream</span><span>(</span><span>new</span> <span>FileInputStream</span><span>(</span><span>"data.obj"</span><span>)</span><span>)</span><span>;</span>
<span>Employee</span> emp5 <span>=</span> <span>(</span><span>Employee</span><span>)</span> in<span>.</span><span>readObject</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><strong>联系DearLocation:</strong></p>
<ol>
<li>如果需要下载CSDN资料又没有积分可以DearLocation留言，DearLocation帮你下载</li>
</ol>
<blockquote>
<p>查看更多面试题及答案
<img src="https://tvax3.sinaimg.cn/large/007F3CC8ly1h11lc8tbdbj3076076gm7.jpg" alt="image" loading="lazy"></p>
</blockquote>
<h2 id="推荐阅读" tabindex="-1"> 推荐阅读：</h2>
<p><a href="/willbe/java-basics-interview-must.html">【Java基础】10道不得不会的Java基础面试题</a></p>
<p><a href="java-concurrent-interview-must">【Java并发】10道不得不会的Java并发基础面试题</a></p>
<p><a href="/willbe/mysql-interview-must.html">【MySQL】10道不得不会的MySQL基础面试题</a></p>
<p><a href="/willbe/elasticsearch-interview-must.html">【ElasticSearch】10道不得不会的ElasticSearch面试题</a></p>
<p><a href="/willbe/jvm-interview-must.html">【JVM】10道不得不会的JVM面试题</a></p>
<p><a href="/willbe/willbe/spring-interview-must.html">【Spring】10道不得不会的Spring面试题</a></p>
<p><a href="https://github.com/yangchunjian" target="_blank" rel="noopener noreferrer">GItHub</a>|<a href="https://gitee.com/yangchunjian" target="_blank" rel="noopener noreferrer">GitEE</a></p>
<p>公众号二维码</p>
<p><img src="/accounts/wechat.jpg" alt="" loading="lazy"></p>
<p>个人微信</p>
<p><img src="/accounts/QRcode.jpg" alt="" loading="lazy"></p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/fa68ecc8af4e4b679e48c2703cf897c7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASmF2YVB1Yi1yb2RlcnQ=,size_8,color_FFFFFF,t_70,g_se,x_16" type="image/"/>
    </item>
    <item>
      <title>10道不得不会的Java并发基础面试题</title>
      <link>https://dearlocation.com/willbe/java-concurrent-interview-must.html</link>
      <guid>https://dearlocation.com/willbe/java-concurrent-interview-must.html</guid>
      <source url="https://dearlocation.com/rss.xml">10道不得不会的Java并发基础面试题</source>
      <description>Java并发
</description>
      <category>最少必要面试题</category>
      <pubDate>Thu, 21 Apr 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Java并发</p>

<p>10道不得不会的Java并发基础面试题</p>
<p>以下都是Java的并发基础面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。<strong>DearLocation</strong>在这里整理这些容易忘记的重点知识及<strong>解答</strong>，<code>建议收藏，经常温习查阅</code>。</p>
<p>评论区见</p>
<p>@[toc]</p>
<hr>
<h2 id="_1-start-方法和run-方法的区别" tabindex="-1"> 1. start()方法和run()方法的区别</h2>
<p>如果只是调用 run() 方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</p>
<p>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。</p>
<p>参考图：</p>
<p><img src="https://img-blog.csdnimg.cn/c9b8939fe6274e508853acba1f1ee213.png" alt="在这里插入图片描述" loading="lazy"></p>
<hr>
<h2 id="_2-volatile关键字的作用" tabindex="-1"> 2. volatile关键字的作用</h2>
<p>volatile <code>英 [ˈvɒlətaɪl]</code> ，第一个想到的一定是<strong>保证内存可见性</strong>（Memory Visibility）。可见性是性对于线程而言。</p>
<p><img src="https://img-blog.csdnimg.cn/dbb024baa3144f8b9abc1b241a6474a6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASmF2YVB1Yi1yb2RlcnQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy">
上图是Java内存模型，所有线程的共享变量都放在主内存中，每一个线程都有一个独有的工作内存，每个线程不直接操作在主内存中的变量，而是将主内存上变量的副本放进自己的工作内存中，只操作工作内存中的数据。当修改完毕后，再把修改后的结果放回到主内存中。每个线程都只操作自己工作内存中的变量，无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</p>
<p>很明显，在并发环境下一定会发生脏数据问题。</p>
<p>使用volatile变量能够保证:</p>
<ol>
<li>每次读取前必须先从主内存刷新最新的值。</li>
<li>每次写入后必须立即同步回主内存当中。</li>
</ol>
<blockquote>
<p>也就是说，volatile关键字修饰的变量看到的随时是自己的最新值。</p>
</blockquote>
<p><strong>防止指令重排</strong></p>
<p>在基于偏序关系的Happens-Before内存模型中，指令重排技术大大提高了程序执行效率。但是也引入一个新问题：被部分初始化的对象</p>
<p>例子：</p>
<div><pre><code>创建一个对象
instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>它并不是一个原子操作。事实上，它可以”抽象“为下面几条JVM指令：</p>
<div><pre><code>memory <span>=</span> <span>allocate</span><span>(</span><span>)</span><span>;</span>    <span>//1：分配对象的内存空间</span>
<span>initInstance</span><span>(</span>memory<span>)</span><span>;</span>   <span>//2：初始化对象</span>
instance <span>=</span> memory<span>;</span>      <span>//3：设置instance指向刚分配的内存地址</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面操作2依赖于操作1，但是操作3并不依赖于操作2，所以JVM可以以“优化”为目的对它们进行重排序，经过重排序后如下：</p>
<div><pre><code>memory <span>=</span> <span>allocate</span><span>(</span><span>)</span><span>;</span>    <span>//1：分配对象的内存空间</span>
instance <span>=</span> memory<span>;</span>      <span>//3：设置instance指向刚分配的内存地址（此时对象还未初始化）</span>
<span>initInstance</span><span>(</span>memory<span>)</span><span>;</span>   <span>//2：初始化对象</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>可以看到指令重排之后，操作 3 排在了操作 2 之前，即引用instance指向内存memory时，这段崭新的内存还没有初始化。由于instance已经指向了一块内存空间，从而返回 instance!=null，用户得到了没有完成初始化的“半个”单例。</p>
<p>但是有一点：volatile不保证原子性。</p>
<blockquote>
<p>这里有一篇生产环境使用volatile的例子：<a href="https://mp.weixin.qq.com/s/s1cwut9WvUSrMYw_6UK3sg" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/s1cwut9WvUSrMYw_6UK3sg</a></p>
</blockquote>
<hr>
<h2 id="_3-sleep方法和wait方法有什么区别" tabindex="-1"> 3. sleep方法和wait方法有什么区别</h2>
<p>要了解sleep和wait，首先需要了解Java线程的6种状态。</p>
<div><pre><code>#下面是<span>Java</span>线程的<span>6</span>种状态
<span>1.</span> 初始<span>(</span>NEW<span>)</span>：新创建了一个线程对象，但还没有调用<span>start</span><span>(</span><span>)</span>方法。
<span>2.</span> 运行<span>(</span>RUNNABLE<span>)</span>：<span>Java</span>线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
线程对象创建后，其他线程<span>(</span>比如main线程）调用了该对象的<span>start</span><span>(</span><span>)</span>方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
<span>3.</span> 阻塞<span>(</span>BLOCKED<span>)</span>：表示线程阻塞于锁。
<span>4.</span> 等待<span>(</span>WAITING<span>)</span>：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
<span>5.</span> 超时等待<span>(</span>TIMED_WAITING<span>)</span>：该状态不同于WAITING，它可以在指定的时间后自行返回。
<span>6.</span> 终止<span>(</span>TERMINATED<span>)</span>：表示该线程已经执行完毕。
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>sleep</strong> 休眠方法</p>
<div><pre><code><span>static</span> <span>void</span> <span>sleep</span><span>(</span><span>long</span> ms<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>该方法会使当前线程进入阻塞状态指定毫秒，当阻塞指定毫秒后，当前线程会重新进入Runnable状态，等待划分时间片。</p>
<p>sleep方法属于Thread类中方法，表示让一个线程进入睡眠状态，等待一定的时间之后，自动醒来进入到可运行状态，不会马上进入运行状态，因为线程调度机制恢复线程的运行也需要时间，一个线程对象调用了sleep方法之后，并不会释放他所持有的所有对象锁，所以也就不会影响其他进程对象的运行。</p>
<p><strong>wait</strong> 方法一般是跟notify方法连用的</p>
<p>多线程之间需要协调工作。如果条件不满足则等待。当条件满足时，等待该条件的线程将被唤醒。在Java中，这个机制实现依赖于wait/notify或wait/notifyAll。</p>
<p>object.wait()让当前线程进入不可运行状态，如sleep()一样，但不同的是wait方法从一个对象调用，而不是从一个线程调用；我们称这个对象为“锁定对象（lockObj）”。在lockObj.wait()被调用之前，当前线程必须在lockObj上同步（synchronize）；然后调用wait()后释放这个锁，并将线程增加到与lockObj相关的“等待名单（wait list）”。然后，另一个在同一个lockObj锁定（synchronize）的方法可以调用lockObj.nofity()。这会唤醒原来等待的线程。基本上，wait() / notify()就像sleep() / interrupt()，只是活动线程不需要直接指向一个睡眠线程，他们只需要共享锁对象（lockObj）。</p>
<p>到这里你是否明白这个问题，如果不明白来DearLocation，后续一篇代码分析，马上安排。</p>
<hr>
<h2 id="_4-如何停止一个正在运行的线程" tabindex="-1"> 4. 如何停止一个正在运行的线程？</h2>
<p>最直观的一定是 Thread.stop，但是它是不推荐的，并且已经废弃。看一下官方说明
<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html</a></p>
<div><pre><code><span>*</span>   	<span>This</span> method is inherently <span><span>unsafe<span>.</span></span>   Stopping</span> a thread <span>with</span> 
<span>*</span>       <span>Thread</span><span>.</span> stop causes it <span>to</span> <span>unlock</span> all of the monitors that it 
<span>*</span>       has locked <span>(</span>as a natural consequence of the unchecked 
<span>*</span>       <span><span>&lt;</span>code<span>></span></span><span>ThreadDeath</span><span>&lt;</span><span>/</span>code<span>></span> exception propagating up the stack<span>)</span><span>.</span>   <span>If</span> 
<span>*</span>       any of the objects previously <span>protected</span> by these monitors were in 
<span>*</span>       an inconsistent state<span>,</span> the damaged objects become visible <span>to</span> 
<span>*</span>       other threads<span>,</span> potentially resulting in arbitrary <span><span>behavior<span>.</span></span>   Many</span> 
<span>*</span>       <span>uses</span> <span>of</span> <span><span>&lt;</span>code<span>></span></span>stop<span>&lt;</span><span>/</span>code<span>></span> should be replaced by code that simply 
<span>*</span>       modifies some variable <span>to</span> <span>indicate</span> that the target thread should 
<span>*</span>       stop <span><span>running<span>.</span></span>   The</span> target thread should check <span>this</span> variable 
<span>*</span>       regularly<span>,</span> and <span>return</span> from its run method in an orderly fashion 
<span>*</span>       <span>if</span> the variable indicates that it is <span>to</span> <span>stop</span> <span><span>running<span>.</span></span>   If</span> the 
<span>*</span>       target thread waits <span>for</span> <span>long</span> periods <span>(</span>on a condition variable<span>,</span> 
<span>*</span>       <span>for</span> example<span>)</span><span>,</span> the <span><span>&lt;</span>code<span>></span></span>interrupt<span>&lt;</span><span>/</span>code<span>></span> method should be used <span>to</span> 
<span>*</span>       interrupt the wait<span>.</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>小结：
简单来说，Thread.stop()不安全，已不再建议使用。</p>
<p><strong>方法一：</strong></p>
<p>使用 interrupt 方法中断线程。</p>
<p>interrupt()方法的使用效果并不像for+break语句那样，马上就停止循环。调用interrupt方法是在当前线程中打了一个停止标志，并不是真的停止线程。</p>
<p>需要 this.isInterrupted(): 测试线程是否真的已经中断。</p>
<p><strong>方法二：</strong></p>
<p>最好的一种方法，使用标志位停止。</p>
<p>run() 方法中做标识符，保证优雅的停止服务。</p>
<hr>
<h2 id="_5-java如何实现多线程之间的通讯和协作-如何在两个线程间共享数据" tabindex="-1"> 5. java如何实现多线程之间的通讯和协作？(如何在两个线程间共享数据？)</h2>
<p><strong>volatile关键字方式</strong></p>
<p>volatile有两大特性，一是可见性，二是有序性，禁止指令重排序，其中可见性就是可以让线程之间进行通信。</p>
<p><strong>等待/通知机制</strong></p>
<p>等待通知机制是基于wait和notify方法来实现的，在一个线程内调用该线程锁对象的wait方法，线程将进入等待队列进行等待直到被通知或者被唤醒。</p>
<p>也就是通过<strong>等待/通知机制</strong> 让多个线程协作</p>
<p><strong>join方式</strong></p>
<p>join其实合理理解成是线程合并，当在一个线程调用另一个线程的join方法时，当前线程阻塞等待被调用join方法的线程执行完毕才能继续执行，所以join的好处能够保证线程的执行顺序，但是如果调用线程的join方法其实已经失去了并行的意义，虽然存在多个线程，但是本质上还是串行的，最后join的实现其实是基于等待通知机制的。</p>
<p><strong>threadLocal方式</strong></p>
<p>threadLocal方式的线程通信，不像以上三种方式是多个线程之间的通信，它更像是一个线程内部的通信，将当前线程和一个map绑定，在当前线程内可以任意存取数据，减省了方法调用间参数的传递。</p>
<hr>
<h2 id="_6-什么是threadlocal" tabindex="-1"> 6. 什么是ThreadLocal?</h2>
<p>定义：线程局部变量是局限于线程内的变量，属于线程自身所有，不在多个线程间共享。java提供 ThreadLocal类 来支持线程局部变量，是一个实现线程安全的方式。</p>
<p>作用：ThreadLocal 是一种以空间换时间的做法，在每一个 Thread 里面维护了一个 ThreadLocal.ThreadLocalMap 把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。</p>
<hr>
<h2 id="_7-java-中-countdownlatch-和-cyclicbarrier-有什么不同" tabindex="-1"> 7. Java 中 CountDownLatch 和 CyclicBarrier 有什么不同？</h2>
<p><strong>概念：</strong></p>
<p><strong>CountDownLatch</strong> 是一个同步的辅助类，允许一个或多个线程，等待其他一组线程完成操作，再继续执行。简单来说：CountDownLatch 是一个计数器，可以保证线程之间的顺序执行把线程从并发状态调整为串行状态保证了线程的执行顺序。(只可以使用一次)</p>
<p><strong>CyclicBarrier</strong> 是一个同步的辅助类，允许一组线程相互之间等待，达到一个共同点，再继续执行。典型场景：可以用于多线程计算数据，最后合并计算结果。（可以多次使用）</p>
<p>分享一个直观的代码：</p>
<div><pre><code><span>package</span> <span>com<span>.</span>javapub<span>.</span>test</span><span>;</span>

<span>import</span> <span><span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>CountDownLatch</span></span><span>;</span>

<span>/**
 * @Author: DearLocation
 * @License: https://github.com/yangchunjian/
 * @Contact: https://javapub.blog.csdn.net/
 * @Date: 2022/1/1 16:50
 * @Version: 1.0
 * @Description: countDownLatch 可以保证线程之间的顺序执行把线程从并发状态调整为串行状态保证了线程的执行顺序。
 * demo效果：当打印完B，再打印C。
 */</span>

<span>class</span> <span>ThreadA</span> <span>extends</span> <span>Thread</span> <span>{</span>

    <span>private</span> <span>CountDownLatch</span> down<span>;</span>

    <span>public</span> <span>ThreadA</span><span>(</span><span>CountDownLatch</span> down<span>)</span> <span>{</span>
        <span>this</span><span>.</span>down <span>=</span> down<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"A"</span><span>)</span><span>;</span>
        <span>try</span> <span>{</span>
            down<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span><span>//相当于wait(),调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"C"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>ThreadB</span> <span>extends</span> <span>Thread</span> <span>{</span>
    <span>private</span> <span>CountDownLatch</span> down<span>;</span>

    <span>public</span> <span>ThreadB</span><span>(</span><span>CountDownLatch</span> down<span>)</span> <span>{</span>
        <span>this</span><span>.</span>down <span>=</span> down<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"B"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>down<span>.</span><span>getCount</span><span>(</span><span>)</span><span>)</span><span>;</span>
        down<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span><span>//将count值减1</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Test</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>CountDownLatch</span> down <span>=</span> <span>new</span> <span>CountDownLatch</span><span>(</span><span>1</span><span>)</span><span>;</span><span>//创建1个计数器</span>
        <span>new</span> <span>ThreadA</span><span>(</span>down<span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>new</span> <span>ThreadB</span><span>(</span>down<span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>/*输出
A
B
C
 */</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>package</span> <span>com<span>.</span>roundyuan<span>.</span>fanggateway<span>.</span>test</span><span>;</span>

<span>import</span> <span><span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>CyclicBarrier</span></span><span>;</span>

<span>/**
 * @Author: DearLocation
 * @License: https://github.com/yangchunjian/
 * @Contact: https://javapub.blog.csdn.net/
 * @Date: 2022/1/2 13:42
 * @Version: 1.0
 * @Description: CyclicBarrier
 */</span>

<span>public</span> <span>class</span> <span>CyclicBarrierDemo</span> <span>{</span>

    <span>static</span> <span>class</span> <span>TaskThread</span> <span>extends</span> <span>Thread</span> <span>{</span>

        <span>CyclicBarrier</span> barrier<span>;</span>

        <span>public</span> <span>TaskThread</span><span>(</span><span>CyclicBarrier</span> barrier<span>)</span> <span>{</span>
            <span>this</span><span>.</span>barrier <span>=</span> barrier<span>;</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>try</span> <span>{</span>
                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" 到达栅栏 A"</span><span>)</span><span>;</span>
                barrier<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" 冲破栅栏 A"</span><span>)</span><span>;</span>

                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>2000</span><span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" 到达栅栏 B"</span><span>)</span><span>;</span>
                barrier<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" 冲破栅栏 B"</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span> threadNum <span>=</span> <span>5</span><span>;</span>
        <span>CyclicBarrier</span> barrier <span>=</span> <span>new</span> <span>CyclicBarrier</span><span>(</span>threadNum<span>,</span> <span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>

            <span>@Override</span>
            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" 完成最后任务"</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> threadNum<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>new</span> <span>TaskThread</span><span>(</span>barrier<span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>/*
Thread-3 到达栅栏 A
Thread-1 到达栅栏 A
Thread-4 到达栅栏 A
Thread-2 到达栅栏 A
Thread-0 到达栅栏 A
Thread-2 完成最后任务
Thread-2 冲破栅栏 A
Thread-0 冲破栅栏 A
Thread-4 冲破栅栏 A
Thread-3 冲破栅栏 A
Thread-1 冲破栅栏 A
Thread-4 到达栅栏 B
Thread-0 到达栅栏 B
Thread-2 到达栅栏 B
Thread-1 到达栅栏 B
Thread-3 到达栅栏 B
Thread-3 完成最后任务
Thread-3 冲破栅栏 B
Thread-0 冲破栅栏 B
Thread-4 冲破栅栏 B
Thread-1 冲破栅栏 B
Thread-2 冲破栅栏 B
 */</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>网上看到一个比较形象一个例子：</p>
<div><pre><code>CountDownLatch：
宿管阿姨，晚上关宿舍大门睡觉，需要等到所有学生回寝，才能关门睡觉，学生之间不用相互等待，回寝就能睡觉。	（学生就是各个线程，宿管阿姨就是监听CountDownLatch为0后要执行的。）

CyclicBarrier：
家庭聚餐，等待家庭成员到齐才能开饭，家庭成员之间需要相互等待，直到最后一个到达，才能同时开饭。
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><hr>
<h2 id="_8-如何避免死锁" tabindex="-1"> 8. 如何避免死锁？</h2>
<p><img src="https://img-blog.csdnimg.cn/20190729214659783.png" alt="" loading="lazy">
从上图我们就可以看出，产生死锁就是俩个或多个线程在申请资源时，自己需要的资源别别人持有、并阻塞。所以导致死锁。</p>
<p><strong>如何解决：</strong></p>
<ol>
<li>减小锁的范围，尽量保证之锁定自己需要的资源，减小交叉持有资源情况</li>
<li>但是有些时候不得不持有多个资源，比如<strong>银行转账</strong>，我们必须同时获得两个账户上的锁，才能进行操作，两个锁的申请必须发生交叉。这时我们也可以打破死锁的那个闭环，在涉及到要同时申请两个锁的方法中，总是以相同的顺序来申请锁，比如总是先申请 id 大的账户上的锁 ，然后再申请 id 小的账户上的锁，这样就无法形成导致死锁的那个闭环。</li>
<li>我们知道导致死锁有一个因素是阻塞，所以如果我们不使用默认阻塞的锁，也是可以避免死锁的。我们可以使用 ReentrantLock.tryLock() 方法，在一个循环中，如果 tryLock() 返回失败，那么就释放以及获得的锁，并睡眠一小段时间。这样就打破了死锁的闭环。</li>
</ol>
<div><pre><code><span>package</span> <span>com<span>.</span>roundyuan<span>.</span>fanggateway<span>.</span>test</span><span>;</span>

<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Random</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>TimeUnit</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span>concurrent<span>.</span>locks<span>.</span></span><span>Lock</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span>concurrent<span>.</span>locks<span>.</span></span><span>ReentrantLock</span></span><span>;</span>

<span>/**
 * @Author: DearLocation
 * @License: https://github.com/yangchunjian/
 * @Contact: https://javapub.blog.csdn.net/
 * @Date: 2022/1/2 14:38
 * @Version: 1.0
 * @Description: ReentrantLock
 */</span>

<span>public</span> <span>class</span> <span>DeadLock</span> <span>{</span>

    <span>private</span> <span>static</span> <span>Lock</span> lock1 <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>)</span><span>;</span>
    <span>private</span> <span>static</span> <span>Lock</span> lock2 <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>void</span> <span>deathLock</span><span>(</span><span>)</span> <span>{</span>
        <span>new</span> <span>Thread</span><span>(</span><span>)</span> <span>{</span>
            <span>@Override</span>
            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
                <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
                    <span>if</span> <span>(</span>lock1<span>.</span><span>tryLock</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                        <span>try</span> <span>{</span>
                            <span>//如果获取成功则执行业务逻辑，如果获取失败，则释放lock1的锁，自旋重新尝试获得锁</span>
                            <span>if</span> <span>(</span>lock2<span>.</span><span>tryLock</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                                <span>try</span> <span>{</span>
                                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Thread1：已成功获取 lock1 and lock2 ..."</span><span>)</span><span>;</span>
                                    <span>break</span><span>;</span>
                                <span>}</span> <span>finally</span> <span>{</span>
                                    lock2<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
                                <span>}</span>
                            <span>}</span>
                        <span>}</span> <span>finally</span> <span>{</span>
                            lock1<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
                        <span>}</span>
                    <span>}</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Thread1：获取锁失败，重新获取---"</span><span>)</span><span>;</span>
                    <span>try</span> <span>{</span>
                        <span>//防止发生活锁</span>
                        <span>TimeUnit</span><span>.</span>NANOSECONDS<span>.</span><span>sleep</span><span>(</span><span>new</span> <span>Random</span><span>(</span><span>)</span><span>.</span><span>nextInt</span><span>(</span><span>100</span><span>)</span><span>)</span><span>;</span>
                    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>

        <span>new</span> <span>Thread</span><span>(</span><span>)</span> <span>{</span>
            <span>@Override</span>
            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
                <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
                    <span>if</span> <span>(</span>lock2<span>.</span><span>tryLock</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                        <span>try</span> <span>{</span>
                            <span>//如果获取成功则执行业务逻辑，如果获取失败，则释放lock2的锁，自旋重新尝试获得锁</span>
                            <span>if</span> <span>(</span>lock1<span>.</span><span>tryLock</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                                <span>try</span> <span>{</span>
                                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Thread2：已成功获取 lock2 and lock1 ..."</span><span>)</span><span>;</span>
                                    <span>break</span><span>;</span>
                                <span>}</span> <span>finally</span> <span>{</span>
                                    lock1<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
                                <span>}</span>
                            <span>}</span>
                        <span>}</span> <span>finally</span> <span>{</span>
                            lock2<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
                        <span>}</span>
                    <span>}</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Thread2：获取锁失败，重新获取---"</span><span>)</span><span>;</span>
                    <span>try</span> <span>{</span>
                        <span>//防止发生活锁</span>
                        <span>TimeUnit</span><span>.</span>NANOSECONDS<span>.</span><span>sleep</span><span>(</span><span>new</span> <span>Random</span><span>(</span><span>)</span><span>.</span><span>nextInt</span><span>(</span><span>100</span><span>)</span><span>)</span><span>;</span>
                    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>deathLock</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>说起死锁，银行家算法非常有必要了解：</p>
<div><pre><code>银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。
1、操作系统按照银行家指定的规则为进程分配资源，当进程首次申请资源时，需要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请资源分配资源，否则就推迟分配；
2、当进程在执行中继续申请资源时，先测试该进程本次申请的资源数，是否超过了该资源剩余的总量，若超过则拒绝分配资源，若能满足则按当前的申请量分配资源，否则也要推迟分配。
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>参考阅读：</p>
<p>如何快速排查死锁？如何避免死锁？
<a href="https://zhuanlan.zhihu.com/p/136294283" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/136294283</a></p>
<hr>
<h2 id="_9-java-中-synchronized-和-reentrantlock-有什么不同" tabindex="-1"> 9. Java 中 synchronized 和 ReentrantLock 有什么不同？</h2>
<p><strong>等待可中断:</strong></p>
<p>使用synchronized，不能被中断。synchronized 也可以说是Java提供的原子性内置锁机制。内部锁扮演了互斥锁（mutual exclusion lock ，mutex）的角色，一个线程引用锁的时候，别的线程阻塞等待。</p>
<p>使用ReentrantLock。等待了很长时间以后，可以中断等待，转而去做别的事情。</p>
<p><strong>公平锁:</strong></p>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请的时间顺序来依次获得锁；而非公平锁则不能保证这一点。非公平锁在锁被释放时，任何一个等待锁的线程都有机会获得锁。 synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁。</p>
<p>还有大家已知的俩点：</p>
<ol>
<li>
<p>synchronized是独占锁，加锁和解锁的过程自动进行，易于操作，但不够灵活。ReentrantLock也是独占锁，加锁和解锁的过程需要手动进行，不易操作，但非常灵活。</p>
</li>
<li>
<p>synchronized可重入，因为加锁和解锁自动进行，不必担心最后是否释放锁；ReentrantLock也可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。</p>
</li>
</ol>
<hr>
<h2 id="_10-有三个线程-t1-t2-t3-怎么确保它们按顺序执行" tabindex="-1"> 10. 有三个线程 T1，T2，T3，怎么确保它们按顺序执行？</h2>
<p><strong>方法1：</strong></p>
<p>线程内部顺序调用，T1、T2、T3。这个可能不是要考察的点，但也是一个方案。</p>
<p><strong>方法2：</strong></p>
<p>join()方法用于将线程由 ”并行“变成”串行“，它用于等待其他线程的终止，在当前线程掉用了join()方法，那么当前线程将进入阻塞状态，等到另一个线程结束，当前线程再由阻塞状态转变成就绪状态，等待CPU的使用权。</p>
<div><pre><code><span>package</span> <span>com<span>.</span>javapub<span>.</span>test</span><span>;</span>

<span>/**
 * @Author: DearLocation
 * @License: https://github.com/yangchunjian/
 * @Contact: https://javapub.blog.csdn.net/
 * @Date: 2022/1/2 15:20
 * @Version: 1.0
 * @Description:
 */</span>


<span>public</span> <span>class</span> <span>Test1</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>ThreadA</span> threadA <span>=</span> <span>new</span> <span>ThreadA</span><span>(</span><span>)</span><span>;</span>
        <span>ThreadB</span> threadB <span>=</span> <span>new</span> <span>ThreadB</span><span>(</span>threadA<span>)</span><span>;</span>
        <span>ThreadC</span> threadC <span>=</span> <span>new</span> <span>ThreadC</span><span>(</span>threadB<span>)</span><span>;</span>

        threadA<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        threadB<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        threadC<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>

    <span>}</span>

<span>}</span>

<span>class</span> <span>ThreadA</span> <span>extends</span> <span>Thread</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"线程A"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>ThreadB</span> <span>extends</span> <span>Thread</span> <span>{</span>
    <span>Thread</span> threadA<span>;</span>

    <span>public</span> <span>ThreadB</span><span>(</span><span>)</span> <span>{</span>
        <span>// TODO Auto-generated constructor stub</span>
    <span>}</span>

    <span>public</span> <span>ThreadB</span><span>(</span><span>Thread</span> threadA<span>)</span> <span>{</span>
        <span>this</span><span>.</span>threadA <span>=</span> threadA<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            threadA<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
            <span>// TODO Auto-generated catch block</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"线程B"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>ThreadC</span> <span>extends</span> <span>Thread</span> <span>{</span>
    <span>Thread</span> threadB<span>;</span>

    <span>public</span> <span>ThreadC</span><span>(</span><span>Thread</span> threadB<span>)</span> <span>{</span>
        <span>this</span><span>.</span>threadB <span>=</span> threadB<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            threadB<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
            <span>// TODO Auto-generated catch block</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"线程C"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>信号量方式 java.util.concurrent.Semaphore <code>英 [ˈseməfɔː(r)]</code>
待研究</p>
<hr>
<p><strong>联系DearLocation:</strong></p>
<ol>
<li>如果需要下载CSDN资料又没有积分可以DearLocation留言，DearLocation帮你下载</li>
</ol>
<h2 id="推荐阅读" tabindex="-1"> 推荐阅读：</h2>
<p><a href="/willbe/java-basics-interview-must.html">【Java基础】10道不得不会的Java基础面试题</a></p>
<p><a href="java-concurrent-interview-must">【Java并发】10道不得不会的Java并发基础面试题</a></p>
<p><a href="/willbe/mysql-interview-must.html">【MySQL】10道不得不会的MySQL基础面试题</a></p>
<p><a href="/willbe/elasticsearch-interview-must.html">【ElasticSearch】10道不得不会的ElasticSearch面试题</a></p>
<p><a href="/willbe/jvm-interview-must.html">【JVM】10道不得不会的JVM面试题</a></p>
<p><a href="https://github.com/yangchunjian" target="_blank" rel="noopener noreferrer">GItHub</a>|<a href="https://gitee.com/yangchunjian" target="_blank" rel="noopener noreferrer">GitEE</a></p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/c9b8939fe6274e508853acba1f1ee213.png" type="image/png"/>
    </item>
    <item>
      <title>10道不得不会的JVM面试题</title>
      <link>https://dearlocation.com/willbe/jvm-interview-must.html</link>
      <guid>https://dearlocation.com/willbe/jvm-interview-must.html</guid>
      <source url="https://dearlocation.com/rss.xml">10道不得不会的JVM面试题</source>
      <description>JVM
</description>
      <category>最少必要面试题</category>
      <pubDate>Thu, 21 Apr 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>JVM</p>

<p>10道不得不会的JVM面试题</p>
<p>我是DearLocation，专注于面试、副业，技术人的成长记录。</p>
<p>以下是 JVM 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。<strong>DearLocation</strong>在这里整理这些容易忘记的重点知识及<strong>解答</strong>，<code>建议收藏，经常温习查阅</code>。</p>
<p>评论区见</p>
<p>@[toc]</p>
<h1 id="jvm" tabindex="-1"> JVM</h1>
<p>基于JDK8</p>
<h2 id="_1-说一说jvm的主要组成部分" tabindex="-1"> 1. 说一说JVM的主要组成部分</h2>
<p>点击放大看，一图胜千文</p>
<p><img src="https://tvax1.sinaimg.cn/large/007F3CC8ly1h11l1b6ykaj30x50kl46x.jpg" alt="image" loading="lazy"></p>
<ul>
<li>
<p>方法区和堆是所有线程共享的内存区域；而虚拟机栈、本地方法栈和程序计数器的运行是线程私有的内存区域，运行时数据区域就是我们常说的JVM的内存。</p>
</li>
<li>
<p>类加载子系统：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到运行时数据区中的方法区中。</p>
</li>
<li>
<p>Java堆是Java虚拟机所管理的内存中最大的一块，也是垃圾回收的主要区域。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
</li>
<li>
<p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</li>
<li>
<p>程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器，用来指示执行引擎下一条执行指令的地址。</p>
</li>
<li>
<p>Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、返回方法地址等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
</li>
<li>
<p>本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p>
</li>
<li>
<p>执行引擎：根据程序计数器中存储的指令地址执行classes中的指令。</p>
</li>
<li>
<p>本地接口：与本地方法库交互，是其它编程语言交互的接口。</p>
</li>
</ul>
<h2 id="_2-说一下-jvm-的作用" tabindex="-1"> 2. 说一下 JVM 的作用？</h2>
<p>首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
<h2 id="_3-说一下堆栈的区别" tabindex="-1"> 3. 说一下堆栈的区别？</h2>
<p><strong>物理地址</strong></p>
<p>堆的物理地址分配对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）</p>
<p>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p>
<p><strong>内存分别</strong></p>
<p>堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。</p>
<p>栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。</p>
<p><strong>存放的内容</strong></p>
<p>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储</p>
<p>栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。</p>
<p><strong>PS：</strong></p>
<p>静态变量放在方法区
静态的对象还是放在堆。
程序的可见度</p>
<p>堆对于整个应用程序都是共享、可见的。</p>
<p>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</p>
<h2 id="_4-java内存泄漏" tabindex="-1"> 4. Java内存泄漏</h2>
<p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。</p>
<p>严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p>
<p>理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</p>
<p>但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</p>
<h2 id="_5-jvm-有哪些垃圾回收算法" tabindex="-1"> 5. JVM 有哪些垃圾回收算法？</h2>
<ul>
<li>标记-清除算法：标记有用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li>
<li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半，消耗内存。</li>
<li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li>
<li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li>
</ul>
<h2 id="_6-说一下-jvm-有哪些垃圾回收器" tabindex="-1"> 6. 说一下 JVM 有哪些垃圾回收器？</h2>
<p><img src="https://tva2.sinaimg.cn/large/007F3CC8ly1h11l1p8888j30te07oacq.jpg" alt="image" loading="lazy"></p>
<p><img src="https://tvax1.sinaimg.cn/large/007F3CC8ly1h11l1ykqpsj30vx08o14v.jpg" alt="image" loading="lazy"></p>
<h2 id="_7-说一下类加载的执行过程" tabindex="-1"> 7. 说一下类加载的执行过程？</h2>
<ul>
<li><strong>加载</strong>：根据查找路径找到相应的 class 文件然后装载入内存中；</li>
</ul>
<p><img src="https://tvax2.sinaimg.cn/large/007F3CC8ly1h11l29871ij30is07h76f.jpg" alt="image" loading="lazy"></p>
<ul>
<li><strong>验证</strong>：检查加载的 class 文件的正确性；</li>
<li><strong>准备</strong>：给类中的静态变量分配内存空间；</li>
<li><strong>解析</strong>：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li>
<li><strong>初始化</strong>：对静态变量和静态代码块执行初始化工作。</li>
</ul>
<hr>
<h2 id="_8-什么是双亲委派模型-为什么要使用双亲委派模型" tabindex="-1"> 8. 什么是双亲委派模型？为什么要使用双亲委派模型？</h2>
<p><strong>什么是双亲委派模型</strong></p>
<ul>
<li>当需要加载一个类的时候，子类加载器并不会马上去加载，而是依次去请求父类加载器加载</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ul>
<p><strong>为什么要使用双亲委派模型</strong></p>
<p>可以防止内存中出现多份同样的字节码，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，多个类加载器都去加载这个类到内存中，系统中将会出现多个不同的Object类，那么类之间的比较结果及类的唯一性将无法保证，而且如果不使用这种双亲委派模型将会给虚拟机的安全带来隐患。所以，要让类对象进行比较有意义，前提是他们要被同一个类加载器加载。</p>
<h2 id="_9-cms垃圾清理的过程" tabindex="-1"> 9. CMS垃圾清理的过程</h2>
<p><img src="https://tva4.sinaimg.cn/large/007F3CC8ly1h11l2qpppoj30se08sgq4.jpg" alt="image" loading="lazy"></p>
<p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记 stop-the-world)</p>
<ul>
<li>
<p><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出 GC Roots 能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p>
</li>
<li>
<p><strong>并发标记</strong>（Concurrent-Mark）阶段：从 Gc Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>
</li>
<li>
<p><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p>
</li>
<li>
<p><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p>
</li>
</ul>
<h2 id="_10-常用的-jvm-调优的参数都有哪些" tabindex="-1"> 10. 常用的 JVM 调优的参数都有哪些？</h2>
<p><img src="https://tvax1.sinaimg.cn/large/007F3CC8ly1h11l35h3jfj30pd097764.jpg" alt="image" loading="lazy"></p>
<ul>
<li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li>
<li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li>
<li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li>
<li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li>
<li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li>
<li>-XX:+PrintGC：开启打印 gc 信息；</li>
<li>-XX:+PrintGCDetails：打印 gc 详细信息。</li>
</ul>
<p><img src="https://tvax4.sinaimg.cn/large/007F3CC8ly1h11l3rzpgsj30mb0883ze.jpg" alt="image" loading="lazy"></p>
<p>JVM 调优-这个问题单独一篇</p>
<hr>
<h2 id="系列文章" tabindex="-1"> 系列文章</h2>
<p><a href="https://mp.weixin.qq.com/s/3Nviyml0cvnX_HHkZ5DjWg" target="_blank" rel="noopener noreferrer">【Java基础】10道不得不会的Java基础面试题</a></p>
<p><a href="https://mp.weixin.qq.com/s/h2tTwDVqL15rCI6rftgn9A" target="_blank" rel="noopener noreferrer">【Java并发】10道不得不会的Java并发基础面试题</a></p>
<p><a href="https://mp.weixin.qq.com/s/yVPwCoSQ-8OYvhw8bH0PtA" target="_blank" rel="noopener noreferrer">【MySQL】10道不得不会的MySQL基础面试题</a></p>
<p><a href="https://mp.weixin.qq.com/s/z3D37HqeTUmwrdheUL_Efw" target="_blank" rel="noopener noreferrer">【ElasticSearch】10道不得不会的ElasticSearch面试题</a></p>
<p><a href="/willbe/jvm-interview-must.html">【JVM】10道不得不会的JVM面试题</a></p>
<p><a href="/willbe/spring-interview-must.html">【Spring】10道不得不会的Spring面试题</a></p>
<p><a href="https://github.com/yangchunjian" target="_blank" rel="noopener noreferrer">GItHub</a>|<a href="https://gitee.com/yangchunjian" target="_blank" rel="noopener noreferrer">GitEE</a></p>
]]></content:encoded>
      <enclosure url="https://tvax1.sinaimg.cn/large/007F3CC8ly1h11l1b6ykaj30x50kl46x.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>10道不得不会的 Kafka 面试题</title>
      <link>https://dearlocation.com/willbe/kafka-interview-must.html</link>
      <guid>https://dearlocation.com/willbe/kafka-interview-must.html</guid>
      <source url="https://dearlocation.com/rss.xml">10道不得不会的 Kafka 面试题</source>
      <description>kafka
</description>
      <category>最少必要面试题</category>
      <pubDate>Sun, 19 Jun 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>kafka</p>

<p>10道不得不会的 Kafka 面试题</p>
<p>我是DearLocation，专注于面试、副业，技术人的成长记录。</p>
<p>以下是 Kafka 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。<strong>DearLocation</strong>在这里整理这些容易忘记的重点知识及<strong>解答</strong>，<code>建议收藏，经常温习查阅</code>。</p>
<p>评论区见</p>
<p>@[toc]</p>
<h1 id="kafka" tabindex="-1"> Kafka</h1>
<p>在面试kafka中，一定要了解为什么要用kafka、及kafka的架构等基本概念，才能对面试中的问题得心应手。</p>
<h2 id="术语0-kafka中的isr、ar又代表什么-isr的伸缩又指什么" tabindex="-1"> 术语0. Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么</h2>
<p><strong>ISR</strong>:In-Sync Replicas 副本同步队列</p>
<p><strong>AR</strong>:Assigned Replicas 所有副本</p>
<p>ISR是由leader维护，follower从leader同步数据有一些延迟（包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度, 当前最新的版本0.10.x中只支持replica.lag.time.max.ms这个维度），任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。AR=ISR+OSR。</p>
<h2 id="术语0-kafka中的hw、leo、lso、lw等分别代表什么" tabindex="-1"> 术语0. Kafka中的HW、LEO、LSO、LW等分别代表什么？</h2>
<p><strong>HW</strong>:High Watermark 高水位，取一个partition对应的ISR中最小的LEO作为HW，consumer最多只能消费到HW所在的位置上一条信息。</p>
<p><strong>LEO</strong>:LogEndOffset 当前日志文件中下一条待写信息的offset
HW/LEO这两个都是指最后一条的下一条的位置而不是指最后一条的位置。</p>
<p><strong>LSO</strong>:Last Stable Offset 对未完成的事务而言，LSO 的值等于事务中第一条消息的位置(firstUnstableOffset)，对已完成的事务而言，它的值同 HW 相同</p>
<p><strong>LW</strong>:Low Watermark 低水位, 代表 AR 集合中最小的 logStartOffset 值</p>
<hr>
<h3 id="_1-kafka-是什么-有什么作用" tabindex="-1"> 1. kafka 是什么？有什么作用？</h3>
<p>Kafka 是一个分布式的流式处理平台，它以高吞吐、可持久化、可水平扩展、支持流数据处理等多种特性而被广泛使用</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/16668d6a19eb5cb6faddd7706e9e989b.png" alt="" loading="lazy"></p>
<p>主要功能体现于三点：</p>
<ul>
<li>
<p><strong>消息系统</strong>：kafka与传统的消息中间件都具备<strong>系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性</strong>等功能。与此同时，kafka还提供了大多数消息系统难以实现的消息顺序性保障及回溯性消费的功能。</p>
</li>
<li>
<p><strong>存储系统</strong>：kafka把<strong>消息持久化到磁盘</strong>，相比于其他基于内存存储的系统而言，有效的降低了消息丢失的风险。这得益于其消息持久化和多副本机制。也可以将kafka作为长期的存储系统来使用，只需要把对应的数据保留策略设置为“永久”或启用主题日志压缩功能。</p>
</li>
<li>
<p><strong>流式处理平台</strong>：kafka为流行的流式处理框架提供了可靠的数据来源，还提供了一个完整的流式处理框架，比如窗口、连接、变换和聚合等各类操作。</p>
</li>
</ul>
<h3 id="_2-kafka-的架构是怎么样的" tabindex="-1"> 2. kafka 的架构是怎么样的？</h3>
<blockquote>
<p>这是一个基本概念的题目，一定要掌握。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/77d41d1963c2606740b3188195eac97f.png" alt="" loading="lazy"></p>
<p>一个典型的 kafka 体系架构包括若干 Producer、若干 Consumer、以及一个 Zookeeper 集群（在2.8.0版本中移，除了 Zookeeper,通过 KRaft 进行自己的集群管理）</p>
<p>Producer 将消息发送到 Broker，Broker 负责将受到的消息存储到磁盘中，而 Consumer 负责从 Broker 订阅并消费消息。</p>
<p>Kafka 基本概念：</p>
<ul>
<li>
<p><strong>Producer</strong> ：生产者，负责将消息发送到 Broker</p>
</li>
<li>
<p><strong>Consumer</strong> ：消费者，从 Broker 接收消息</p>
</li>
<li>
<p><strong>Consumer Group</strong> ：消费者组，由多个 Consumer 组成。消费者组内每个消费者负责消费不同分区的数据，<strong>一个分区只能由一个组内消费者消费</strong>，消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</p>
</li>
<li>
<p><strong>Broker</strong> ：可以看做一个独立的 <strong>Kafka 服务节点或 Kafka 服务实例</strong>。如果一台服务器上只部署了一个 Kafka 实例，那么我们也可以将 Broker 看做一台 Kafka 服务器。</p>
</li>
<li>
<p><strong>Topic</strong> ：一个逻辑上的概念，包含很多 Partition，<strong>同一个 Topic 下的 Partiton 的消息内容是不相同的</strong>。</p>
</li>
<li>
<p><strong>Partition</strong> ：为了实现扩展性，一个非常大的 topic <strong>可以分布到多个 broker 上，一个 topic 可以分为多个 partition</strong>，每个 partition 是一个有序的队列。</p>
</li>
<li>
<p><strong>Replica</strong> ：副本，<strong>同一分区的不同副本保存的是相同的消息</strong>，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 仍然能够继续工作，- kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。</p>
</li>
<li>
<p><strong>Leader</strong> ：每个分区的多个副本中的&quot;主副本&quot;，<strong>生产者以及消费者只与 Leader 交互</strong>。</p>
</li>
<li>
<p><strong>Follower</strong> ：每个分区的多个副本中的&quot;从副本&quot;，<strong>负责实时从 Leader 中同步数据，保持和 Leader 数据的同步</strong>。Leader 发生故障时，从 Follower 副本中重新选举新的 Leader 副本对外提供服务。</p>
</li>
</ul>
<h3 id="_3-kafka-replicas是怎么管理的" tabindex="-1"> 3. Kafka Replicas是怎么管理的？</h3>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dfb283e65f030d4c660d60f3c8ca9b9c.png" alt="" loading="lazy"></p>
<ul>
<li>AR:分区中的<strong>所有 Replica 统称为 AR</strong></li>
<li>ISR:所有与 Leader 副本<strong>保持一定程度同步</strong>的Replica(包括 Leader 副本在内)组成 ISR</li>
<li>OSR:与 Leader 副本<strong>同步滞后过多的</strong> Replica 组成了 OSR</li>
</ul>
<p>Leader 负责维护和跟踪 ISR 集合中所有 Follower 副本的滞后状态，当 Follower 副本落后过多时，就会将其放入 OSR 集合，当 Follower 副本追上了 Leader 的进度时，就会将其放入 ISR 集合。</p>
<p>默认情况下，只有 <strong>ISR 中的副本才有资格晋升为 Leader</strong>。</p>
<h3 id="_4-如何确定当前能读到哪一条消息" tabindex="-1"> 4. 如何确定当前能读到哪一条消息？</h3>
<blockquote>
<p>这个问题要先了解上一个问题的概念</p>
</blockquote>
<p>分区相当于一个日志文件，我们先简单介绍几个概念</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9b038ce0fc7308c1e815ce46ac397b86.png" alt="" loading="lazy"></p>
<p>如上图是一个分区日志文件</p>
<ul>
<li>标识<strong>共有7条消息</strong>，offset (消息偏移量)分别是0~6</li>
<li>0 代表这个日志文件的<strong>开始</strong></li>
<li>HW(High Watermark) 为4，0~3 代表这个日志文件<strong>可以消费的区间</strong>，消费者只能消费到这四条消息</li>
<li>LEO 代表即将要写入消息的偏移量 offset</li>
</ul>
<p><strong>分区 ISR 集合中的每个副本都会维护自己的 LEO，而 ISR 集合中最小的LEO 即为分区的 HW</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/733241b1f3d812dc229022ddcddaadba.png" alt="" loading="lazy"></p>
<p>如上图: 三个分区副本都是 ISR集合当中的，最小的 LEO 为 3，就代表分区的 HW 为3，所以当前分区只能消费到 0~2 之间的三条数据，如下图</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5e09d8a79178af747ccbf0cc2b142063.png" alt="" loading="lazy"></p>
<h3 id="_5-发送消息的分区策略有哪些" tabindex="-1"> 5. 发送消息的分区策略有哪些？</h3>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fc5038a2800475066fb2fc7cebdbea30.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>1.轮询：<strong>依次</strong>将消息发送该topic下的所有分区，如果在创建消息的时候 key 为 null，Kafka 默认采用这种策略。</p>
</li>
<li>
<p>2.key 指定分区：在创建消息是 key 不为空，并且使用默认分区器，Kafka 会将 key 进行 hash，然后<strong>根据hash值映射到指定的分区上</strong>。这样的好处是 key 相同的消息会在一个分区下，Kafka 并不能保证全局有序，但是在每个分区下的消息是有序的，按照顺序存储，按照顺序消费。在保证同一个 key 的消息是有序的，这样基本能满足消息的顺序性的需求。但是<strong>如果 partation 数量发生变化，那就很难保证 key 与分区之间的映射关系了</strong>。</p>
</li>
<li>
<p>3.自定义策略：实现 Partitioner 接口就能自定义分区策略。</p>
</li>
<li>
<p>4.指定 Partiton 发送</p>
</li>
</ul>
<h3 id="_6-kafka-的可靠性是怎么保证的" tabindex="-1"> 6. Kafka 的可靠性是怎么保证的？</h3>
<p><strong>1.acks</strong></p>
<p>这个参数用来指定分区中有多少个副本收到这条消息，生产者才认为这条消息是写入成功的，这个参数有三个值：</p>
<ul>
<li>1.acks = 1，默认为1。生产者发送消息，<strong>只要 leader 副本成功写入消息，就代表成功</strong>。这种方案的问题在于，当返回成功后，如果 leader 副本和 follower 副本<strong>还没有来得及同步</strong>，leader 就崩溃了，那么在选举后新的 leader 就没有这条<strong>消息，也就丢失了</strong>。</li>
<li>2.acks = 0。生产者发送消息后直接算写入成功，不需要等待响应。这个方案的问题很明显，<strong>只要服务端写消息时出现任何问题，都会导致消息丢失</strong>。</li>
<li>3.acks = -1 或 acks = all。生产者发送消息后，需要等待 ISR 中的所有副本都成功写入消息后才能收到服务端的响应。毫无疑问这种方案的<strong>可靠性是最高的</strong>，但是如果 ISR 中只有leader 副本，那么就和 acks = 1 毫无差别了。</li>
</ul>
<p><strong>2.消息发送的方式</strong></p>
<p>第6问中我们提到了生产者发送消息有三种方式，发完即忘，同步和异步。我们可以通过同步或者异步获取响应结果，<strong>失败做重试</strong>来保证消息的可靠性。</p>
<p><strong>3.手动提交位移</strong></p>
<p>默认情况下，当消费者消费到消息后，就会自动提交位移。但是如果消费者消费出错，没有进入真正的业务处理，那么就可能会导致这条消息消费失败，从而丢失。我们可以开启手动提交位移，等待业务正常处理完成后，再提交offset。</p>
<p><strong>4.通过副本 LEO 来确定分区 HW</strong></p>
<p>可参考第四问</p>
<h3 id="_7-分区再分配是做什么的-解决了什么问题" tabindex="-1"> 7. 分区再分配是做什么的？解决了什么问题？</h3>
<p>分区再分配主要是用来维护 kafka 集群的负载均衡</p>
<p>既然是分区再分配，那么 kafka 分区有什么问题呢？</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e57b54803d2cf0f8f11b0acecc978e31.png" alt="" loading="lazy"></p>
<p><strong>问题1</strong>：当集群中的一个节点下线了</p>
<ul>
<li>如果该节点的分区是单副本的,那么分区将会变得不可用</li>
<li>如果是多副本的，就会进行 leader 选举，在其他机器上选举出新的 leader</li>
</ul>
<p><strong>kafka 并不会将这些失效的分区迁移到其他可用的 broker 上</strong>，这样就会影响集群的负载均衡，甚至也会影响服务的可靠性和可用性</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e2912a908a8b2672ae947e71287791db.png" alt="" loading="lazy"></p>
<p><strong>问题2</strong>：集群新增 broker 时，只有新的主题分区会分配在该 broker 上，而老的主题分区不会分配在该 broker 上，就造成了<strong>老节点和新节点之间的负载不均衡</strong>。</p>
<p>为了解决该问题就出现了分区再分配，它可以在集群扩容，broker 失效的场景下进行分区迁移。</p>
<p><strong>分区再分配的原理就是通化控制器给分区新增新的副本，然后通过网络把旧的副本数据复制到新的副本上，在复制完成后，将旧副本清除</strong>。 当然，为了不影响集群正常的性能，在此复制期间还会有一系列保证性能的操作，比如<strong>复制限流</strong>。</p>
<h3 id="_8-kafka-partition-副本-leader-是怎么选举的" tabindex="-1"> 8. Kafka Partition 副本 leader 是怎么选举的？</h3>
<blockquote>
<p>这个问题设计的点比较多，拓展的也更多一点，建议耐心阅读。</p>
</blockquote>
<p><strong>常用选主机制的缺点：</strong></p>
<div><pre><code>split-brain (脑裂):
​这是由ZooKeeper的特性引起的，虽然ZooKeeper能保证所有Watch按顺序触发，但是网络延迟，并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致，可能选出多个领导“大脑”，导致“脑裂”。

herd effect (羊群效应):
​如果宕机的那个Broker上的Partition比较多， 会造成多个Watch被触发，造成集群内大量的调整，导致大量网络阻塞。

ZooKeeper负载过重:
​每个Replica都要为此在ZooKeeper上注册一个Watch，当集群规模增加到几千个Partition时ZooKeeper负载会过重。
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>优势：</strong></p>
<p>​Kafka的Leader Election方案解决了上述问题，它在所有broker中选出一个controller，所有Partition的Leader选举都由controller决定。 controller会将Leader的改变直接通过RPC的方式(比ZooKeeper Queue的方式更高效)通知需为此作为响应的Broker。</p>
<p>​没有使用 zk，所以无 2.3 问题；也没有注册 watch无 2.2 问题 leader 失败了，就通过 controller 继续重新选举即可，所以克服所有问题。</p>
<p><strong>Kafka partition leader的选举：</strong></p>
<p>由 controller 执行：</p>
<ul>
<li>从Zookeeper中读取当前分区的所有ISR(in-sync replicas)集合</li>
<li>调用配置的分区选择算法选择分区的leader</li>
</ul>
<p><img src="https://tvax1.sinaimg.cn/large/007F3CC8ly1h3dl7rqe24j313c0nm7ik.jpg" alt="分区选择算法" loading="lazy"></p>
<p>上面五种分区算法都是选择PreferredReplica(优先副本选举)作为当前Partition的leader。区别仅仅是选择leader之后的操作有所不同。</p>
<h3 id="_9-分区数越多越好吗-吞吐量就会越高吗" tabindex="-1"> 9. 分区数越多越好吗？吞吐量就会越高吗？</h3>
<p>般类似于这种问题的答案，都是持否定态度的。</p>
<p>但是可以说，<strong>在一定条件下，分区数的数量是和吞吐量成正比的，分区数和性能也是成正比的</strong>。</p>
<p>那么为什么说超过了一定限度，就会对性能造成影响呢？原因如下:</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/54db2b5495c53fde42368a5f60ac1b0f.png" alt="" loading="lazy"></p>
<p><strong>1.客户端/服务器端需要使用的内存就越多</strong></p>
<p>服务端在很多组件中都维护了分区级别的缓存，分区数越大，缓存成本也就越大。
消费端的消费线程数是和分区数挂钩的，分区数越大消费线程数也就越多，线程的开销成本也就越大
生产者发送消息有缓存的概念，会为每个分区缓存消息，当积累到一定程度或者时间时会将消息发送到分区，分区越多，这部分的缓存也就越大</p>
<p><strong>2.文件句柄的开销</strong></p>
<p>每个 partition 都会对应磁盘文件系统的一个目录。在 Kafka 的数据日志文件目录中，每个日志数据段都会分配两个文件，一个索引文件和一个数据文件。每个 broker 会为每个日志段文件打开一个 index 文件句柄和一个数据文件句柄。因此，随着 partition 的增多，所需要保持打开状态的文件句柄数也就越多，最终可能超过底层操作系统配置的文件句柄数量限制。</p>
<p><strong>3.越多的分区可能增加端对端的延迟</strong></p>
<p>Kafka 会将分区 HW 之前的消息暴露给消费者。分区越多则副本之间的同步数量就越多，在默认情况下，每个 broker 从其他 broker 节点进行数据副本复制时，该 broker 节点只会为此工作分配一个线程，该线程需要完成该 broker 所有 partition 数据的复制。</p>
<p><strong>4.降低高可用性</strong></p>
<p>在第 7 问我们提到了分区再分配，会将数据复制到另一份副本当中，<strong>分区数量越多，那么恢复时间也就越长</strong>，而如果发生宕机的 broker 恰好是 controller 节点时：在这种情况下，新 leader 节点的选举过程在 controller 节点恢复到新的 broker 之前不会启动。controller 节点的错误恢复将会自动地进行，但是新的 controller 节点需要从 zookeeper 中读取每一个 partition 的元数据信息用于初始化数据。例如，假设一个Kafka 集群存在 10000个partition，从 zookeeper 中恢复元数据时每个 partition 大约花费 2 ms，则 controller 的恢复将会增加约 20 秒的不可用时间窗口。</p>
<h3 id="_10-kafka-为什么这么快" tabindex="-1"> 10. kafka 为什么这么快？</h3>
<p><img src="https://img-blog.csdnimg.cn/img_convert/660921f85642692c5f819c27474ebc68.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>1.<strong>顺序读写</strong>磁盘分为顺序读写与随机读写，基于磁盘的随机读写确实很慢，但磁盘的顺序读写性能却很高，kafka 这里采用的就是顺序读写。</p>
</li>
<li>
<p>2.<strong>Page Cache</strong>为了优化读写性能，Kafka 利用了<strong>操作系统本身的 Page Cache</strong>，就是利用操作系统自身的内存而不是JVM空间内存。</p>
</li>
<li>
<p>3.<strong>零拷贝</strong>Kafka使用了零拷贝技术，也就是<strong>直接将数据从内核空间的读缓冲区直接拷贝到内核空间的 socket 缓冲区</strong>，然后再写入到 NIC 缓冲区，避免了在内核空间和用户空间之间穿梭。</p>
</li>
<li>
<p>4.<strong>分区分段+索引</strong>Kafka 的 message 是按 topic分 类存储的，topic 中的数据又是按照一个一个的 partition 即分区存储到不同 broker 节点。每个 partition 对应了操作系统上的一个文件夹，partition 实际上又是按照segment分段存储的。通过这种分区分段的设计，Kafka 的 message 消息实际上是分布式存储在一个一个小的 segment 中的，每次文件操作也是直接操作的 segment。为了进一步的查询优化，Kafka 又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度。</p>
</li>
<li>
<p>5.<strong>批量读写Kafka 数据读写也是批量的而不是单条的</strong>,这样可以避免在网络上频繁传输单个消息带来的延迟和带宽开销。假设网络带宽为10MB/S，一次性传输10MB的消息比传输1KB的消息10000万次显然要快得多。</p>
</li>
<li>
<p>6.<strong>批量压缩</strong>Kafka 把所有的消息都变成一个<strong>批量的文件</strong>，并且进行合理的<strong>批量压缩</strong>，减少网络 IO 损耗，通过 mmap 提高 I/O 速度，写入数据的时候由于单个Partion是末尾添加所以速度最优；读取数据的时候配合 sendfile 进行直接读取。</p>
</li>
</ul>
<p>低谷蓄力</p>
<h2 id="《最少必要面试题》" tabindex="-1"> 《最少必要面试题》</h2>
<p><a href="https://javapub.blog.csdn.net/article/details/122011870" target="_blank" rel="noopener noreferrer">10道不得不会的Java基础面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/122159231" target="_blank" rel="noopener noreferrer">10道不得不会的Java并发基础面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/124008535" target="_blank" rel="noopener noreferrer">10道不得不会的JVM面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/122087243" target="_blank" rel="noopener noreferrer">10道不得不会的MySQL基础面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/123761794" target="_blank" rel="noopener noreferrer">10道不得不会的ElasticSearch面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的Spring面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的Redis面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的Kafka面试题</a></p>
<p><img src="https://tvax2.sinaimg.cn/large/007F3CC8ly1h3dml6lpcxj30hs0ht0tb.jpg" alt="91ec3d2507612867d21de87e798cbaba" loading="lazy"></p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/img_convert/16668d6a19eb5cb6faddd7706e9e989b.png" type="image/png"/>
    </item>
    <item>
      <title>10道不得不会的 MyBatis 面试题</title>
      <link>https://dearlocation.com/willbe/mybatis-interview-must.html</link>
      <guid>https://dearlocation.com/willbe/mybatis-interview-must.html</guid>
      <source url="https://dearlocation.com/rss.xml">10道不得不会的 MyBatis 面试题</source>
      <description>MyBatis
</description>
      <category>最少必要面试题</category>
      <pubDate>Thu, 23 Jun 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>MyBatis</p>

<p>10道不得不会的 MyBatis 面试题</p>
<p>我是DearLocation，专注于面试、副业，技术人的成长记录。</p>
<p>以下是 MyBatis 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。<strong>DearLocation</strong>在这里整理这些容易忘记的重点知识及<strong>解答</strong>，<code>建议收藏，经常温习查阅</code>。</p>
<p>评论区见</p>
<p>@[toc]</p>
<h1 id="mybatis" tabindex="-1"> MyBatis</h1>
<p>本系列<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzNDUyOTY0Nw==&amp;action=getalbum&amp;album_id=2344061143381508097#wechat_redirect" target="_blank" rel="noopener noreferrer">《最少必要面试题》</a></p>
<h3 id="_1-什么是mybatis" tabindex="-1"> 1. 什么是MyBatis</h3>
<blockquote>
<p>这个问题主要是对比JDBC来看</p>
</blockquote>
<ol>
<li>
<p>MyBatis是一个ORM（对象关系映射）框架，它内部封装了JDBC,开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动，创建连接，创建statement等复杂的过程。开发人员不需要编写原生态sql，可以严格控制sql执行性能，灵活度高。</p>
</li>
<li>
<p>MyBatis可以使用xml或者注解来配置映射原生信息，将POJO映射成数据库中的记录，避免了几乎所有的JDBC代码和手动设置的参数以及获取结果集。</p>
</li>
</ol>
<h3 id="_2-mybatis的优点" tabindex="-1"> 2. MyBatis的优点</h3>
<ol>
<li>
<p>基于SQL语句编程，相对灵活（相对于hibernate），支持写动态sql语句并可重复使用。</p>
</li>
<li>
<p>减少代码量，消除了冗余代码。（类似于JDBC的封装）</p>
</li>
<li>
<p>与Spring完美集成。</p>
</li>
<li>
<p>提供映射标签支持字段关系映射。</p>
</li>
</ol>
<h3 id="_3-和-的区别是什么" tabindex="-1"> 3. #{}和${}的区别是什么？</h3>
<ol>
<li>
<p><code>#{}</code>预编译处理、是占位符，<code>${}</code>是字符串替换、是拼接符。</p>
</li>
<li>
<p>使用<code>#{}</code>可以有效的防止sql注入，提高系统的安全性。</p>
</li>
</ol>
<p>Mybatis在处理 <code>#{}</code> 的时候会将sql中的 <code>#{}</code> 替换成？号，调用PreparedStatement来赋值</p>
<div><pre><code>/* SQL */
如：select * from user where name = #{userName}；设userName=javapub

看日志我们可以看到解析时将#{userName}替换成了 ？

select * from user where name = ?;

然后再把 javapub 放进去，外面加上单引号
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Mybatis在处理 <code>${}</code> 的时候就是把 <code>${}</code> 替换成变量的值，调用Statement来赋值</p>
<div><pre><code>/* SQL */
如：select * from user where name = #{userName}；设userName=javapub

看日志可以发现就是直接把值拼接上去了

select * from user where name = javapub;

这极有可能发生sql注入，下面举了一个简单的sql注入案例
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="_4-一个-xml-映射文件-都会写一个-dao-接口与之对应-这个-dao-接口的工作原理是什么" tabindex="-1"> 4. 一个 Xml 映射文件，都会写一个 Dao 接口与之对应，这个 Dao 接口的工作原理是什么?</h3>
<p>Dao 接口就是人们常说的 Mapper 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名就是映射文件中 <strong>MappedStatement</strong> 的 id 值，接口方法内的参数就是传递给 sql 的参数。</p>
<p>接口里的方法是<strong>不能重载</strong>的，因为是<strong>全限名+方法名</strong>的保存和寻找策略。</p>
<p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会<strong>使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行接口方法所对应的MappedStatement所代表的sql</strong>，然后将sql执行结果返回。</p>
<p>MappedStatement：MappedStatement维护了一条 &lt;select|update|delete|insert&gt;节点的封装,包括了传入参数映射配置、执行的SQL语句、结果映射配置等信息。</p>
<div><pre><code><span><span><span>&lt;</span>select</span> <span>id</span><span><span>=</span><span>"</span>selectAuthorLinkedHashMap<span>"</span></span> <span>resultType</span><span><span>=</span><span>"</span>java.util.LinkedHashMap<span>"</span></span><span>></span></span>
        select id, username from author where id = #{value}
<span><span><span>&lt;/</span>select</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h3 id="_5-如何获取自动生成的-主-键值" tabindex="-1"> 5. 如何获取自动生成的(主)键值?</h3>
<p><strong>用法：</strong></p>
<p>在 <code>&lt;insert /&gt;</code> 标签中添加 <code>useGeneratedKeys=&quot;true&quot;</code> 等属性</p>
<div><pre><code><span><span><span>&lt;</span>insert</span> <span>id</span><span><span>=</span><span>"</span>insert<span>"</span></span> <span>useGeneratedKeys</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>keyProperty</span><span><span>=</span><span>"</span>id<span>"</span></span> <span>keyColumn</span><span><span>=</span><span>"</span>id<span>"</span></span>
        <span>parameterType</span><span><span>=</span><span>"</span>person<span>"</span></span> <span>></span></span>
    INSERT INTO person(name, pswd)
    VALUE (#{name}, #{pswd})
<span><span><span>&lt;/</span>insert</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>当 Mybatis 解析 xml节点时，读到 <code>insert</code> 有配置时，会判断是否 有配置 <code>useGeneratedKeys</code>，如果有则会使用 <code>Jdbc3KeyGenerator</code> 作为sql回显，否则会以 <code>NoKeyGenerator</code> 作为主键回显。</p>
<p>底层封装了JDBC获取自增主键，即当使用 prepareStatement 或者 Statement时候，可以通过 <code>getGeneratedKeys</code> 获取这条插入语句的自增而成的主键。例子</p>
<div><pre><code>    <span>Connection</span> conn <span>=</span> <span>DriverManager</span><span>.</span><span>getConnection</span><span>(</span>url<span>,</span> <span>"root"</span><span>,</span> <span>"123456"</span><span>)</span><span>;</span>
    <span>String</span><span>[</span><span>]</span> columnNames <span>=</span> <span>{</span><span>"id"</span><span>,</span> <span>"name"</span><span>}</span><span>;</span>
    <span>PreparedStatement</span> stmt <span>=</span> conn<span>.</span><span>prepareStatement</span><span>(</span>sql<span>,</span> columnNames<span>)</span><span>;</span>
    stmt<span>.</span><span>setString</span><span>(</span><span>1</span><span>,</span> <span>"jack wang"</span><span>)</span><span>;</span>
    stmt<span>.</span><span>executeUpdate</span><span>(</span><span>)</span><span>;</span>
    <span>ResultSet</span> rs <span>=</span> stmt<span>.</span><span>getGeneratedKeys</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> id <span>=</span> <span>0</span><span>;</span>
    <span>if</span> <span>(</span>rs<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        id <span>=</span> rs<span>.</span><span>getInt</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"----------"</span> <span>+</span> id<span>)</span><span>;</span>
    <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="_6-mybatis-动态-sql-有什么用-有哪些动态-sql-执行原理" tabindex="-1"> 6. Mybatis 动态 sql 有什么用？有哪些动态 sql？执行原理？</h3>
<p>Mybatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。</p>
<p>Mybatis 提供了9种动态sql标签： <strong>trim | where | set | foreach | if | choose | when | otherwise | bind</strong>。</p>
<p>其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p>
<p>是不是有点懵，继续阅读：</p>
<p><strong>科普：</strong></p>
<p>OGNL 是 Object-Graph Navigation Language 的缩写，对象图导航语言。例如 <code>#{}</code> 语法。</p>
<p>OGNL 作用是在对象和视图之间做数据的交互，可以存取对象的属性和调用对象的方法，通过表达式可以迭代出整个对象的结构图。</p>
<p>参考一个很形象的例子。</p>
<p>有一个学生对象 student，属性分别有 id = 10，name = '小明' 和 课程对象 course，其中 course 对象中属性有：分数 score = 88，排名 rank = 5。</p>
<p>对象关系图如下：</p>
<div><pre><code>student

    id：10

    name：小明

    course：

        score：88

        rank：5
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当上下文（环境）中的对象为 student 的时候，也就是在 Mybatis 中查询时传入的参数对象为 student 的时候：</p>
<p>通过 OGNL 表达式直接获取上下文中对象的属性值，比如：</p>
<p>#{id} —&gt; 10，相对于当前上下文对象.getId()，即 student.getId() 。</p>
<p>#{name} —&gt; 小明。</p>
<p>#{course.score} —&gt; 88，相当于 student.getCourse().getScore()。</p>
<p>所以，通过 OGNL 表达式，可以迭代出整个对象的结构图。</p>
<p>发布 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzNDUyOTY0Nw==&amp;action=getalbum&amp;album_id=2344061143381508097#wechat_redirect" target="_blank" rel="noopener noreferrer">《最少必要面试题》</a></p>
<h3 id="_7-什么是mybatis的一级、二级缓存" tabindex="-1"> 7. 什么是Mybatis的一级、二级缓存?</h3>
<p><strong>一级缓存</strong>: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。</p>
<p>当Mybaits与Spring整合的时候，不带Spring事务的方法内，每次请求数据库，都会新建一个SqlSession，这时候是使用不到一级缓存的。除了事务问题，还有调用了Sqlsession的修改、添加、删除、commit()、close()等方法时，一级缓存也会被清空。</p>
<p><strong>二级缓存</strong>与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)。即使开启了二级缓存，不同的sqlsession之间的缓存数据也不是想互访就能互访的，必须等到sqlsession关闭了以后，才会把其一级缓存中的数据写入二级缓存。默认不打开二级缓存。</p>
<p>现在大多数应用都是支持分布式的，一般情况都是用中间件作为缓存层，比如redis。开启 MyBatis 的二级缓存也会多一步序列化和反序列化，影响服务性能。</p>
<h3 id="_8-mybatis的工作原理" tabindex="-1"> 8. MyBatis的工作原理</h3>
<p>一图胜千文</p>
<p><img src="https://tvax2.sinaimg.cn/large/007F3CC8ly1h3i5df8ddbj30l90ir0uj.jpg" alt="来源网络" loading="lazy"></p>
<ol>
<li>
<p>读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</p>
</li>
<li>
<p>加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</p>
</li>
<li>
<p>构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</p>
</li>
<li>
<p>创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</p>
</li>
<li>
<p>Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p>
</li>
<li>
<p>MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</p>
</li>
<li>
<p>输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。</p>
</li>
<li>
<p>输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</p>
</li>
</ol>
<h3 id="_9-什么是mybatis的接口绑定-有哪些实现方式" tabindex="-1"> 9. 什么是MyBatis的接口绑定？有哪些实现方式？</h3>
<p>接口绑定，就是在 MyBatis 中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来的SqlSession提供的方法我们可以有更加灵活的选择和设置。</p>
<p>接口绑定有两种实现方式：</p>
<ul>
<li>
<p>通过<strong>注解绑定</strong>，就是在接口的方法上面加上 @Select、@Update 等注解，里面包含Sql语句来绑定；</p>
</li>
<li>
<p>通过<strong>xml</strong>里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的 namespace 必须为接口的全路径名。当Sql语句比较简单时候，用注解绑定， 当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。</p>
</li>
</ul>
<h3 id="_10-mybatis的分页原理" tabindex="-1"> 10. Mybatis的分页原理</h3>
<p>Mybatis 使用 RowBounds 对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，所以一般不会使用。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p>分页插件的原理就是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内，拦截待执行的SQL，然后根据设置的 dialect（方言），和设置的分页参数，重写SQL ，生成带有分页语句的SQL，执行重写后的SQL，从而实现分页。</p>
<p>举例：<code>select * from student</code>，拦截sql后重写为：<code>select t.* from （select * from student）t limit 0，10</code>。</p>
<p>低谷蓄力</p>
<p><strong>《最少必要面试题》</strong></p>
<p><a href="https://javapub.blog.csdn.net/article/details/122011870" target="_blank" rel="noopener noreferrer">10道不得不会的Java基础面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/122159231" target="_blank" rel="noopener noreferrer">10道不得不会的Java并发基础面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/124008535" target="_blank" rel="noopener noreferrer">10道不得不会的JVM面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/122087243" target="_blank" rel="noopener noreferrer">10道不得不会的MySQL基础面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的MyBatis面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的Spring面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/123761794" target="_blank" rel="noopener noreferrer">10道不得不会的ElasticSearch面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的Redis面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的Kafka面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的Docker面试题</a></p>
<p><img src="https://tvax3.sinaimg.cn/large/007F3CC8ly1h3i5qc8fnyj30j708qq4k.jpg" alt="image" loading="lazy"></p>
]]></content:encoded>
      <enclosure url="https://tvax2.sinaimg.cn/large/007F3CC8ly1h3i5df8ddbj30l90ir0uj.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>10道不得不会的MySQL基础面试题</title>
      <link>https://dearlocation.com/willbe/mysql-interview-must.html</link>
      <guid>https://dearlocation.com/willbe/mysql-interview-must.html</guid>
      <source url="https://dearlocation.com/rss.xml">10道不得不会的MySQL基础面试题</source>
      <description>MySql
</description>
      <category>最少必要面试题</category>
      <pubDate>Thu, 21 Apr 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>MySql</p>

<p>10道不得不会的MySQL基础面试题</p>
<p>以下都是 <strong>MySQL常见面试题</strong>，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。<strong>DearLocation</strong>在这里整理这些容易忘记的重点知识及<strong>解答</strong>，<code>建议收藏，经常温习查阅</code>。</p>
<p>评论区见</p>
<p>@[toc]</p>
<hr>
<p>推荐一篇非常不错的文章，阅读后更有利于了解MySQL【B树和B+树的区别】：
<a href="https://mp.weixin.qq.com/s/RWkc2lNarKnn8Dc0HrP58g" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/RWkc2lNarKnn8Dc0HrP58g</a></p>
<hr>
<h2 id="_1-mysql有哪几种log" tabindex="-1"> 1. mysql有哪几种log</h2>
<p>重做日志(redo log)、回滚日志(undo log)、二进制日志(binlog)、错误日志(errorlog)、慢查询日志(slow query log)、一般查询日志(general log)，中继日志(relay log)</p>
<p>错误日志：记录出错信息，也记录一些警告信息或者正确的信息。</p>
<p>查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。</p>
<p>慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</p>
<p>二进制日志：记录对数据库执行更改的所有操作。</p>
<p>中继日志：中继日志也是二进制日志，用来给slave 库恢复</p>
<p>事务日志：重做日志redo和回滚日志undo</p>
<hr>
<h2 id="_2-mysql的复制原理以及流程" tabindex="-1"> 2. MySQL的复制原理以及流程</h2>
<ol>
<li>主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中。</li>
<li>从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中。</li>
<li>从：sql执行线程——执行relay log中的语句。</li>
</ol>
<hr>
<h2 id="_3-事物的4种隔离级别" tabindex="-1"> 3. 事物的4种隔离级别</h2>
<p>隔离强度逐渐增强，性能逐渐变差。</p>
<ul>
<li>读未提交(RU) READ UNCOMMITTED</li>
<li>读已提交(RC) READ COMMITT</li>
<li>可重复读(RR) REPEATABLE READ</li>
<li>串行化 SERIALIZABLE</li>
</ul>
<p>事务具有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）四个特性，简称 ACID，缺一不可。</p>
<hr>
<h2 id="_4-相关概念" tabindex="-1"> 4. 相关概念</h2>
<p><strong>脏读</strong></p>
<p>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。</p>
<p><strong>可重复读</strong></p>
<p>可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。通常针对数据更新（UPDATE）操作。</p>
<p><strong>不可重复读</strong></p>
<p>对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新（UPDATE）操作。</p>
<p><strong>幻读</strong></p>
<p>幻读是针对数据插入（INSERT）操作来说的。假设事务 A 对某些行的内容作了更改，但是还未提交，此时事务 B 插入了与事务 A 更改前的记录相同的记录行，并且在事务 A 提交之前先提交了，而这时，在事务 A 中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务 B 刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。</p>
<hr>
<h2 id="_5-mysql数据库几个基本的索引类型" tabindex="-1"> 5. MySQL数据库几个基本的索引类型</h2>
<p>普通索引、唯一索引、主键索引、全文索引</p>
<hr>
<h2 id="_6-drop、delete与truncate的区" tabindex="-1"> 6. drop、delete与truncate的区</h2>
<p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别</p>
<p>1、delete和truncate只删除表的数据不删除表的结构
2、速度,一般来说: drop&gt; truncate &gt;delete
3、delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;
4、如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</p>
<hr>
<h2 id="_7-数据库的乐观锁和悲观锁是什么" tabindex="-1"> 7. 数据库的乐观锁和悲观锁是什么？</h2>
<p><strong>悲观锁</strong>的特点是先获取锁，再进行业务操作，即 “悲观” 的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的 “一锁二查三更新” 即指的是使用悲观锁。</p>
<p>通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的 select … for update 操作来实现悲观锁。　当数据库执行 select for update 时会获取被 select 中的数据行的行锁，因此其他并发执行的 select for update 如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update 获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p>
<p>mysql 还有个问题是 select… for update 语句执行中，如果数据表没有添加索引或主键，所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在 mysql 中用悲观锁务必要确定走了索引，而不是全表扫描。</p>
<p><strong>乐观锁</strong>的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。</p>
<p>乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号，或者时间戳。</p>
<p><strong>乐观锁的两种实现方式：</strong></p>
<ol>
<li>
<p>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的 version 值进行比对，如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。</p>
</li>
<li>
<p>乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）,和上面的 version 类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则 OK，否则就是版本冲突。</p>
</li>
</ol>
<hr>
<h2 id="_8-sql优化方式" tabindex="-1"> 8. SQL优化方式</h2>
<ol>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如果索引是整形，那么可以在索引上设置默认值 0，确保表中列没有 null 值。</li>
<li>应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。</li>
<li>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。</li>
<li>in 和 not in 也要慎用，否则会导致全表扫描。</li>
<li>like ‘%abc%’ 也会导致全表扫描。</li>
<li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</li>
<li>应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</li>
<li>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</li>
<li>很多时候用 exists 代替 in 是一个好的选择。</li>
</ol>
<hr>
<h2 id="_9-从锁的类别上分mysql都有哪些锁呢" tabindex="-1"> 9. 从锁的类别上分MySQL都有哪些锁呢？</h2>
<p>从锁的类别上来讲，有共享锁和排他锁。</p>
<p><strong>共享锁</strong>: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p>
<p><strong>排他锁</strong>: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p>
<hr>
<p>参考：</p>
<div><pre><code>1. https://haicoder.net/note/mysql-interview/mysql-interview-optimistic-pessimism-lock.html
</code></pre><div aria-hidden="true"><div></div></div></div><hr>
<h2 id="推荐阅读" tabindex="-1"> 推荐阅读：</h2>
<p>系列面试题</p>
<p><a href="https://mp.weixin.qq.com/s/3Nviyml0cvnX_HHkZ5DjWg" target="_blank" rel="noopener noreferrer">【Java基础】10道不得不会的Java基础面试题</a></p>
<p><a href="https://mp.weixin.qq.com/s/h2tTwDVqL15rCI6rftgn9A" target="_blank" rel="noopener noreferrer">【Java并发】10道不得不会的Java并发基础面试题</a></p>
<p><a href="https://mp.weixin.qq.com/s/yVPwCoSQ-8OYvhw8bH0PtA" target="_blank" rel="noopener noreferrer">【MySQL】10道不得不会的MySQL基础面试题</a></p>
<p><a href="https://mp.weixin.qq.com/s/z3D37HqeTUmwrdheUL_Efw" target="_blank" rel="noopener noreferrer">【ElasticSearch】10道不得不会的ElasticSearch面试题</a></p>
<p><a href="/willbe/jvm-interview-must.html">【JVM】10道不得不会的JVM面试题</a></p>
<p><a href="/willbe/spring-interview-must.html">【Spring】10道不得不会的Spring面试题</a></p>
<p><a href="https://github.com/yangchunjian" target="_blank" rel="noopener noreferrer">GItHub</a>|<a href="https://gitee.com/yangchunjian" target="_blank" rel="noopener noreferrer">GitEE</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>10道不得不会的Redis面试题</title>
      <link>https://dearlocation.com/willbe/redis-interview-must.html</link>
      <guid>https://dearlocation.com/willbe/redis-interview-must.html</guid>
      <source url="https://dearlocation.com/rss.xml">10道不得不会的Redis面试题</source>
      <description>Redis
</description>
      <category>最少必要面试题</category>
      <pubDate>Wed, 15 Jun 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Redis</p>

<p>10道不得不会的 Redis 面试题</p>
<p>以下是 Redis 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。<strong>DearLocation</strong>在这里整理这些容易忘记的重点知识及<strong>解答</strong>，<code>建议收藏，经常温习查阅</code>。</p>
<p>评论区见</p>
<p>@[toc]</p>
<h3 id="_1-redis是什么" tabindex="-1"> 1. Redis是什么？</h3>
<blockquote>
<p>一般问这个问题你最少要答出以下几点</p>
</blockquote>
<p>Redis 是一个<strong>基于内存的 key-value</strong> 存储系统，数据结构包括<strong>字符串、list、set、zset（sorted set --有序集合）和hash</strong>，bitmap，GeoHash(坐标)，HyperLogLog，Streams（5.x版本以后）</p>
<h3 id="_2-你在哪些场景使用redis" tabindex="-1"> 2. 你在哪些场景使用redis</h3>
<blockquote>
<p>你有实战经验，那就直接表演。如果没有，选几个下面的经典场景</p>
</blockquote>
<ol>
<li>作为队列使用，（因为是基于内存、一般不会作为消费队列、作为循环队列必要适用）；</li>
<li>模拟类似于token这种需要设置过期时间的场景，登录失效；</li>
<li>分布式缓存，避免大量请求底层关系型数据库，大大降低数据库压力；</li>
<li>分布式锁；</li>
<li>基于 bitmap 实现布隆过滤器；</li>
<li>排行榜-基于zset（有序集合数据类型）；</li>
<li>计数器-对于浏览量、播放量等并发较高，使用 redis incr 实现计数器功能；</li>
<li>分布式会话；</li>
<li>消息系统；</li>
</ol>
<h3 id="_3-为什么redis是单线程的" tabindex="-1"> 3. 为什么Redis是单线程的?</h3>
<p>这个问题给一个官方答案</p>
<p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<h3 id="_4-redis持久化有几种方式" tabindex="-1"> 4. Redis持久化有几种方式？</h3>
<p>redis 提供了两种持久化的方式，分别是<strong>快照方式（RDB Redis DataBase）和文件追加（AOF Append Only File）</strong>。</p>
<p>显而易见，快照方式重启恢复快、但是数据更容易丢失，文件追加数据更完整、重启恢复慢。</p>
<p><strong>混合持久化方式</strong>，Redis 4.0之后新增的方式，混合持久化是结合RDB和AOF的优点，在写入的时候先把当前的数据以RDB的形式写入到文件的开头，再将后续的操作以AOF的格式存入文件当中，这样既能保证重启时的速度，又能降低数据丢失的风险。</p>
<p>在恢复时，先恢复快照方式保存的文件，然后再恢复追加文件中的增量数据。</p>
<h3 id="_5-什么是缓存穿透-怎么解决" tabindex="-1"> 5. 什么是缓存穿透？怎么解决？</h3>
<p>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍，然后返回空。</p>
<p>如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至击垮数据库系统。</p>
<p>这就叫做缓存穿透。</p>
<p><strong>怎么解决？</strong></p>
<ul>
<li>
<p>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert之后清理缓存。</p>
</li>
<li>
<p>对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该Bitmap过滤。(也就是布隆过滤器的原理：<a href="https://mp.weixin.qq.com/s?__biz=MzUzNDUyOTY0Nw==&amp;mid=2247483968&amp;idx=1&amp;sn=0251e9eed08ca688cc4442cf8223b643&amp;chksm=fa921140cde5985647e8b5a98b0e0270d59f962a2daba6784b26546a892677e5d7965811b402&amp;token=529078779&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">大白话讲解布隆过滤器</a>)</p>
</li>
</ul>
<h3 id="_6-什么是缓存雪崩" tabindex="-1"> 6. 什么是缓存雪崩?</h3>
<p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，请求直接落到数据库上，引起数据库压力过大甚至宕机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p><strong>怎么解决？</strong></p>
<p>常用的解决方案有：</p>
<ul>
<li>均匀过期</li>
<li>加互斥锁</li>
<li>缓存永不过期</li>
<li>双层缓存策略</li>
</ul>
<p><strong>均匀过期</strong>：设置不同的过期时间，让缓存失效的时间点尽量均匀。通常可以为有效期增加随机值或者统一规划有效期。</p>
<p><strong>加互斥锁</strong>：跟缓存击穿解决思路一致，同一时间只让一个线程构建缓存，其他线程阻塞排队。</p>
<p><strong>缓存永不过期</strong>：跟缓存击穿解决思路一致，缓存在物理上永远不过期，用一个异步的线程更新缓存。</p>
<p><strong>双层缓存策略</strong>：使用主备两层缓存：</p>
<p>主缓存：有效期按照经验值设置，设置为主读取的缓存，主缓存失效后从数据库加载最新值。</p>
<p>备份缓存：有效期长，获取锁失败时读取的缓存，主缓存更新时需要同步更新备份缓存。</p>
<h3 id="_7-redis使用上如何做内存优化" tabindex="-1"> 7. Redis使用上如何做内存优化？</h3>
<ol>
<li><strong>缩短键值的长度</strong></li>
</ol>
<ul>
<li>缩短值的长度才是关键，如果值是一个大的业务对象，可以将对象序列化成二进制数组；</li>
<li>首先应该在业务上进行精简，去掉不必要的属性，避免存储一些没用的数据；</li>
<li>其次是序列化的工具选择上，应该选择更高效的序列化工具来降低字节数组大小；</li>
<li>以JAVA为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如: protostuff，kryo等</li>
</ul>
<ol start="2">
<li><strong>共享对象池</strong></li>
</ol>
<p>对象共享池指Redis内部维护[0-9999]的整数对象池。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。</p>
<ol start="3">
<li><strong>字符串优化</strong></li>
</ol>
<p>因为redis的惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留。尽量做新增不做更新。</p>
<ol start="4">
<li><strong>编码优化</strong></li>
</ol>
<p>所谓编码就是具体使用哪种底层数据结构来实现。编码不同将直接影响数据的内存占用和读写效率。</p>
<p>这个需要掌握redis底层的数据结构。下图作为参考：</p>
<p><img src="https://tvax3.sinaimg.cn/large/007F3CC8ly1h391syfw1qj30hs0c2t9m.jpg" alt="image" loading="lazy"></p>
<ol start="5">
<li><strong>控制key的数量</strong></li>
</ol>
<h3 id="_8-你们redis使用哪种部署方式" tabindex="-1"> 8. 你们redis使用哪种部署方式？</h3>
<p>redis部署分为单节点、主从部署（master-slave）、哨兵部署（Sentinel）、集群部署（cluster）。</p>
<p>单节点：也就是单机部署；</p>
<p>主从部署：分为一主一从或一主多从，主从之间同步分为全量或增量。量同步：master 节点通过 BGSAVE 生成对应的RDB文件，然后发送给slave节点，slave节点接收到写入命令后将master发送过来的文件加载并写入；增量同步：即在 master-slave 关系建立开始，master每执行一次数据变更的命令就会同步至slave节点。一般会将写请求转发到master，读请求转发到slave。提高了redis的性能。</p>
<p>哨兵部署：分别有哨兵集群与Redis的主从集群，哨兵作为操作系统中的一个监控进程，对应监控每一个Redis实例，如果master服务异常（ping pong其中节点没有回复且超过了一定时间），就会多个哨兵之间进行确认，如果超过一半确认服务异常，则对master服务进行下线处理，并且选举出当前一个slave节点来转换成master节点；如果slave节点服务异常，也是经过多个哨兵确认后，进行下线处理。提高了redis集群高可用的特性，及横向扩展能力的增强。</p>
<p><img src="https://tvax4.sinaimg.cn/large/007F3CC8ly1h3923wycklj30oq0hwtbl.jpg" alt="image" loading="lazy"></p>
<p>集群部署：属于**“去中心化”**的一种方式，多个 master 节点保存整个集群中的全部数据，而数据根据 key 进行 crc-16 校验算法进行散列，将 key 散列成对应 16383 个 slot，而 Redis cluster 集群中每个 master 节点负责不同的slot范围。每个 master 节点下还可以配置多个 slave 节点，同时也可以在集群中再使用 sentinel 哨兵提升整个集群的高可用性。</p>
<p><img src="https://tvax3.sinaimg.cn/large/007F3CC8ly1h39277u34pj30py0nojxa.jpg" alt="image" loading="lazy"></p>
<h3 id="_9-redis实现分布式锁要注意什么" tabindex="-1"> 9. redis实现分布式锁要注意什么？</h3>
<ol>
<li>加锁过程要保证原子性；</li>
<li>保证谁加的锁只能被谁解锁，即Redis加锁的value，解锁时需要传入相同的value才能成功，保证value唯一性；</li>
<li>设置锁超时时间，防止加锁方异常无法释放锁时其他客户端无法获取锁，同时，超时时间要大于业务处理时间；</li>
</ol>
<p>使用Redis命令 <code>SET lock_key unique_value NX EX seconds</code> 进行加锁，单命令操作，Redis是串行执行命令，所以能保证只有一个能加锁成功。</p>
<h2 id="推荐阅读" tabindex="-1"> 推荐阅读：</h2>
<p><a href="/willbe/java-basics-interview-must.html">【Java基础】10道不得不会的Java基础面试题</a></p>
<p><a href="java-concurrent-interview-must">【Java并发】10道不得不会的Java并发基础面试题</a></p>
<p><a href="/willbe/mysql-interview-must.html">【MySQL】10道不得不会的MySQL基础面试题</a></p>
<p><a href="/willbe/elasticsearch-interview-must.html">【ElasticSearch】10道不得不会的ElasticSearch面试题</a></p>
<p><a href="/willbe/jvm-interview-must.html">【JVM】10道不得不会的JVM面试题</a></p>
<p><a href="/willbe/willbe/spring-interview-must.html">【Spring】10道不得不会的Spring面试题</a></p>
<p><a href="https://blog.csdn.net/qq_40374604/category_11740063.html" target="_blank" rel="noopener noreferrer">【Redis】10道不得不会的Redis面试题</a></p>
<p><a href="https://github.com/yangchunjian" target="_blank" rel="noopener noreferrer">GItHub</a>|<a href="https://gitee.com/yangchunjian" target="_blank" rel="noopener noreferrer">GitEE</a></p>
]]></content:encoded>
      <enclosure url="https://tvax3.sinaimg.cn/large/007F3CC8ly1h391syfw1qj30hs0c2t9m.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>10道不得不会的Spring面试题</title>
      <link>https://dearlocation.com/willbe/spring-interview-must.html</link>
      <guid>https://dearlocation.com/willbe/spring-interview-must.html</guid>
      <source url="https://dearlocation.com/rss.xml">10道不得不会的Spring面试题</source>
      <description>spring
</description>
      <category>最少必要面试题</category>
      <pubDate>Sat, 04 Jun 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>spring</p>

<p>10道不得不会的Spring面试题</p>
<p>我是DearLocation，专注于面试、副业，技术人的成长记录。</p>
<p>以下是 Spring 面试题，相信大家都会有种及眼熟又陌生的感觉、看过可能在短暂的面试后又马上忘记了。<strong>DearLocation</strong>在这里整理这些容易忘记的重点知识及<strong>解答</strong>，<code>建议收藏，经常温习查阅</code>。</p>
<p>评论区见</p>
<p>@[toc]</p>
<h1 id="spring" tabindex="-1"> Spring</h1>
<h2 id="_1-什么是-spring-框架-spring-框架有哪些主要模块" tabindex="-1"> 1. 什么是 Spring 框架？Spring 框架有哪些主要模块？</h2>
<p>Spring是针对bean的生命周期进行管理的轻量级容器，一个控制反转和面向切面的容器框架</p>
<p>Spring有七大功能模块：</p>
<p>1、Core</p>
<p>Core模块是Spring的核心类库，Core实现了IOC功能。</p>
<p>2、AOP</p>
<p>Apring AOP模块是Spring的AOP库，提供了AOP（拦截器）机制，并提供常见的拦截器，供用户自定义和配置。</p>
<p>3、orm</p>
<p>提供对常用ORM框架的管理和支持，hibernate、mybatis等。</p>
<p>4、Dao</p>
<p>Spring提供对JDBC的支持，对JDBC进行封装。</p>
<p>5、Web</p>
<p>对Struts2的支持。</p>
<p>6、Context</p>
<p>Context模块提供框架式的Bean的访问方式，其它程序可以通过Context访问Spring的Bean资源，相当于资源注入。</p>
<p>7、MVC</p>
<p>MVC模块为spring提供了一套轻量级的MVC实现，即Spring MVC。</p>
<h2 id="_2-spring-ioc、aop举例说明" tabindex="-1"> 2. Spring IOC、AOP举例说明</h2>
<blockquote>
<p>这是一个基础问题，如果理解有难度、建议先读五遍。</p>
</blockquote>
<p>1、IOC理论的背景</p>
<p>我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。</p>
<p><img src="https://pic002.cnblogs.com/images/2011/230454/2011052709382686.jpg" alt="图1：软件系统中耦合的对象" loading="lazy"></p>
<p>如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒 针顺时针旋转，从而在表盘上产生正确的时间。图1中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项 任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。
齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着 工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临 更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。</p>
<p><img src="https://pic002.cnblogs.com/images/2011/230454/2011052709390013.jpg" alt="图2：对象之间复杂的依赖关系" loading="lazy"></p>
<p>耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。<strong>为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中，很多的J2EE项目均采用了IOC框架产品Spring。</strong></p>
<p>2、什么是控制反转(IoC)</p>
<p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”，还有些书籍翻译成为“控制反向”或者“控制倒置”。
1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以 后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依 赖关系的对象之间的解耦，如下图：</p>
<p><img src="https://pic002.cnblogs.com/images/2011/230454/2011052709391014.jpg" alt="图3：IOC解耦过程" loading="lazy"></p>
<p>大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三 方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有 对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。
我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统：</p>
<p><img src="https://pic002.cnblogs.com/images/2011/230454/2011052709392670.jpg" alt="图4：拿掉IoC容器后的系统" loading="lazy"></p>
<p>我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样 的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言， 这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！
我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：
软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。
软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。
通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</p>
<p>参考资料：<a href="https://www.cnblogs.com/jianmang/articles/4947615.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/jianmang/articles/4947615.html</a></p>
<h2 id="_3-什么是控制反转-ioc-什么是依赖注入-di" tabindex="-1"> 3. 什么是控制反转(IOC)？什么是依赖注入（DI）？</h2>
<p>IoC(Inversion of Control) – 控制反转。它不是一种技术，而是一种思想。</p>
<p>IOC：就是对象之间的依赖关系由容器来创建，对象之间的关系本来是由我们开发者自己创建和维护的，在我们使用Spring框架后，对象之间的关系由容器来创建和维护，将开发者做的事让容器做，这就是控制反转。BeanFactory接口是Spring Ioc容器的核心接口。</p>
<p>DI：我们在使用Spring容器的时候，容器通过调用set方法或者是构造器来建立对象之间的依赖关系。
控制反转是目标，依赖注入是我们实现控制反转的一种手段。</p>
<h2 id="_4-描述一下-spring-bean-的生命周期" tabindex="-1"> 4. 描述一下 Spring Bean 的生命周期？</h2>
<blockquote>
<p>这道题是spring一道标准题目</p>
</blockquote>
<p>按照阶段理解Spring中的bean的生命周期主要包含四个阶段：<code>实例化Bean --＞ Bean属性填充 --＞ 初始化Bean --＞销毁Bean</code></p>
<p><img src="https://img-blog.csdnimg.cn/cfbab93142834a37803ba692fcd8f0fa.png" alt="Spring Bean 的生命周期" loading="lazy"></p>
<ol>
<li>
<p>Spring中的bean的生命周期主要包含四个阶段：实例化Bean --＞ Bean属性填充 --＞ 初始化Bean --＞销毁Bean</p>
</li>
<li>
<p>首先是实例化Bean，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚末初始化的依赖时，容器就会调用doCreateBean()方法进行实例化，实际上就是通过反射的方式创建出一个bean对象</p>
</li>
<li>
<p>Bean实例创建出来后，接着就是给这个Bean对象进行属性填充，也就是注入这个Bean依赖的其它bean对象</p>
</li>
<li>
<p>属性填充完成后，进行初始化Bean操作，初始化阶段又可以分为几个步骤：</p>
</li>
</ol>
<p>a. 执行Aware接口的方法</p>
<blockquote>
<p>Spring会检测该对象是否实现了xxxAware接口，通过Aware类型的接口，可以让我们拿到Spring容器的些资源。如实现BeanNameAware接口可以获取到BeanName，实现BeanFactoryAware接口可以获取到工厂对象BeanFactory等</p>
</blockquote>
<p>b. 执行BeanPostProcessor的前置处理方法postProcessBeforelnitialization()，对Bean进行一些自定义的前置处理</p>
<p>c. 判断Bean是否实现了InitializingBean接口，如果实现了，将会执行lnitializingBean的afeterPropertiesSet()初始化方法；</p>
<p>d. 执行用户自定义的初始化方法，如init-method等；</p>
<p>e. 执行BeanPostProcessor的后置处理方法postProcessAfterinitialization()</p>
<ol start="5">
<li>初始化完成后，Bean就成功创建了，之后就可以使用这个Bean， 当Bean不再需要时，会进行销毁操作，</li>
</ol>
<p>a. 首先判断Bean是否实现了DestructionAwareBeanPostProcessor接口，如果实现了，则会执行DestructionAwareBeanPostProcessor后置处理器的销毁回调方法
b. 其次会判断Bean是否实现了DisposableBean接口，如果实现了将会调用其实现的destroy()方法
c. 最后判断这个Bean是否配置了dlestroy-method等自定义的销毁方法，如果有的话，则会自动调用其配置的销毁方法；</p>
<h2 id="_5-spring-bean-的作用域之间有什么区别" tabindex="-1"> 5. Spring Bean 的作用域之间有什么区别？</h2>
<p><strong>Spring器中的bean可以分为5个范围：</strong></p>
<ol>
<li>singleton：这种bean范围是默认的，这种范围确保不管接受多少请求，每个容器中只有一个bean的实例，单例模式；</li>
<li>prototype：为每一个bean提供一个实例；</li>
<li>request：在请求bean范围内为每一个来自客户端的网络请求创建一个实例，在请求完毕后，bean会失效并被垃圾回收器回收；</li>
<li>session：为每个session创建一个实例，session过期后，bean会随之消失；</li>
<li>global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet公用全局的存储变量的话，那么全局变量需要存储在global-session中。</li>
</ol>
<h2 id="_6-spring中都应用了哪些设计模式" tabindex="-1"> 6. Spring中都应用了哪些设计模式</h2>
<p>1、简单工厂模式</p>
<p>简单工厂模式的本质就是一个工厂类根据传入的参数，动态的决定实例化哪个类。</p>
<p>Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象。</p>
<p>2、工厂方法模式</p>
<p>应用程序将对象的创建及初始化职责交给工厂对象，工厂Bean。</p>
<p>定义工厂方法，然后通过config.xml配置文件，将其纳入Spring容器来管理，需要通过factory-method指定静态方法名称。</p>
<p>3、单例模式</p>
<p>Spring用的是双重判断加锁的单例模式，通过getSingleton方法从singletonObjects中获取bean。</p>
<div><pre><code>     /**
     * Return the (raw) singleton object registered under the given name.
     * &lt;p&gt;Checks already instantiated singletons and also allows for an early
     * reference to a currently created singleton (resolving a circular reference).
     * @param beanName the name of the bean to look for
     * @param allowEarlyReference whether early references should be created or not
     * @return the registered singleton object, or {@code null} if none found
     */
    protected Object getSingleton(String beanName, boolean allowEarlyReference) {
        Object singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
            synchronized (this.singletonObjects) {
                singletonObject = this.earlySingletonObjects.get(beanName);
                if (singletonObject == null &amp;&amp; allowEarlyReference) {
                    ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
                    if (singletonFactory != null) {
                        singletonObject = singletonFactory.getObject();
                        this.earlySingletonObjects.put(beanName, singletonObject);
                        this.singletonFactories.remove(beanName);
                    }
                }
            }
        }
        return (singletonObject != NULL_OBJECT ? singletonObject : null);
    }
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>4、代理模式</p>
<p>Spring的AOP中，使用的Advice（通知）来增强被代理类的功能。Spring实现AOP功能的原理就是代理模式（① JDK动态代理，② CGLIB字节码生成技术代理。）对类进行方法级别的切面增强。</p>
<p>5、装饰器模式</p>
<p>装饰器模式：动态的给一个对象添加一些额外的功能。</p>
<p>Spring的ApplicationContext中配置所有的DataSource。这些DataSource可能是不同的数据库，然后SessionFactory根据用户的每次请求，将DataSource设置成不同的数据源，以达到切换数据源的目的。</p>
<p>在Spring中有两种表现：</p>
<p>一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>
<p>6、观察者模式</p>
<p>定义对象间的一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</p>
<p>Spring中观察者模式一般用在listener的实现。</p>
<p>7、策略模式</p>
<p>策略模式是行为性模式，调用不同的方法，适应行为的变化 ，强调父类的调用子类的特性 。</p>
<p>getHandler是HandlerMapping接口中的唯一方法，用于根据请求找到匹配的处理器。</p>
<p>8、模板方法模式</p>
<p>Spring JdbcTemplate的query方法总体结构是一个模板方法+回调函数，query方法中调用的execute()是一个模板方法，而预期的回调doInStatement(Statement state)方法也是一个模板方法。</p>
<h2 id="_7-spring-aop里面的几个名词的概念" tabindex="-1"> 7. Spring AOP里面的几个名词的概念</h2>
<p>（1）连接点（Join point）：指程序运行过程中所执行的方法。在Spring AOP中，一个连接点总代表一个方法的执行。</p>
<p>（2）切面（Aspect）：被抽取出来的公共模块，可以用来会横切多个对象。Aspect切面可以看成 Pointcut切点 和 Advice通知 的结合，一个切面可以由多个切点和通知组成。</p>
<blockquote>
<p>在Spring AOP中，切面可以在类上使用 @AspectJ 注解来实现。</p>
</blockquote>
<p>（3）切点（Pointcut）：切点用于定义 要对哪些Join point进行拦截。</p>
<blockquote>
<p>切点分为execution方式和annotation方式。execution方式可以用路径表达式指定对哪些方法拦截，比如指定拦截add*、search*。annotation方式可以指定被哪些注解修饰的代码进行拦截。</p>
</blockquote>
<p>（4）通知（Advice）：指要在连接点（Join Point）上执行的动作，即增强的逻辑，比如权限校验和、日志记录等。通知有各种类型，包括Around、Before、After、After returning、After throwing。</p>
<p>（5）目标对象（Target）：包含连接点的对象，也称作被通知（Advice）的对象。 由于Spring AOP是通过动态代理实现的，所以这个对象永远是一个代理对象。</p>
<p>（6）织入（Weaving）：通过动态代理，在目标对象（Target）的方法（即连接点Join point）中执行增强逻辑（Advice）的过程。</p>
<p>（7）引入（Introduction）：添加额外的方法或者字段到被通知的类。Spring允许引入新的接口（以及对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。</p>
<p>几个概念的关系图可以参考下图：</p>
<p><img src="https://img-blog.csdnimg.cn/2020120700443256.png" alt="" loading="lazy"></p>
<p>网上有张非常形象的图，描述了各个概念所处的场景和作用，贴在这里供大家理解：</p>
<p><img src="https://img-blog.csdnimg.cn/20201207001947787.png" alt="" loading="lazy"></p>
<h2 id="_8-beanfactory和applicationcontext有什么区别" tabindex="-1"> 8. BeanFactory和ApplicationContext有什么区别？</h2>
<p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。</p>
<ol>
<li>BeanFactory是Spring里面最底层的接口，是IoC的核心，定义了IoC的基本功能，包含了各种Bean的定义、加载、实例化，依赖注入和生命周期管理。ApplicationContext接口作为BeanFactory的子类，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</li>
</ol>
<ul>
<li>继承MessageSource，因此支持国际化。</li>
<li>资源文件访问，如URL和文件（ResourceLoader）。</li>
<li>载入多个（有继承关系）上下文（即同时加载多个配置文件） ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li>
<li>提供在监听器中注册bean的事件。</li>
</ul>
<ol start="2">
<li></li>
</ol>
<p>a. BeanFactroy采用的是延迟加载形式来注入Bean的，只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能提前发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>
<p>b. ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。</p>
<p>c. ApplicationContext启动后预载入所有的单实例Bean，所以在运行的时候速度比较快，因为它们已经创建好了。相对于BeanFactory，ApplicationContext 唯一的不足是占用内存空间，当应用程序配置Bean较多时，程序启动较慢。</p>
<ol start="3">
<li>
<p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>
</li>
<li>
<p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p>
</li>
</ol>
<h2 id="_9-spring如何解决循环依赖问题" tabindex="-1"> 9. Spring如何解决循环依赖问题：</h2>
<p>见：<a href="https://javapub.blog.csdn.net/" target="_blank" rel="noopener noreferrer">https://javapub.blog.csdn.net/</a></p>
<p>循环依赖问题在Spring中主要有三种情况：</p>
<ul>
<li>（1）通过构造方法进行依赖注入时产生的循环依赖问题。</li>
<li>（2）通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。</li>
<li>（3）通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。</li>
</ul>
<p>在Spring中，只有第（3）种方式的循环依赖问题被解决了，其他两种方式在遇到循环依赖问题时都会产生异常。这是因为：</p>
<ul>
<li>第一种构造方法注入的情况下，在new对象的时候就会堵塞住了，其实也就是”先有鸡还是先有蛋“的历史难题。</li>
<li>第二种setter方法（多例）的情况下，每一次getBean()时，都会产生一个新的Bean，如此反复下去就会有无穷无尽的Bean产生了，最终就会导致OOM问题的出现。</li>
</ul>
<p>Spring在单例模式下的setter方法依赖注入引起的循环依赖问题，主要是通过二级缓存和三级缓存来解决的，其中三级缓存是主要功臣。解决的核心原理就是：在对象实例化之后，依赖注入之前，Spring提前暴露的Bean实例的引用在第三级缓存中进行存储。</p>
<p><strong>第一种构造方法注入的情况：</strong></p>
<blockquote>
<p>例如：类A通过构造函数注入需要类B的实例，而类B通过构造函数注入需要类A的实例。如果将A类和B类的bean配置为相互注入，则Spring IoC容器会在运行时检测此循环引用，并抛出a <code>BeanCurrentlyInCreationException</code>。
一种可能的解决方案是编辑由setter而不是构造函数配置的某些类的源代码。或者，避免构造函数注入并仅使用setter注入。换句话说，尽管不推荐使用，但您可以使用setter注入配置循环依赖关系。
与典型情况（没有循环依赖）不同，bean A和bean B之间的循环依赖强制其中一个bean在完全初始化之前被注入另一个bean（经典的鸡与鸡蛋场景）。</p>
</blockquote>
<div><pre><code>    <span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>"</span>person<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>pojo.Person<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>constructor-arg</span> <span>index</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>小明<span>"</span></span><span>/></span></span>
        <span><span><span>&lt;</span>constructor-arg</span> <span>index</span><span><span>=</span><span>"</span>1<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>12<span>"</span></span><span>/></span></span>
        <span><span><span>&lt;</span>constructor-arg</span> <span>index</span><span><span>=</span><span>"</span>2<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>student<span>"</span></span><span>/></span></span>
    <span><span><span>&lt;/</span>bean</span><span>></span></span>

    <span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>"</span>student<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>pojo.Student<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>constructor-arg</span> <span>index</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>小王<span>"</span></span><span>/></span></span>
        <span><span><span>&lt;</span>constructor-arg</span> <span>index</span><span><span>=</span><span>"</span>1<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>13<span>"</span></span><span>/></span></span>
        <span><span><span>&lt;</span>constructor-arg</span> <span>index</span><span><span>=</span><span>"</span>2<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>person<span>"</span></span><span>/></span></span>
    <span><span><span>&lt;/</span>bean</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_10-spring事务的实现方式和实现原理" tabindex="-1"> 10. Spring事务的实现方式和实现原理：</h2>
<p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。Spring只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过 redo log 和 undo log实现的。Spring会在事务开始时，根据当前环境中设置的隔离级别，调整数据库隔离级别，由此保持一致。</p>
<p><strong>1. Spring事务的种类：</strong></p>
<p>spring支持编程式事务管理和声明式事务管理两种方式：</p>
<p>a. 编程式事务管理使用 TransactionTemplate。</p>
<p>b. 声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p>
<blockquote>
<p>声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>
</blockquote>
<p><strong>2. spring的事务传播机制：</strong></p>
<p>spring事务的传播机制说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。事务传播机制实际上是使用简单的ThreadLocal实现的，所以，如果调用的方法是在新线程调用的，事务传播实际上是会失效的。</p>
<blockquote>
<p>① PROPAGATION_REQUIRED：（默认传播行为）如果当前没有事务，就创建一个新事务；如果当前存在事务，就加入该事务。</p>
<p>② PROPAGATION_REQUIRES_NEW：无论当前存不存在事务，都创建新事务进行执行。</p>
<p>③ PROPAGATION_SUPPORTS：如果当前存在事务，就加入该事务；如果当前不存在事务，就以非事务执行。‘</p>
<p>④ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
<p>⑤ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则按REQUIRED属性执行。</p>
<p>⑥ PROPAGATION_MANDATORY：如果当前存在事务，就加入该事务；如果当前不存在事务，就抛出异常。</p>
<p>⑦ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p>
</blockquote>
<p>事务不只限于脏读、幻读等名词。</p>
<p><strong>3. Spring中的隔离级别：</strong></p>
<blockquote>
<p>① ISOLATION_DEFAULT：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。</p>
<p>② ISOLATION_READ_UNCOMMITTED：读未提交，允许事务在执行过程中，读取其他事务未提交的数据。</p>
<p>③ ISOLATION_READ_COMMITTED：读已提交，允许事务在执行过程中，读取其他事务已经提交的数据。</p>
<p>④ ISOLATION_REPEATABLE_READ：可重复读，在同一个事务内，任意时刻的查询结果都是一致的。</p>
<p>⑤ ISOLATION_SERIALIZABLE：所有事务逐个依次执行。</p>
</blockquote>
<p>低谷蓄力</p>
<p><strong>最少必要面试题</strong></p>
<p><a href="https://javapub.blog.csdn.net/article/details/122011870" target="_blank" rel="noopener noreferrer">10道不得不会的Java基础面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/122087243" target="_blank" rel="noopener noreferrer">10道不得不会的MySQL基础面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/122159231" target="_blank" rel="noopener noreferrer">10道不得不会的Java并发基础面试题</a></p>
<p><a href="https://javapub.blog.csdn.net/article/details/124008535" target="_blank" rel="noopener noreferrer">10道不得不会的JVM面试题</a></p>
<p><a href="https://blog.csdn.net/qq_40374604/article/details/123761794" target="_blank" rel="noopener noreferrer">10道不得不会的ElasticSearch面试题</a></p>
<p><a href="https://blog.csdn.net/qq_40374604/category_11740063.html" target="_blank" rel="noopener noreferrer">10道不得不会的Spring面试题</a></p>
<p><img src="https://tvax3.sinaimg.cn/large/007F3CC8ly1h32gkgw3jrj30je0aignk.jpg" alt="image" loading="lazy"></p>
]]></content:encoded>
      <enclosure url="https://pic002.cnblogs.com/images/2011/230454/2011052709382686.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>幻灯片页</title>
      <link>https://dearlocation.com/zh/slide.html</link>
      <guid>https://dearlocation.com/zh/slide.html</guid>
      <source url="https://dearlocation.com/rss.xml">幻灯片页</source>
      <pubDate>Tue, 28 Jun 2022 11:46:24 GMT</pubDate>
      <content:encoded><![CDATA[
<i>Content not supported</i>]]></content:encoded>
      <enclosure url="https://dearlocation.com/logo.svg" type="image/svg+xml"/>
    </item>
    <item>
      <title>随记</title>
      <link>https://dearlocation.com/me/2022-04/essay.html</link>
      <guid>https://dearlocation.com/me/2022-04/essay.html</guid>
      <source url="https://dearlocation.com/rss.xml">随记</source>
      <description>随记
</description>
      <category>我</category>
      <pubDate>Thu, 28 Apr 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>随记</p>

<p>不用猜了，帅哥一枚，哈哈~</p>
]]></content:encoded>
    </item>
    <item>
      <title>ip飘移</title>
      <link>https://dearlocation.com/posts/article/ip-switch.html</link>
      <guid>https://dearlocation.com/posts/article/ip-switch.html</guid>
      <source url="https://dearlocation.com/rss.xml">ip飘移</source>
      <description>各大主流社交软件显示ip地址，如何实现ip飘移
</description>
      <category>vpn</category>
      <pubDate>Sun, 01 May 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>各大主流社交软件显示ip地址，如何实现ip飘移</p>

<p>[toc]</p>
<p>今日一则被一则报道刷下，<strong>微信公众号、抖音、微博等社交媒体平台全量开放IP属地功能，导致很多大V都“翻车”了。</strong></p>
<p>大致原因微信也做了解释如下：</p>
<p><img src="https://tvax1.sinaimg.cn/large/007F3CC8ly1h1srm99siyj30ic0vdn6c.jpg" alt="image" loading="lazy"></p>
<p>看看各位up主身在何方！</p>
<p><img src="https://tva3.sinaimg.cn/large/007F3CC8ly1h1srrx5azzj30k10lsdnm.jpg" alt="image" loading="lazy"></p>
<p><img src="https://tvax4.sinaimg.cn/large/007F3CC8ly1h1srsfvp6yj30jz0gxwkl.jpg" alt="image" loading="lazy"></p>
<p>互联网不是法外之地。习惯在阳光下说话，秉持“底线自觉”，网络空间中的文明指数一定会逐步提升，每个人也都将是受益者。双手支持国家的这项政策。</p>
<p>其实作为up主，相信很多人都收到过或大或小的网络暴力，这次得举动也是对网络环境的一点点警示作用。还有类似 Russia and Ukraine 等如果太激进话题也不符合社会主义核心价值观。</p>
<p>后台看了下，大多数股东都是从事互联网行业的，让自己的ip闪电飘移是基础操作。今天介绍一种傻瓜式操作方式、保姆级教程、手把手教学。当然，如果保姆没教会，可以私信我。</p>
<h2 id="搭建" tabindex="-1"> 搭建</h2>
<p>这里使用热门的 V2Ray 搭建梯服务器的工具和协议</p>
<p>官网在这里，为了防止漏洞，大家定时更新下客户端和服务端。
<a href="https://github.com/v2ray/v2ray-core/" target="_blank" rel="noopener noreferrer">https://github.com/v2ray/v2ray-core/</a></p>
<p><strong>首先：</strong></p>
<p>需要的服务器资源，自行解决，某云也有提供。如果你想白嫖也可以私信我，白嫖稳定性可想而知，但是突然用一下是够。</p>
<h3 id="服务端" tabindex="-1"> 服务端</h3>
<p>服务器系统 centos7 64位</p>
<ol>
<li>安装wget</li>
</ol>
<blockquote>
<p>yum -y install wget</p>
</blockquote>
<ol start="2">
<li>下载脚本</li>
</ol>
<blockquote>
<p>wget <a href="https://install.direct/go.sh" target="_blank" rel="noopener noreferrer">https://install.direct/go.sh</a></p>
</blockquote>
<ol start="3">
<li>安装unzip</li>
</ol>
<p>因为centos不支持apt-get，我们需要安装unzip</p>
<blockquote>
<p>yum install zip unzip</p>
</blockquote>
<ol start="4">
<li>执行安装</li>
</ol>
<blockquote>
<p>bash <a href="http://go.sh" target="_blank" rel="noopener noreferrer">go.sh</a></p>
</blockquote>
<p><img src="https://tvax3.sinaimg.cn/large/007F3CC8ly1h1t02qio7hj30kb0ckjzl.jpg" alt="image" loading="lazy"></p>
<p>执行以上步骤提示如下错误信息：</p>
<div><pre><code>ERROR: This script has been DISCARDED, please switch to fhs-install-v2ray project.

HOW TO USE: https://github.com/v2fly/fhs-install-v2ray

TO MIGRATE: https://github.com/v2fly/fhs-install-v2ray/wiki/Migrate-from-the-old-script-to-this

可以参见：http://loonlog.com/2020/10/5/v2ray-server-new/，如果还有问题可以私信
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>使用以下脚本：</p>
<blockquote>
<p>curl -Ls <a href="https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh" target="_blank" rel="noopener noreferrer">https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh</a> | sudo bash</p>
</blockquote>
<ol start="5">
<li>配置</li>
</ol>
<p>服务端其实是不需要再进行任何配置的，配置文件位于 <code>/etc/v2ray/config.json</code>，使用 <code>cat /etc/v2ray/config.json</code> 查看配置信息。</p>
<p>配置信息主要注意以下几点：</p>
<ul>
<li>
<p>配置文件中的id、端口、alterId需要和客户端的配置保持一致；</p>
</li>
<li>
<p>服务端使用脚本安装成功之后默认就是vmess协议；</p>
</li>
<li>
<p>配置完成之后重启v2ray。</p>
</li>
<li>
<p>下图后面也有，可以对比理解</p>
</li>
</ul>
<p><img src="https://tvax3.sinaimg.cn/large/007F3CC8ly1h1t09loyx2j30uz0fuwl4.jpg" alt="image" loading="lazy"></p>
<ol start="6">
<li>常用的启动，停止，重启v2ray命令</li>
</ol>
<p>在首次安装完成之后，V2Ray不会自动启动，需要手动运行上述启动命令。而在已经运行V2Ray的VPS上再次执行安装脚本，安装脚本会自动停止V2Ray 进程，升级V2Ray程序，然后自动运行V2Ray。在升级过程中，配置文件不会被修改。</p>
<p>启动</p>
<blockquote>
<p>systemctl start v2ray</p>
</blockquote>
<p>停止</p>
<p><code>systemctl stop v2ray</code></p>
<p>重启</p>
<p><code>systemctl restart v2ray</code></p>
<p>关于软件更新：更新 V2Ray 的方法是再次执行安装脚本！再次执行安装脚本！再次执行安装脚本！</p>
<ol start="7">
<li>防火墙端口的打开</li>
</ol>
<p>centos系统防火墙需要开启</p>
<p>查看已开放端口</p>
<blockquote>
<p>firewall-cmd --zone=public --list-ports</p>
</blockquote>
<p>添加开放端口</p>
<blockquote>
<p>firewall-cmd --zone=public --add-port=80/tcp --permanent</p>
</blockquote>
<p>重载防火墙配置，不然查看开放端口都查不到，也不能用，重载配置后即可</p>
<blockquote>
<p>firewall-cmd --reload</p>
</blockquote>
<p>如果哪一天发现怎么无法使用了，有可能是IP被屏蔽，也有肯能是端口被封，这个时候就需要换个端口，别忘记防火墙开启新端口，那旧端口就可以删除了：</p>
<p>删除端口：</p>
<blockquote>
<p>firewall-cmd --zone=public --remove-port=123456/tcp --permanent</p>
</blockquote>
<h3 id="客户端windows" tabindex="-1"> 客户端Windows</h3>
<p><strong>1. 下载windows客户端</strong></p>
<div><pre><code>下载【v2ray-windows-64.zip Github Release】； https://github.com/v2ray/v2ray-core/releases

下载【v2rayN-v2rayN.exe-Github Release】；https://github.com/2dust/v2rayN/releases
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>第一个下载，对v2ray-windows-64.zip进行解压，</p>
<p>第二个下载，解压后，将下载的V2RayN.exe和一个汉化文件夹复制到第一个下载解压后的目录，即两个下载好的文件需要在同一目录。</p>
<p><img src="https://tvax4.sinaimg.cn/large/007F3CC8ly1h1t0fe5rnoj306o06ewfr.jpg" alt="image" loading="lazy"></p>
<p><img src="https://tva4.sinaimg.cn/large/007F3CC8ly1h1t0fkftu4j30gs09uwj1.jpg" alt="image" loading="lazy"></p>
<p><strong>2. 配置windows客户端</strong></p>
<p>运行V2RayN.exe，然后进行配置。</p>
<p>客户端的配置需要根据你的服务端进行相应的配置，因为你的服务端协议可能是vmess,shadowsocks等。</p>
<p>如果你的服务端配置是协议vmess，则配置如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007F3CC8ly1h1t0gc9iklj30rg0h7n2x.jpg" alt="image" loading="lazy"></p>
<p><img src="https://tvax1.sinaimg.cn/large/007F3CC8ly1h1t0gga6kmj30uz0fuwl4.jpg" alt="image" loading="lazy"></p>
<p><strong>3. 启用代理</strong></p>
<p>右击V2RayN运行的图标</p>
<p><img src="https://tva2.sinaimg.cn/large/007F3CC8ly1h1t0h4dd4pj30ee04s40y.jpg" alt="image" loading="lazy"></p>
<p>以上代理就完成了，但是还不能 <code>学科网上</code></p>
<p>需要如下设置，就是设置本地代理模式，这里使用谷歌浏览器的一个插件：“SwitchyOmega”</p>
<p>SwitchyOmega</p>
<p>这具体是个什么东西，自行百度，我也说不明白，哈哈</p>
<ol>
<li>下载谷歌浏览器插件</li>
</ol>
<p>下载地址，翻到下面，下载crx文件 <a href="https://github.com/FelisCatus/SwitchyOmega/releases/" target="_blank" rel="noopener noreferrer">https://github.com/FelisCatus/SwitchyOmega/releases/</a></p>
<p><img src="https://tva4.sinaimg.cn/large/007F3CC8ly1h1t0kawbkfj30m9051gmv.jpg" alt="image" loading="lazy"></p>
<ol start="2">
<li>安装插件</li>
</ol>
<p>把下载的文件扩展名crx改为zip，然后解压</p>
<p>点击谷歌浏览器右边面包按钮，找到更多工具-扩展程序，打开开发这模式</p>
<p>加载已解压的扩展程序，选择刚刚解压的文件夹，即可安装成功，有错误提示忽略</p>
<ol start="3">
<li>配置扩展程序</li>
</ol>
<p>打开配置界面，如下3张图：</p>
<p>根据123步骤进行配置</p>
<p><img src="https://tvax4.sinaimg.cn/large/007F3CC8ly1h1t0l0c9v5j30pe0iewjv.jpg" alt="image" loading="lazy"></p>
<p><img src="https://tva1.sinaimg.cn/large/007F3CC8ly1h1t0l7cbk9j30po0fy0yv.jpg" alt="image" loading="lazy"></p>
<p><img src="https://tvax3.sinaimg.cn/large/007F3CC8ly1h1t0lytreqj30pg0mz79q.jpg" alt="image" loading="lazy"></p>
<p>这个规则列表地址是 <a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener noreferrer">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a></p>
<p>大家可以直接复制利用</p>
<p>规则列表地址是大神提供的需要地址，这里我们直接使用，这样就可以facebook，内网就正常渠道上网</p>
<p><img src="https://tva1.sinaimg.cn/large/007F3CC8ly1h1t0mky07uj30tt0ixtjb.jpg" alt="image" loading="lazy"></p>
<h3 id="客户端" tabindex="-1"> 客户端</h3>
<ol>
<li>
<p>安卓：<a href="https://github.com/2dust/v2rayNG/releases" target="_blank" rel="noopener noreferrer">https://github.com/2dust/v2rayNG/releases</a></p>
</li>
<li>
<p>安卓：<a href="https://apkpure.com/bifrostv/com.github.dawndiy.bifrostv" target="_blank" rel="noopener noreferrer">https://apkpure.com/bifrostv/com.github.dawndiy.bifrostv</a></p>
</li>
<li>
<p>ios：<a href="https://itunes.apple.com/us/app/i2ray/id1445270056?mt=8" target="_blank" rel="noopener noreferrer">https://itunes.apple.com/us/app/i2ray/id1445270056?mt=8</a></p>
</li>
<li>
<p>mac：<a href="https://github.com/Cenmrev/V2RayX/releases" target="_blank" rel="noopener noreferrer">https://github.com/Cenmrev/V2RayX/releases</a></p>
</li>
</ol>
<p>如果有什么疑惑联系讨论</p>
]]></content:encoded>
      <enclosure url="https://tvax1.sinaimg.cn/large/007F3CC8ly1h1srm99siyj30ic0vdn6c.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Java练手项目 [第一弹]</title>
      <link>https://dearlocation.com/posts/article/java-project-1.html</link>
      <guid>https://dearlocation.com/posts/article/java-project-1.html</guid>
      <source url="https://dearlocation.com/rss.xml">Java练手项目 [第一弹]</source>
      <description>源码+文档+免费领取
</description>
      <category>Java练手项目</category>
      <pubDate>Sun, 24 Apr 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>源码+文档+免费领取</p>

<p>Java练手项目 [第一弹]</p>
<p><img src="https://tva2.sinaimg.cn/large/007F3CC8ly1h1l2mnl7y0j30oq09h76p.jpg" alt="image" loading="lazy"></p>
<p>最近总有人私信我，问有没有Java练手的项目今天 yangchunjian 在这分享几个</p>
<h2 id="_1-基于ssm图书馆管理系统" tabindex="-1"> 1. 基于SSM图书馆管理系统</h2>
<p>项目地址：<a href="https://mp.weixin.qq.com/s/rydMsMCGZG5F-F-LpXS_0A" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/rydMsMCGZG5F-F-LpXS_0A</a></p>
<h2 id="_2-​基于ssm-layui开发汽车租赁管理系统" tabindex="-1"> 2. ​基于ssm+layui开发汽车租赁管理系统</h2>
<p>项目地址：<a href="https://mp.weixin.qq.com/s/zeKL8Ki9pvM3Yw9SwM7mug" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/zeKL8Ki9pvM3Yw9SwM7mug</a></p>
<h2 id="_3-基于spring-boot2的个人博客系统" tabindex="-1"> 3. 基于spring boot2的个人博客系统</h2>
<p>项目地址：<a href="https://mp.weixin.qq.com/s/WybspWYfy4SjhQrl71No5g" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/WybspWYfy4SjhQrl71No5g</a></p>
<h2 id="_4-16k点赞-基于spring-vue的前后端分离管理系统eladmin-真香" tabindex="-1"> 4. 16K点赞 基于Spring + Vue的前后端分离管理系统ELAdmin，真香</h2>
<p>项目地址：<a href="https://mp.weixin.qq.com/s/xW6H7Zv06jQYPbFPzHmcsw" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/xW6H7Zv06jQYPbFPzHmcsw</a></p>
<h2 id="_5-spring-boot-security-mybatis-thymeleaf-activiti-快速开发平台项目" tabindex="-1"> 5. Spring Boot + Security + MyBatis + Thymeleaf + Activiti 快速开发平台项目</h2>
<p>项目地址：<a href="https://mp.weixin.qq.com/s/2ER31ZqgakXM6HjHI7-ckg" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/2ER31ZqgakXM6HjHI7-ckg</a></p>
<h2 id="_6-一款基于-spring-boot-的现代化社区-论坛-问答-社交网络-博客" tabindex="-1"> 6. 一款基于 Spring Boot 的现代化社区（论坛/问答/社交网络/博客）</h2>
<p>项目地址：<a href="https://mp.weixin.qq.com/s/iyaD_KL-QCmhkhdNgPcQlg" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/iyaD_KL-QCmhkhdNgPcQlg</a></p>
<p><strong>未完待续...</strong></p>
<p>公众号二维码</p>
<p><img src="/accounts/wechat.jpg" alt="" loading="lazy"></p>
<p>个人微信</p>
<p><img src="/accounts/QRcode.jpg" alt="" loading="lazy"></p>
]]></content:encoded>
      <enclosure url="https://tva2.sinaimg.cn/large/007F3CC8ly1h1l2mnl7y0j30oq09h76p.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>币</title>
      <link>https://dearlocation.com/posts/btc/btc-01.html</link>
      <guid>https://dearlocation.com/posts/btc/btc-01.html</guid>
      <source url="https://dearlocation.com/rss.xml">币</source>
      <description>bi
</description>
      <category>币</category>
      <pubDate>Sat, 21 May 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>bi</p>

<p>俩万后台管理系统免费开源，</p>
<p>预览地址：<a href="http://liawan.javapub.net.cn/" target="_blank" rel="noopener noreferrer">http://liawan.javapub.net.cn/</a>
开源地址：<a href="https://gitee.com/yangchunjian/liawan-vue" target="_blank" rel="noopener noreferrer">https://gitee.com/yangchunjian/liawan-vue</a></p>
<hr>
<h2 id="比特币" tabindex="-1"> 比特币</h2>
<p>加密货币是当前全世界最受争议的事件之一，它的实现原理决定了对法币造成的挑战。</p>
<p>从2009年1月3日中本聪生成第一枚比特币开始，比特币就开始书写它的传奇。</p>
<p><img src="https://tvax2.sinaimg.cn/large/007F3CC8ly1h2fphd7mlnj30ni0na0yk.jpg" alt="image" loading="lazy"></p>
<p>这是截至发稿时BTC的周线图，最近几年局势比较动荡，俄乌冲突、朝核危机、塔利班、Corona Virus Disease 2019，COVID-19 间接导致的全球经济，为了使自己的资本保值、不被印钞机稀释掉，也就催化了加密货币的生长。</p>
<p>除了BTC，还有以太坊 ETH、狗币 DOGE、FIL及最近最火的LUNA/USDT。最听说有人挣得钵满彭满、开着高杠杆</p>
<h2 id="luna" tabindex="-1"> LUNA</h2>
<p>最近就算没接触炒币的胖友们也一定听说露娜LUNA/USDT币，造富神话。</p>
<p><img src="https://tvax1.sinaimg.cn/large/007F3CC8ly1h2fq399nahj316e085wjx.jpg" alt="image" loading="lazy"></p>
]]></content:encoded>
      <enclosure url="https://tvax2.sinaimg.cn/large/007F3CC8ly1h2fphd7mlnj30ni0na0yk.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>IDEA 破解【稳定】【更新】（永久更新）</title>
      <link>https://dearlocation.com/posts/idea/idea-crack.html</link>
      <guid>https://dearlocation.com/posts/idea/idea-crack.html</guid>
      <source url="https://dearlocation.com/rss.xml">IDEA 破解【稳定】【更新】（永久更新）</source>
      <description>亲测2019、2020、2021、2022版本可用
</description>
      <category>idea</category>
      <pubDate>Sun, 15 May 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>亲测2019、2020、2021、2022版本可用</p>

<p>[toc]</p>
<blockquote>
<p>初次访问：反爬虫，激活码已被保护</p>
</blockquote>
<h2 id="说明" tabindex="-1"> 说明</h2>
<p>2018.2~2022版本用这个，下面激活码直接复制粘贴到activation code即可激活软件，如果是新的版本，换新激活码的时候code with me也要激活一次</p>
<p><img src="https://tvax1.sinaimg.cn/large/007F3CC8ly1h29hbpt2d9j307306y757.jpg" alt="image" loading="lazy"></p>
<blockquote>
<p>微信扫一扫，获取，验证码</p>
<p>微信扫一扫，回复“验证码”，获取网页验证码</p>
</blockquote>
<p>激活后如果显示key is invalid，这是因为你破解过软件的原因，请按如下操作</p>
<ol>
<li>打开软件，</li>
<li>help edit VM options，</li>
<li>删掉最下面一行的javaagent，重启软件即可</li>
</ol>
<h2 id="注意" tabindex="-1"> 注意：</h2>
<p>（如果是较新的版本Intellij IDEA和Code with me都要激活一次）</p>
<h2 id="必读" tabindex="-1"> 必读</h2>
<p>激活码过了一段时间会失效，到时候怎么办？</p>
<p>jetBrains 官方会不定时封号，但是本站激活码即时更新，如果失效可以到公众号发送“激活码”获取最新更新的激活码</p>
]]></content:encoded>
      <enclosure url="https://tvax1.sinaimg.cn/large/007F3CC8ly1h29hbpt2d9j307306y757.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>mysql主从搭建</title>
      <link>https://dearlocation.com/posts/mysql/mysql-master-slave.html</link>
      <guid>https://dearlocation.com/posts/mysql/mysql-master-slave.html</guid>
      <source url="https://dearlocation.com/rss.xml">mysql主从搭建</source>
      <description>基于linux搭建mysql主从服务器，单机搭建
</description>
      <category>mysql</category>
      <pubDate>Wed, 27 Apr 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>基于linux搭建mysql主从服务器，单机搭建</p>

<p>[toc]</p>
<h2 id="下载" tabindex="-1"> 下载</h2>
<blockquote>
<p>wget wget <a href="https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.32-el7-x86_64.tar.gz" target="_blank" rel="noopener noreferrer">https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.32-el7-x86_64.tar.gz</a></p>
</blockquote>
<h2 id="创建多实例配置目录" tabindex="-1"> 创建多实例配置目录</h2>
<div><pre><code><span>#为每个实例创建单独的文件，以便存放对应的数据文件、日志文件、临时文件</span>
<span>mkdir</span> -p /mnt/databases/mysql/<span>{</span>mysql_3306,mysql_3307<span>}</span>
<span>mkdir</span> /mnt/databases/mysql/mysql_3306/<span>{</span>data,log,tmp<span>}</span>
<span>mkdir</span> /mnt/databases/mysql/mysql_3307/<span>{</span>data,log,tmp<span>}</span>

<span>#更改目录权限</span>
<span>chown</span> -R mysql-admin:mysql /mnt/databases/mysql/ 
<span>chown</span> -R mysql-admin:mysql /usr/local/mysql/

<span>#添加环境变量</span>
<span>echo</span> <span>'export PATH=$PATH:/usr/local/mysql/bin'</span> <span>>></span>  /etc/profile 
<span>source</span> /etc/profile 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="配置my-cnf" tabindex="-1"> 配置my.cnf</h2>
<blockquote>
<p>vim /usr/local/mysql/support-files/my.cnf</p>
</blockquote>
<div><pre><code><span>[</span>client<span>]</span>
<span>port</span><span>=</span><span>3306</span>
<span>socket</span><span>=</span>/tmp/mysql.sock

<span>[</span>mysqld_multi<span>]</span>
<span>mysqld</span><span>=</span>/usr/local/mysql/bin/mysqld_safe
<span>mysqladmin</span><span>=</span>/usr/local/mysql/bin/mysqladmin
<span>log</span><span>=</span>/mnt/databases/mysql/mysqld_multi.log

<span>[</span>mysqld<span>]</span>
<span>user</span><span>=</span>mysql-admin
<span>basedir</span><span>=</span>/usr/local/mysql
<span>sql_mode</span><span>=</span>NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES

<span>[</span>mysqld3306<span>]</span>
<span>mysqld</span><span>=</span>mysqld
<span>mysqladmin</span><span>=</span>mysqladmin
<span>datadir</span><span>=</span>/mnt/databases/mysql/mysql_3306/data
<span>port</span><span>=</span><span>3306</span>
<span>server_id</span><span>=</span><span>3306</span>
<span>socket</span><span>=</span>/tmp/mysql_3306.sock
log-output<span>=</span>file
<span>slow_query_log</span><span>=</span><span>1</span>
<span>long_query_time</span><span>=</span><span>1</span>
<span>slow_query_log_file</span><span>=</span>/mnt/databases/mysql/mysql_3306/log/slow.log
log-error<span>=</span>/mnt/databases/mysql/mysql_3306/log/error.log
<span>binlog_format</span><span>=</span>mixed
log-bin<span>=</span>/mnt/databases/mysql/mysql_3306/log/mysql3306_bin

<span>[</span>mysqld3307<span>]</span>
<span>mysqld</span><span>=</span>mysqld
<span>mysqladmin</span><span>=</span>mysqladmin
<span>datadir</span><span>=</span>/mnt/databases/mysql/mysql_3307/data
<span>port</span><span>=</span><span>3307</span>
<span>server_id</span><span>=</span><span>3307</span>
<span>socket</span><span>=</span>/tmp/mysql_3307.sock
log-output<span>=</span>file
<span>slow_query_log</span><span>=</span><span>1</span>
<span>long_query_time</span><span>=</span><span>1</span>
<span>slow_query_log_file</span><span>=</span>/mnt/databases/mysql/mysql_3307/log/slow.log
log-error<span>=</span>/mnt/databases/mysql/mysql_3307/log/error.log
<span>binlog_format</span><span>=</span>mixed
log-bin<span>=</span>/mnt/databases/mysql/mysql_3307/log/mysql3307_bin
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>cp /usr/local/mysql/support-files/my.cnf /etc/my.cnf</p>
</blockquote>
<h2 id="初始化数据库" tabindex="-1"> 初始化数据库</h2>
<div><pre><code><span>#进入到mysql的bin目录下</span>
<span>cd</span> /usr/local/mysql/bin
<span>#执行初始化3306数据库</span>
./mysqld --initialize --user<span>=</span>mysql-admin --basedir<span>=</span>/usr/local/mysql/ --datadir<span>=</span>/mnt/databases/mysql/mysql_3306/data

<span>#初始化3307数据库</span>
./mysqld --initialize --user<span>=</span>mysql-admin --basedir<span>=</span>/usr/local/mysql/ --datadir<span>=</span>/mnt/databases/mysql/mysql_3307/data
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="管理多实例" tabindex="-1"> 管理多实例</h2>
<div><pre><code><span>#启动全部实例：</span>
/usr/local/mysql/bin/mysqld_multi start

<span>#查看全部实例状态：</span>
/usr/local/mysql/bin/mysqld_multi report 

<span>#启动单个实例：</span>
/usr/local/mysql/bin/mysqld_multi start <span>3306</span> 

<span>#停止单个实例：</span>
/usr/local/mysql/bin/mysqld_multi stop <span>3306</span> 

<span>#查看单个实例状态：</span>
/usr/local/mysql/bin/mysqld_multi report <span>3306</span> 

<span>#停止实例命令失效时，使用如下命令：</span>
mysqladmin -u root -p -S /tmp/mysql_3306.sock <span>shutdown</span>
Enter password:

<span>#查看启动进程</span>
<span>netstat</span> -tlnap <span>|</span> <span>grep</span> mysql
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="修改临时密码" tabindex="-1"> 修改临时密码</h2>
<div><pre><code><span>#逐一登录mysql，输入临时密码登录；</span>
mysql -S /tmp/mysql_3306.sock -p
Enter password:
<span>#设置新密码</span>
<span>set</span> password <span>for</span> root@<span>'localhost'</span><span>=</span>password<span>(</span><span>'123456'</span><span>)</span><span>;</span> 
flush privileges<span>;</span> 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><hr>
<hr>
<h2 id="主从" tabindex="-1"> 主从</h2>
<h3 id="配置修改" tabindex="-1"> 配置修改</h3>
<div><pre><code><span>#打开配置文件my.cnf</span>
<span>vim</span> /usr/local/mysql/support-files/my.cnf
<span>#在 主库[mysqld3306] 下增加配置，忽略同步的数据库名称；</span>
binlog-ignore-db<span>=</span>mysql
binlog-ignore-db<span>=</span>performance_schema
binlog-ignore-db<span>=</span>sys
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>重启</p>
<div><pre><code><span>#关闭3306，启动3306；3307没有修改，不需要进行重启；</span>
mysqladmin -u root -p -S /tmp/mysql_3306.sock <span>shutdown</span>
mysqld_multi start <span>3306</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h3 id="授权" tabindex="-1"> 授权</h3>
<p>主库</p>
<div><pre><code>grant replication slave on *.* to <span>'root'</span>@<span>'127.0.0.1'</span> identified by <span>'123456'</span><span>;</span>
<span>#授权后需要刷新后，才能生效；</span>
flush privileges<span>;</span> 
<span>#查看主库授权状态</span>
show master status<span>;</span> 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="https://tva1.sinaimg.cn/large/007F3CC8ly1h1oaj3c3y7j30nr0nx7pp.jpg" alt="image" loading="lazy"></p>
<p>从库</p>
<div><pre><code><span>#注意：从库的几个参数一定要和主库的保持一致</span>
change master to <span>master_host</span><span>=</span><span>'127.0.0.1'</span>,master_user<span>=</span><span>'root'</span>,master_password<span>=</span><span>'123456'</span>,master_log_file<span>=</span><span>'mysql3306-bin.000006'</span>,master_log_pos<span>=</span><span>597</span><span>;</span>
<span>#启动主从拷贝</span>
start slave<span>;</span> 
<span>#查看拷贝状态</span>
show slave status<span>;</span>
 <span>#清除授权，授权信息也被清除掉</span>
reset slave all<span>;</span>
<span>#查看状态</span>
show slave status <span>\</span>G
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>检验</strong></p>
<div><pre><code>Slave_IO_Running: Yes
Slave_SQL_Running: Yes
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="附加" tabindex="-1"> 附加</h2>
<p>建立从库只读账户</p>
<div><pre><code>GRANT SElECT ON *.* TO <span>'root_readonly'</span>@<span>'%'</span> IDENTIFIED BY <span>"123456"</span><span>;</span>
<span>#执行刷新，刷新后；</span>
flush privileges<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div>]]></content:encoded>
      <enclosure url="https://tva1.sinaimg.cn/large/007F3CC8ly1h1oaj3c3y7j30nr0nx7pp.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>nacos安装-Windows</title>
      <link>https://dearlocation.com/posts/nacos/nacos-install-windows.html</link>
      <guid>https://dearlocation.com/posts/nacos/nacos-install-windows.html</guid>
      <source url="https://dearlocation.com/rss.xml">nacos安装-Windows</source>
      <description>nacos下载安装教程-windows
</description>
      <category>nacos</category>
      <pubDate>Wed, 01 Jun 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>nacos下载安装教程-windows</p>

<ol>
<li>打开Nacos官网</li>
</ol>
<blockquote>
<p><a href="https://nacos.io/zh-cn/" target="_blank" rel="noopener noreferrer">https://nacos.io/zh-cn/</a></p>
</blockquote>
<p><img src="https://tvax1.sinaimg.cn/large/007F3CC8ly1h2suwhm5fyj31gy0qz4bu.jpg" alt="image" loading="lazy"></p>
<ol start="2">
<li>进入GitHub，点击Tags</li>
</ol>
<p><code>如果打不开Github，直接看最后一条</code></p>
<p><img src="https://tvax1.sinaimg.cn/large/007F3CC8ly1h2suxqciqhj31gb0ruh5o.jpg" alt="image" loading="lazy"></p>
<ol start="3">
<li>点击Releases，下滑到需要的版本</li>
</ol>
<p><img src="https://tvax1.sinaimg.cn/large/007F3CC8ly1h2sv0rjjbrj31gv0ruwua.jpg" alt="image" loading="lazy"></p>
<ol start="4">
<li>下载解压后，得到目录</li>
</ol>
<p><img src="https://tvax4.sinaimg.cn/large/007F3CC8ly1h2sv1jejztj30l8089gnp.jpg" alt="image" loading="lazy"></p>
<ol start="5">
<li>修改配置</li>
</ol>
<p><code>有些特殊情况会出现异常，建议按照如下配置</code></p>
<blockquote>
<p>以notepad++方式打开startup.cmd
然后修改大概在26行的set MODE=&quot;cluster&quot;为set MODE=&quot;standalone&quot;</p>
</blockquote>
<p><img src="https://tva2.sinaimg.cn/large/007F3CC8ly1h2sv40n17ej31hc0qekdd.jpg" alt="image" loading="lazy"></p>
<ol start="6">
<li>启动</li>
</ol>
<p>进入 bin 目录，双击 startup.cmd 运行</p>
<p><img src="https://tva1.sinaimg.cn/large/007F3CC8ly1h2sv2n5h24j31hn0sn7wh.jpg" alt="image" loading="lazy"></p>
<hr>
<p>如果无法访问Github，移驾如下地址下载or给博主留言免费下载：<a href="https://download.csdn.net/download/qq_40374604/14894556" target="_blank" rel="noopener noreferrer">https://download.csdn.net/download/qq_40374604/14894556</a></p>
]]></content:encoded>
      <enclosure url="https://tvax1.sinaimg.cn/large/007F3CC8ly1h2suwhm5fyj31gy0qz4bu.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>python 安装 cv2 - 已解决</title>
      <link>https://dearlocation.com/posts/python/python-cv2-install.html</link>
      <guid>https://dearlocation.com/posts/python/python-cv2-install.html</guid>
      <source url="https://dearlocation.com/rss.xml">python 安装 cv2 - 已解决</source>
      <description>python 安装 cv2 - 已解决
</description>
      <category>python</category>
      <pubDate>Sun, 24 Apr 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>python 安装 cv2 - 已解决</p>

<p>python 安装 cv2 - 已解决</p>
<p><code>建议收藏</code></p>
<p>提供多种操作，一定有一种适合你的</p>
<p>@[toc]</p>
<p>情况就这么个情况，就是装不上。本文没一句废话，仔细阅读。</p>
<p><img src="https://tva2.sinaimg.cn/large/007F3CC8ly1h1ky1xzxiij30rl0efqem.jpg" alt="image" loading="lazy"></p>
<h2 id="_1-传统方式1" tabindex="-1"> 1. 传统方式1</h2>
<p>（执行一遍，一条条试）</p>
<blockquote>
<p>可尝试 python3 -m pip install --upgrade pip</p>
</blockquote>
<blockquote>
<p>pip install cv2</p>
</blockquote>
<blockquote>
<p>pip3 install opencv-python</p>
</blockquote>
<p>国内镜像</p>
<blockquote>
<p>pip3 install opencv-python  -i <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener noreferrer">http://pypi.mirrors.ustc.edu.cn/simple/</a></p>
</blockquote>
<blockquote>
<p>pip install cv2 -i <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener noreferrer">http://pypi.mirrors.ustc.edu.cn/simple/</a></p>
</blockquote>
<p>进度：</p>
<p><img src="https://tva3.sinaimg.cn/large/007F3CC8ly1h1ky2lreabj315c0lkdyk.jpg" alt="image" loading="lazy"></p>
<hr>
<h2 id="_2-第一阶段-终极办法01" tabindex="-1"> 2. 第一阶段 终极办法01</h2>
<p>切换 python 版本， python3.9 不支持 cv2 (python3.7及以下)</p>
<hr>
<h2 id="_3-第二阶段-终极办法02" tabindex="-1"> 3. 第二阶段 终极办法02</h2>
<p>自己安装</p>
<p><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud" target="_blank" rel="noopener noreferrer">https://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud</a></p>
<p><img src="https://tva4.sinaimg.cn/large/007F3CC8ly1h1ky2v4l1cj31hc0lq4k1.jpg" alt="image" loading="lazy"></p>
<p>等待下载好，copy到python安装目录下的lib目录当中</p>
<p>接着，在cmd中安装（先进入lib目录中再安装你下载的那个文件）</p>
<div><pre><code>pip <span>install</span> opencv_python‑2.4.13.7‑cp27‑cp27m‑win_amd64.whl
</code></pre><div aria-hidden="true"><div></div></div></div><p>等待安装好，验证一下。</p>
<div><pre><code>pip <span>install</span> numpy
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="附加" tabindex="-1"> 附加</h2>
<p><img src="https://tva1.sinaimg.cn/large/007F3CC8ly1h1ky36j7ztj30l208i79e.jpg" alt="image" loading="lazy"></p>
<p>下载：</p>
<p>如果是以上错误，你可能需要安装 OpenSSL。<a href="http://slproweb.com/products/Win32OpenSSL.html" target="_blank" rel="noopener noreferrer">http://slproweb.com/products/Win32OpenSSL.html</a></p>
<p><img src="https://tvax4.sinaimg.cn/large/007F3CC8ly1h1ky3c790uj31e50qknlm.jpg" alt="image" loading="lazy"></p>
<p>安装：</p>
<p>一直下一步</p>
<p>配置环境变量</p>
]]></content:encoded>
      <enclosure url="https://tva2.sinaimg.cn/large/007F3CC8ly1h1ky1xzxiij30rl0efqem.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>rodert单排学习redis入门【黑铁】</title>
      <link>https://dearlocation.com/posts/redis/learn-redis-01.html</link>
      <guid>https://dearlocation.com/posts/redis/learn-redis-01.html</guid>
      <source url="https://dearlocation.com/rss.xml">rodert单排学习redis入门【黑铁】</source>
      <description>rodert单排学习redis入门【黑铁】
</description>
      <category>redis</category>
      <pubDate>Mon, 25 Apr 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>rodert单排学习redis入门【黑铁】</p>

<p>redis入门</p>
<blockquote>
<p>欢迎大家前来白嫖PDF。下图回复：666</p>
</blockquote>
<blockquote>
<p>本教程致力于最实用教程，个别图片粘贴有丢失，还有来领取原版。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200613232629668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>@[toc]</p>
<h2 id="前言" tabindex="-1"> 前言</h2>
<blockquote>
<p>声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。</p>
</blockquote>
<blockquote>
<p>本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。
欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：DearLocation</p>
</blockquote>
<blockquote>
<p>有任何问题都可以来谈谈 ！</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200613232439488.jpg" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>本篇主要是 Redis 的入门，涉及一些基础命令和常见场景。</p>
</blockquote>
<blockquote>
<p>redis是目前最热的缓存组件之一，如果你还不懂，那就开始，入门到实战</p>
</blockquote>
<blockquote>
<p>本文主要是 <strong><span color=#159957 face="黑体">Redis</span></strong> 入门知识，介绍 Redis 特性、使用场景、安装和数据类型。</p>
</blockquote>
<blockquote>
<p>中文官网：<a href="http://www.redis.cn/" target="_blank" rel="noopener noreferrer">http://www.redis.cn/</a></p>
</blockquote>
<h2 id="_1-nosql-not-only-sql" tabindex="-1"> 1.NoSql(not only sql)</h2>
<p>指非关系型数据库，不支持sql语句，nosql中存储的数据是KV形式</p>
<p>常见的NoSQL产品有：Mongodb、Redis、Hbase hadoop、Cassandra hadoop。</p>
<h2 id="_2-redis入门" tabindex="-1"> 2.Redis入门</h2>
<blockquote>
<p>这是一些redis介绍，做一些简单了解即可。</p>
</blockquote>
<p><strong><span color=#159957 face="黑体">Redis</span></strong>（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，<strong><span color=#159957 face="黑体">Redis</span></strong> 的开发由Pivotal赞助。</p>
<p>redis 是一个 <strong><span color=#159957 face="黑体">key-value</span></strong> 存储系统。和 Memcached 类似，它支持存储的 value 类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，<strong><span color=#159957 face="黑体">Redis</span></strong> 支持各种不同方式的排序。与 <strong><span color=#159957 face="黑体">memcached</span></strong> 一样，为了保证效率，数据都是缓存在内存中。区别的是 <strong><span color=#159957 face="黑体">Redis</span></strong> 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 <strong><span color=#159957 face="黑体">master-slave</span></strong>(主从)同步。</p>
<p><strong><span color=#159957 face="黑体">Redis</span></strong> 是一个高性能的key-value数据库。 <strong><span color=#159957 face="黑体">Redis</span></strong> 的出现，很大程度补偿了**<span color=#159957 face="黑体">memcached</span>**这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。
<strong><span color=#159957 face="黑体">Redis</span></strong> 支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得 <strong><span color=#159957 face="黑体">Redis</span></strong> 可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</p>
<p><strong><span color=#159957 face="黑体">Redis</span></strong> 的官网地址，非常好记，<a href="http://xn--redis-qr1k.io" target="_blank" rel="noopener noreferrer">是redis.io</a>。（域名后缀io属于国家域名，是british Indian Ocean territory，即英属印度洋领地），Vmware在资助着 <strong><span color=#159957 face="黑体">Redis</span></strong> 项目的开发和维护。</p>
<h2 id="_3-redis特性" tabindex="-1"> 3.Redis特性</h2>
<h3 id="_3-1-性能" tabindex="-1"> 3.1.性能</h3>
<p>下面是官方的bench-mark数据：
测试完成了 50 个并发执行 100000 个请求。
设置和获取的值是一个 256 字节字符串。
Linux box 是运行 Linux 2.6 , 这是 X3320 Xeon 2.5 ghz。
文本执行使用 loopback 接口(127.0.0.1)。
结果:读的速度是 <strong>110000次/s</strong> ,写的速度是 <strong>81000次/s</strong> 。</p>
<h3 id="_3-2-特性" tabindex="-1"> 3.2.特性</h3>
<ol>
<li>**<span color=#159957 face="黑体">Redis </span>**与其他 <strong><span color=#159957 face="黑体">key-value</span></strong> 缓存产品有以下三个特点：</li>
<li>**<span color=#159957 face="黑体">Redis </span>**支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>**<span color=#159957 face="黑体">Redis </span>**不仅仅支持简单的 **<span color=#159957 face="黑体">key-value</span>**类型的数据，同时还提供 **<span color=#159957 face="黑体">list，set，zset，hash </span>**等数据结构的存储。</li>
<li>**<span color=#159957 face="黑体">Redis </span>**支持数据的备份，即 <strong><span color=#159957 face="黑体">master-slave</span></strong> 模式的数据备份。</li>
</ol>
<h3 id="_3-3-优势" tabindex="-1"> 3.3.优势</h3>
<ul>
<li>性能极高 – **<span color=#159957 face="黑体">Redis </span>**能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型 – **<span color=#159957 face="黑体">Redis </span>**支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子 – **<span color=#159957 face="黑体">Redis </span><strong>的所有操作都是原子性的，同时</strong><span color=#159957 face="黑体">Redis </span>**还支持对几个操作全并后的原子性执行。</li>
<li>丰富的特性 – **<span color=#159957 face="黑体">Redis </span>**还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ul>
<h2 id="_4-redis使用场景" tabindex="-1"> 4.Redis使用场景</h2>
<blockquote>
<p>目前在互联网公司， <strong><span color=#159957 face="黑体">Redis </span></strong> 使用非常广泛，我日常工作中，会用它做爬虫采集系统中队列使用，还有在后台管理系统中做分布式，存储 token 使用。</p>
</blockquote>
<p>1、<strong><span color=#159957 face="黑体">缓存</span></strong></p>
<p>缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。<strong><span color=#159957 face="黑体">Redis </span></strong> 提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在 <strong><span color=#159957 face="黑体">Redis </span></strong> 用在缓存的场合非常多。</p>
<p>2、<strong><span color=#159957 face="黑体">排行榜</span></strong></p>
<p>很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。<strong><span color=#159957 face="黑体">Redis </span></strong> 提供的有序集合数据类构能实现各种复杂的排行榜应用。</p>
<p>3、<strong><span color=#159957 face="黑体">计数器</span></strong></p>
<p>什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。<strong><span color=#159957 face="黑体">Redis </span></strong> 提供的 <strong><span color=#159957 face="黑体">incr</span></strong> 命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。</p>
<p>4、<strong><span color=#159957 face="黑体">分布式会话</span></strong></p>
<p>集群模式下，在应用不多的情况下一般使用容器自带的 session 复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以 Redis 等内存数据库为中心的 session 服务，session 不再由容器管理，而是由 session 服务及内存数据库管理。</p>
<p>5、<strong><span color=#159957 face="黑体">分布式锁</span></strong></p>
<p>在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用 Redis 的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。</p>
<p>6、<strong><span color=#159957 face="黑体">社交网络</span></strong></p>
<p>点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。</p>
<p>7、<strong><span color=#159957 face="黑体">最新列表</span></strong></p>
<p>Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。</p>
<p>8、<strong><span color=#159957 face="黑体">消息系统</span></strong></p>
<p>消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka 等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis 提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。</p>
<h2 id="_5-安装" tabindex="-1"> 5.安装</h2>
<h3 id="_5-1-单机安装" tabindex="-1"> 5.1.单机安装</h3>
<h4 id="_5-1-1-windows下" tabindex="-1"> 5.1.1.windows下</h4>
<p>redis 开源在 github 上</p>
<ul>
<li>下载，解压</li>
</ul>
<blockquote>
<p>下载地址：<a href="https://github.com/tporadowski/redis/releases" target="_blank" rel="noopener noreferrer">https://github.com/tporadowski/redis/releases</a></p>
</blockquote>
<p>Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 <strong>Redis-x64-xxx.zip</strong>压缩包到 C 盘，解压后，将文件夹重新命名为 redis。</p>
<ul>
<li>运行</li>
</ul>
<p>解压后，打开 cmd 窗口，cd 切换到 redis根目录下。</p>
<blockquote>
<p>redis-server.exe redis.windows.conf</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200613232402250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li>客户端连接</li>
</ul>
<p>不要关闭原 cmd 窗口，新打开一个 cmd 窗口，切换到 redis 根目录</p>
<blockquote>
<p>redis-cli.exe -h 127.0.0.1 -p 6379</p>
</blockquote>
<p>6379 是 redis 默认端口，我们可以在配置中修改</p>
<ul>
<li>测试</li>
</ul>
<p>设置 key 值</p>
<blockquote>
<p>set myKey abc</p>
</blockquote>
<p>取出 key 值</p>
<blockquote>
<p>get myKey</p>
</blockquote>
<h4 id="_5-1-2-linux下" tabindex="-1"> 5.1.2.linux下</h4>
<blockquote>
<p>linux 和 windows 下类似，启动方式参考上文</p>
</blockquote>
<div><pre><code>$ <span>wget</span> http://download.redis.io/releases/redis-2.8.17.tar.gz
$ <span>tar</span> xzf redis-2.8.17.tar.gz
$ <span>cd</span> redis-2.8.17
$ <span>make</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="_6-五类数据结构" tabindex="-1"> 6.五类数据结构</h2>
<h3 id="_6-0-说明" tabindex="-1"> 6.0.说明</h3>
<blockquote>
<p>类型中会涉及到很多的 Redis 操作命令，一定耐心看完，优化的基础是要了解。</p>
</blockquote>
<h3 id="_6-1-介绍" tabindex="-1"> 6.1.介绍</h3>
<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p>
<blockquote>
<p>redis是非常优秀的缓存工具，熟练使用redis，可以让我们的开发进一步。</p>
</blockquote>
<p>对于下面操作，可以通过 redis-cli 工具连接使用</p>
<h3 id="_6-2-redis-keys" tabindex="-1"> 6.2.Redis keys</h3>
<blockquote>
<p>关于key的几条规则，一定不要以为它们不重要，了解一些对你排查问题至关重要。</p>
</blockquote>
<p>Redis <strong>key</strong> 值是二进制安全的，这意味着可以用任何二进制序列作为key值，从形如”foo”的简单字符串到一个 JPEG 文件的内容都可以。空字符串也是有效 key 值。</p>
<p>关于key的几条规则：</p>
<ul>
<li>太长的键值不是个好主意，例如1024字节的键值就不是个好主意，不仅因为消耗内存，而且在数据中查找这类键值的计算成本很高。</li>
<li>太短的键值通常也不是好主意，如果你要用”u:1000:pwd”来代替”user:1000:password”，这没有什么问题，但后者更易阅读，并且由此增加的空间消耗相对于**<span color=#159957 face="黑体">key object</span><strong>和</strong><span color=#159957 face="黑体">value object</span>**本身来说很小。当然，没人阻止您一定要用更短的键值节省一丁点儿空间。</li>
<li>最好坚持一种模式。例如：”object-type:uid:field”就是个不错的注意，像这样”user:1000:password”。我喜欢对多单词的字段名中加上一个点，就像这样：”comment:q1234:reply.to”。</li>
</ul>
<h3 id="_6-2-字符串-strings" tabindex="-1"> 6.2.字符串（strings）</h3>
<blockquote>
<p>二进制安全的字符串</p>
</blockquote>
<p>字符串方式是redis最简单的数据类型，redis就像一个可以持久化的memcached服务器。</p>
<ul>
<li>基本的操作方式**<span color=#159957 face="黑体">get 和 set </span>**方式</li>
</ul>
<div><pre><code><span>></span> <span>set</span> mykey somevalue
OK
<span>></span> get mykey
<span>"somevalue"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>例如：当key存在时，set会失败。值的长度不能超过512MB。</p>
<ul>
<li>一个有趣的操作，<strong>原子</strong>递增，</li>
</ul>
<div><pre><code><span>></span> <span>set</span> counter <span>100</span>
OK
<span>></span> incr counter
<span>(</span>integer<span>)</span> <span>101</span>
<span>></span> incr counter
<span>(</span>integer<span>)</span> <span>102</span>
<span>></span> incrby counter <span>50</span>
<span>(</span>integer<span>)</span> <span>152</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong><span color=#159957 face="黑体">INCR </span></strong> 命令将字符串解析成整型，将其加一，再将结果保存成新的字符串，类似的命令还有 <strong><span color=#159957 face="黑体">INCRBY</span></strong> , <strong><span color=#159957 face="黑体">DECR</span></strong> 和 <strong><span color=#159957 face="黑体">DECRBY</span></strong> 。</p>
<p>还有一个有趣的命令， <strong><span color=#159957 face="黑体">GETSET</span></strong>  命令：设置新值，返回原值。这个操作有什么用？在我们需要保证原子性操作时</p>
<p>MSET 和 MGET 是批量操作</p>
<div><pre><code><span>></span> mset a <span>10</span> b <span>20</span> c <span>30</span>
OK
<span>></span> mget a b c
<span>1</span><span>)</span> <span>"10"</span>
<span>2</span><span>)</span> <span>"20"</span>
<span>3</span><span>)</span> <span>"30"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong><span color=#159957 face="黑体">MGET</span></strong> 命令返回由值组成的数组。</p>
<ul>
<li>修改和查询存在操作</li>
</ul>
<blockquote>
<p><strong><span color=#159957 face="黑体">exists</span></strong>:判断键是否存在，<strong><span color=#159957 face="黑体">del</span></strong>：删除指定键</p>
</blockquote>
<div><pre><code><span>></span> <span>set</span> mykey hello
OK
<span>></span> exists mykey
<span>(</span>integer<span>)</span> <span>1</span>
<span>></span> del mykey
<span>(</span>integer<span>)</span> <span>1</span>
<span>></span> exists mykey
<span>(</span>integer<span>)</span> <span>0</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p><strong><span color=#159957 face="黑体">TYPE</span></strong> 命令返回key对应的存储类型</p>
</blockquote>
<div><pre><code><span>></span> <span>set</span> mykey x
OK
<span>></span> <span>type</span> mykey
string
<span>></span> del mykey
<span>(</span>integer<span>)</span> <span>1</span>
<span>></span> <span>type</span> mykey
none
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>Redis超时</li>
</ul>
<p>对 <strong>key</strong> 设置**<span color=#159957 face="黑体">超时</span>**。精度可以使用毫秒或秒。</p>
<div><pre><code><span>></span> <span>set</span> key some-value
OK
<span>></span> expire key <span>5</span>
<span>(</span>integer<span>)</span> <span>1</span>
<span>></span> get key <span>(</span>immediately<span>)</span>
<span>"some-value"</span>
<span>></span> get key <span>(</span>after some <span>time</span><span>)</span>
<span>(</span>nil<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>使用了 <strong><span color=#159957 face="黑体">EXPIRE</span></strong> 来设置超时时间(也可以再次调用这个命令来改变超时时间，使用 <strong><span color=#159957 face="黑体">PERSIST</span></strong> 命令去除超时时间 )。我们也可以在创建值的时候设置超时时间:</p>
<div><pre><code><span>></span> <span>set</span> key <span>100</span> ex <span>10</span>
OK
<span>></span> ttl key
<span>(</span>integer<span>)</span> <span>9</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><strong><span color=#159957 face="黑体">TTL</span></strong> 命令用来查看key对应的值剩余存活时间。</p>
<h3 id="_6-3-列表-lists" tabindex="-1"> 6.3.列表（Lists）</h3>
<blockquote>
<p>值得注意的：<strong><span color=#159957 face="黑体">Redis lists</span></strong> 基于 <strong><span color=#159957 face="黑体">Linked Lists</span></strong> 实现。</p>
</blockquote>
<p>**<span color=#159957 face="黑体">Redis 列表</span>**是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p>
<ul>
<li>Redis Lists 入门</li>
</ul>
<div><pre><code><span>></span> rpush mylist A
<span>(</span>integer<span>)</span> <span>1</span>
<span>></span> rpush mylist B
<span>(</span>integer<span>)</span> <span>2</span>
<span>></span> lpush mylist first
<span>(</span>integer<span>)</span> <span>3</span>
<span>></span> lrange mylist <span>0</span> -1
<span>1</span><span>)</span> <span>"first"</span>
<span>2</span><span>)</span> <span>"A"</span>
<span>3</span><span>)</span> <span>"B"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>从右边(尾部)插入俩个元素，左边(头部)插入一个元素，**<span color=#159957 face="黑体">LRANGE </span>**打印所有(0,-1)元素。</p>
<ul>
<li>**<span color=#159957 face="黑体">Redis Lists</span>**常用指令</li>
</ul>
<blockquote>
<p>BLPOP key1 [key2 ] timeout
移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>
</blockquote>
<blockquote>
<p>BRPOP key1 [key2 ] timeout
移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>
</blockquote>
<blockquote>
<p>BRPOPLPUSH source destination timeout
从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>
</blockquote>
<blockquote>
<p>LINDEX key index
通过索引获取列表中的元素</p>
</blockquote>
<blockquote>
<p>LINSERT key BEFORE|AFTER pivot value
在列表的元素前或者后插入元素</p>
</blockquote>
<p>说明：<strong><span color=#159957 face="黑体">Redis Linsert</span></strong> 命令用于在列表的元素前或者后插入元素。当指定元素不存在于列表中时，不执行任何操作。当列表不存在时，被视为空列表，不执行任何操作。如果 key 不是列表类型，返回一个错误。</p>
<p><strong>实例：</strong></p>
<div><pre><code>redis<span>></span> RPUSH mylist <span>"Hello"</span>
<span>(</span>integer<span>)</span> <span>1</span>
redis<span>></span> RPUSH mylist <span>"World"</span>
<span>(</span>integer<span>)</span> <span>2</span>
redis<span>></span> LINSERT mylist BEFORE <span>"World"</span> <span>"There"</span>
<span>(</span>integer<span>)</span> <span>3</span>
redis<span>></span> LRANGE mylist <span>0</span> -1
<span>1</span><span>)</span> <span>"Hello"</span>
<span>2</span><span>)</span> <span>"There"</span>
<span>3</span><span>)</span> <span>"World"</span>
redis<span>></span> 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>LLEN key
获取列表长度</p>
</blockquote>
<blockquote>
<p>LPOP key
移出并获取列表的第一个元素</p>
</blockquote>
<blockquote>
<p>LPUSH key value1 [value2]
将一个或多个值插入到列表头部</p>
</blockquote>
<blockquote>
<p>LPUSHX key value
将一个值插入到<strong>已存在</strong>的列表头部</p>
</blockquote>
<blockquote>
<p>LRANGE key start stop
获取列表指定范围内的元素</p>
</blockquote>
<blockquote>
<p>LREM key count value
移除列表元素</p>
</blockquote>
<div><pre><code>count > 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。
count &lt; 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值。
count = 0 : 移除表中所有与 VALUE 相等的值。
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><blockquote>
<p>LSET key index value
通过索引设置列表元素的值</p>
</blockquote>
<blockquote>
<p>LTRIM key start stop
对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p>
</blockquote>
<div><pre><code>注意：下标从0开始
</code></pre><div aria-hidden="true"><div></div></div></div><blockquote>
<p>RPOP key
移除列表的最后一个元素，返回值为移除的元素。</p>
</blockquote>
<blockquote>
<p>RPOPLPUSH source destination
移除列表的最后一个元素，并将该元素添加到另一个列表并返回。</p>
</blockquote>
<blockquote>
<p>RPUSH key value1 [value2]
在列表中添加一个或多个值</p>
</blockquote>
<blockquote>
<p>RPUSHX key value
为已存在的列表添加值</p>
</blockquote>
<h3 id="_6-4-哈希-hash" tabindex="-1"> 6.4.哈希(Hash)</h3>
<blockquote>
<p><strong><span color=#159957 face="黑体">Redis hash </span></strong> 是一个 <strong><span color=#159957 face="黑体">string </span><strong>类型的 <strong><span color=#159957 face="黑体">field </span></strong> 和 <strong><span color=#159957 face="黑体">value </span></strong> 的映射表，</strong><span color=#159957 face="黑体">hash </span></strong> 特别适合用于存储对象。</p>
</blockquote>
<p>Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。</p>
<div><pre><code>序号	命令及描述
1	HDEL key field1 [field2] 
删除一个或多个哈希表字段
2	HEXISTS key field 
查看哈希表 key 中，指定的字段是否存在。
3	HGET key field 
获取存储在哈希表中指定字段的值。
4	HGETALL key 
获取在哈希表中指定 key 的所有字段和值
5	HINCRBY key field increment 
为哈希表 key 中的指定字段的整数值加上增量 increment 。
6	HINCRBYFLOAT key field increment 
为哈希表 key 中的指定字段的浮点数值加上增量 increment 。
7	HKEYS key 
获取所有哈希表中的字段
8	HLEN key 
获取哈希表中字段的数量
9	HMGET key field1 [field2] 
获取所有给定字段的值
10	HMSET key field1 value1 [field2 value2 ] 
同时将多个 field-value (域-值)对设置到哈希表 key 中。
11	HSET key field value 
将哈希表 key 中的字段 field 的值设为 value 。
12	HSETNX key field value 
只有在字段 field 不存在时，设置哈希表字段的值。
13	HVALS key 
获取哈希表中所有值。
14	HSCAN key cursor [MATCH pattern] [COUNT count] 
迭代哈希表中的键值对。
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>参考:<a href="https://www.runoob.com/redis/redis-hashes.html" target="_blank" rel="noopener noreferrer">https://www.runoob.com/redis/redis-hashes.html</a></p>
</blockquote>
<h3 id="_6-5-集合-set" tabindex="-1"> 6.5.集合(Set)</h3>
<p>Redis 的 <strong><span color=#159957 face="黑体">Set </span></strong> 是 <strong><span color=#159957 face="黑体">String </span></strong> 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中**<span color=#159957 face="黑体">集合 </span>**是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<div><pre><code>序号	命令及描述
1	SADD key member1 [member2] 
向集合添加一个或多个成员
2	SCARD key 
获取集合的成员数
3	SDIFF key1 [key2] 
返回给定所有集合的差集
4	SDIFFSTORE destination key1 [key2] 
返回给定所有集合的差集并存储在 destination 中
5	SINTER key1 [key2] 
返回给定所有集合的交集
6	SINTERSTORE destination key1 [key2] 
返回给定所有集合的交集并存储在 destination 中
7	SISMEMBER key member 
判断 member 元素是否是集合 key 的成员
8	SMEMBERS key 
返回集合中的所有成员
9	SMOVE source destination member 
将 member 元素从 source 集合移动到 destination 集合
10	SPOP key 
移除并返回集合中的一个随机元素
11	SRANDMEMBER key [count] 
返回集合中一个或多个随机数
12	SREM key member1 [member2] 
移除集合中一个或多个成员
13	SUNION key1 [key2] 
返回所有给定集合的并集
14	SUNIONSTORE destination key1 [key2] 
所有给定集合的并集存储在 destination 集合中
15	SSCAN key cursor [MATCH pattern] [COUNT count] 
迭代集合中的元素
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><blockquote>
<p>参考：<a href="https://www.runoob.com/redis/redis-sets.html" target="_blank" rel="noopener noreferrer">https://www.runoob.com/redis/redis-sets.html</a></p>
</blockquote>
<h3 id="_6-6-有序集合-sorted-set" tabindex="-1"> 6.6.有序集合(sorted set)</h3>
<ol>
<li>Redis **<span color=#159957>有序集合 </span><strong>和</strong><span color=#159957>集合 </span>**一样也是 string 类型元素的集合,且不允许重复的成员。</li>
<li>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</li>
<li>有序集合的成员是唯一的,但分数(score)却可以重复。</li>
<li>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</li>
</ol>
<br>
<div><pre><code>序号	命令及描述
1	ZADD key score1 member1 [score2 member2] 
向有序集合添加一个或多个成员，或者更新已存在成员的分数
2	ZCARD key 
获取有序集合的成员数
3	ZCOUNT key min max 
计算在有序集合中指定区间分数的成员数
4	ZINCRBY key increment member 
有序集合中对指定成员的分数加上增量 increment
5	ZINTERSTORE destination numkeys key [key ...] 
计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中
6	ZLEXCOUNT key min max 
在有序集合中计算指定字典区间内成员数量
7	ZRANGE key start stop [WITHSCORES] 
通过索引区间返回有序集合指定区间内的成员
8	ZRANGEBYLEX key min max [LIMIT offset count] 
通过字典区间返回有序集合的成员
9	ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 
通过分数返回有序集合指定区间内的成员
10	ZRANK key member 
返回有序集合中指定成员的索引
11	ZREM key member [member ...] 
移除有序集合中的一个或多个成员
12	ZREMRANGEBYLEX key min max 
移除有序集合中给定的字典区间的所有成员
13	ZREMRANGEBYRANK key start stop 
移除有序集合中给定的排名区间的所有成员
14	ZREMRANGEBYSCORE key min max 
移除有序集合中给定的分数区间的所有成员
15	ZREVRANGE key start stop [WITHSCORES] 
返回有序集中指定区间内的成员，通过索引，分数从高到低
16	ZREVRANGEBYSCORE key max min [WITHSCORES] 
返回有序集中指定分数区间内的成员，分数从高到低排序
17	ZREVRANK key member 
返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序
18	ZSCORE key member 
返回有序集中，成员的分数值
19	ZUNIONSTORE destination numkeys key [key ...] 
计算给定的一个或多个有序集的并集，并存储在新的 key 中
20	ZSCAN key cursor [MATCH pattern] [COUNT count] 
迭代有序集合中的元素（包括元素成员和元素分值）
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="_7-redis常用" tabindex="-1"> 7.Redis常用</h2>
<blockquote>
<p>如果你读到在这里，相信你对 Redis 已经有了一定了解，入门就先简单学到这里，下篇一起上**<span color=#159957 face="黑体">青铜</span>**。</p>
</blockquote>
<blockquote>
<p>后面的篇章，还将继续介绍 Redis 的一些高级用法，缓存击穿、缓存雪崩，源码分析等。看后不忘三连，还有需要更多技术博文可以留言催更。</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/20200613232629668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" type="image/"/>
    </item>
    <item>
      <title>rodert单排学习redis进阶【青铜】</title>
      <link>https://dearlocation.com/posts/redis/learn-redis-02.html</link>
      <guid>https://dearlocation.com/posts/redis/learn-redis-02.html</guid>
      <source url="https://dearlocation.com/rss.xml">rodert单排学习redis进阶【青铜】</source>
      <description>rodert单排学习redis进阶【青铜】
</description>
      <category>redis</category>
      <pubDate>Mon, 25 Apr 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>rodert单排学习redis进阶【青铜】</p>

<p>redis之青铜</p>
<p><img src="https://img-blog.csdnimg.cn/20200616155217399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">
@[toc]</p>
<h2 id="前言" tabindex="-1"> 前言</h2>
<blockquote>
<p>声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。</p>
</blockquote>
<blockquote>
<p>本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。
欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：DearLocation</p>
</blockquote>
<blockquote>
<p>有任何问题都可以来谈谈 ！</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200616161009430.jpg" alt="在这里插入图片描述" loading="lazy"></p>
<p>本篇继续学习 Redis ,上一篇 <a href="https://mp.weixin.qq.com/s?__biz=MzUzNDUyOTY0Nw==&amp;mid=2247484011&amp;idx=1&amp;sn=1ffdb758a552db1934f41b1c4496bb36&amp;chksm=fa92116bcde5987da7db79b41b86add44bddc574cdbd33bd622b7f6a21662c652331ed9e4173&amp;scene=126&amp;sessionid=1592125292&amp;key=2e8f81eda3e54fad9074a8b209275cc64f9c5dd28066961b7be2f518b92c55507968ed1b6278d887e87fd9f464f4b4899c8cf651adda04616c16f3c11e97de5ebdc827c9144e99e8b08451af86234894&amp;ascene=1&amp;uin=MTk1NDc4MzM2Mg%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AWHTYrB4gjJmGEbHtri6R6w%3D&amp;pass_ticket=leo%2BHfJ0BW2bC82%2BQSYAPob7M1DzxC09JpT%2BAvOxTmnKdJp6Basn7bAq9v%2Fv3xN%2B" target="_blank" rel="noopener noreferrer">rodert单排学习redis入门【黑铁】</a> 对 Redis **<span color=#159957>安装</span><strong>和</strong><span color=#159957>常用数据</span>**结构做了梳理，如果没看可以先回去看完再继续本篇~</p>
<p>上一篇都是对一些 redis 基本数据类型 api 的讲解，本篇是数据类型底层实现，主要内容有：</p>
<ul>
<li>为什么使用Redis</li>
<li>Redis数据结构解析</li>
<li>SDS简单动态字符串</li>
<li>哈希表</li>
<li>跳跃表</li>
<li>整数集合</li>
<li>压缩列表</li>
<li>Redis中数据结构的对象</li>
<li>...</li>
</ul>
<h2 id="_1-再谈redis" tabindex="-1"> 1.再谈Redis</h2>
<p>Redis 是什么？官话来说就是：</p>
<blockquote>
<p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.</p>
</blockquote>
<p>Redis 是一个开源的、<strong>基于内存</strong>的<strong>数据结构存储器</strong>，可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>。</p>
<p>如果想尝试 Redis 命令又懒得安装，可以使用这个 <a href="http://try.redis.io/" target="_blank" rel="noopener noreferrer">http://try.redis.io/</a> 网站。</p>
<p><img src="https://img-blog.csdnimg.cn/20200616155248408.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="_2-为什么要用redis" tabindex="-1"> 2.为什么要用Redis</h2>
<p>上一篇咱们有一定了解</p>
<p>Redis 是**<span color=#159957>基于内存</span>**，常用作缓存的一种技术，并且 Redis 存储的方式是以 <strong><span color=#c00>key-value</span></strong> 形式。</p>
<p>那我们为什么不用 Java Map？</p>
<ul>
<li>Java Map是**<span color=#c00>本地缓存</span>**的，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</li>
<li>JVM内存太大容易挂掉，还有各种**<span color=#c00>过期机制、存储结构</span>**需要自己手动来写</li>
<li>Redis 会定期把缓存保存到硬盘，重启恢复数据，丰富的数据结构，缓存机制等实用功能。</li>
</ul>
<h2 id="_3-为什么要使用缓存" tabindex="-1"> 3.为什么要使用缓存？</h2>
<p>高并发，高可用这是现在互联网经常提到的一个词。在程序出现大量请求是就会出现**<span color=#c00>性能问题</span><strong>，一般性能问题第一道就是</strong><span color=#c00>数据库扛不住了</span>**，数据库的读写会有磁盘操作，而磁盘的速度相对内存来说慢很多。</p>
<p>所有我们在中间加一道缓存：</p>
<p><img src="https://img-blog.csdnimg.cn/20200616161041153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="_4-redis数据结构" tabindex="-1"> 4.Redis数据结构</h2>
<h3 id="_4-1-sds简单动态字符串" tabindex="-1"> 4.1.SDS简单动态字符串</h3>
<h4 id="_4-1-1-sds简单动态字符串" tabindex="-1"> 4.1.1.SDS简单动态字符串</h4>
<p>Redis 是由C语言编写的。</p>
<p>我们现在知道 Redis 所有键都是字符串，值有字符串（string）、散列（hash）、列表（list）、集合（set）和有序集合（sorted set）这五种类型的键的底层实现数据结构。</p>
<blockquote>
<p>Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。</p>
</blockquote>
<p>Redis 使用 <code>sds.h/sdshdr</code> 结构表示一个 SDS 值：</p>
<div><pre><code>struct sdshdr <span>{</span>

    <span>// 记录 buf 数组中已使用字节的数量</span>
    <span>// 等于 SDS 所保存字符串的长度</span>
    <span>int</span> len<span>;</span>

    <span>// 记录 buf 数组中未使用字节的数量</span>
    <span>int</span> free<span>;</span>

    <span>// 字节数组，用于保存字符串</span>
    <span>char</span> buf<span>[</span><span>]</span><span>;</span>

<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="https://img-blog.csdnimg.cn/20200616155325700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>上图是 SDS 示例，以空字符结尾 <code>'\0'</code>。遵循空字符结尾这一惯例的好处是， SDS 可以直接重用一部分 C 字符串函数库里面的函数。</p>
<p>举个例子， 如果我们有一个指向图 2-1 所示 SDS 的指针 s ， 那么我们可以直接使用 stdio.h/printf 函数， 通过执行以下语句：</p>
<div><pre><code><span>printf</span><span>(</span><span>"%s"</span><span>,</span> s<span>-></span>buf<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>来打印出 SDS 保存的字符串值 &quot;Redis&quot; ， 而无须为 SDS 编写专门的打印函数。</p>
<h4 id="_4-1-2-sds简单动态字符串好处" tabindex="-1"> 4.1.2.SDS简单动态字符串好处</h4>
<ol>
<li>
<p>sdshdr数据结构中用len属性记录了字符串的长度。那么获取字符串的长度时，<strong><span color=#c00>时间复杂度</span><strong>只需要 <code>O(1)</code>。</strong><span color=#159957>常数复杂度获取字符串长度</span></strong>。</p>
</li>
<li>
<p>SDS不会发生溢出的问题，如果修改SDS时，空间不足。先会扩展空间，再进行修改！(<strong><span color=#c00>内部实现了动态扩展机制</span></strong>)。<strong><span color=#159957>杜绝缓冲区溢出</span></strong>。</p>
</li>
<li>
<p>SDS可以**<span color=#c00>减少内存分配的次数</span><strong>(空间预分配机制)。在扩展空间时，除了分配修改时所必要的空间，还会分配额外的空闲空间(free 属性)。</strong><span color=#159957>减少修改字符串长度时所需的内存重分配次数</span>**。</p>
</li>
<li>
<p>SDS是**<span color=#c00>二进制安全</span>**的，SDS 以二进制的方式来处理SDS存放在buf数组里的数据。</p>
</li>
<li>
<p>可以使用一部分 <code>&lt;string.h&gt;</code> 库中的函数。<strong><span color=#159957>兼容部分 C 字符串函数</span></strong>。</p>
</li>
</ol>
<h3 id="_4-2-redis-链表和链表节点" tabindex="-1"> 4.2.Redis 链表和链表节点</h3>
<blockquote>
<p>Java 学习者对链表应该都很熟悉，链表是 Java 中一种典型且常用的数据构。</p>
</blockquote>
<p>每个**<span color=#c00>链表节点</span>**使用一个 <code>adlist.h/listNode</code> 结构来表示：</p>
<div><pre><code>typedef struct listNode <span>{</span>

    <span>// 前置节点</span>
    struct listNode <span>*</span>prev<span>;</span>

    <span>// 后置节点</span>
    struct listNode <span>*</span>next<span>;</span>

    <span>// 节点的值</span>
    <span>void</span> <span>*</span>value<span>;</span>

<span>}</span> listNode<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>使用listNode是可以组成链表了，Redis中**<span color=#159957>使用list结构来持有链表</span>**：</p>
<div><pre><code>typedef struct list <span>{</span>

    <span>// 表头节点</span>
    listNode <span>*</span>head<span>;</span>

    <span>// 表尾节点</span>
    listNode <span>*</span>tail<span>;</span>

    <span>// 链表所包含的节点数量</span>
    unsigned <span>long</span> len<span>;</span>

    <span>// 节点值复制函数</span>
    <span>void</span> <span>*</span><span>(</span><span>*</span>dup<span>)</span><span>(</span><span>void</span> <span>*</span>ptr<span>)</span><span>;</span>

    <span>// 节点值释放函数</span>
    <span>void</span> <span>(</span><span>*</span>free<span>)</span><span>(</span><span>void</span> <span>*</span>ptr<span>)</span><span>;</span>

    <span>// 节点值对比函数</span>
    <span>int</span> <span>(</span><span>*</span>match<span>)</span><span>(</span><span>void</span> <span>*</span>ptr<span>,</span> <span>void</span> <span>*</span>key<span>)</span><span>;</span>

<span>}</span> list<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>由一个 <code>list</code> 结构和三个 <code>listNode</code> 结构组成的链表：</p>
<p><img src="https://img-blog.csdnimg.cn/20200616155348716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h4 id="_4-2-2-redis-链表重点" tabindex="-1"> 4.2.2.Redis 链表重点</h4>
<ul>
<li>链表被广泛用于实现 Redis 的各种功能， 比如<strong>列表键， 发布与订阅， 慢查询， 监视器</strong>， 等等。</li>
<li>每个链表节点由一个 <code>listNode</code> 结构来表示， 每个节点都有一个指向<strong>前置节点</strong>和<strong>后置节点</strong>的指针， 所以 Redis 的链表实现是<strong>双端链表</strong>。</li>
<li>每个链表使用一个 <code>list</code> 结构来表示，这个结构带有<strong>表头节点指针</strong>、<strong>表尾节点指针</strong>、以及<strong>链表长度</strong>等信息。</li>
<li>因为链表表头节点的<strong>前置节点</strong>和<strong>表尾节点</strong>的后置节点都指向 NULL ， 所以 Redis 的链表实现是<strong>无环链表</strong>。</li>
<li>通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。</li>
</ul>
<h3 id="_4-3-redis-字典" tabindex="-1"> 4.3.Redis 字典</h3>
<h4 id="_4-3-1-哈希表" tabindex="-1"> 4.3.1.哈希表</h4>
<blockquote>
<p>字典是 Redis 中的一个概念，Redis 的字典使用哈希表作为底层实现。 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。</p>
</blockquote>
<p><strong>空哈希表</strong>
Redis 字典所使用的哈希表由 <code>dict.h/dictht</code> 结构定义：</p>
<div><pre><code><span>typedef</span> <span>struct</span> <span>dictht</span> <span>{</span>

    <span>// 哈希表数组</span>
    dictEntry <span>*</span><span>*</span>table<span>;</span>

    <span>// 哈希表大小</span>
    <span>unsigned</span> <span>long</span> size<span>;</span>

    <span>// 哈希表大小掩码，用于计算索引值</span>
    <span>// 总是等于 size - 1</span>
    <span>unsigned</span> <span>long</span> sizemask<span>;</span>

    <span>// 该哈希表已有节点的数量</span>
    <span>unsigned</span> <span>long</span> used<span>;</span>

<span>}</span> dictht<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="https://img-blog.csdnimg.cn/20200616155404943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>哈希表节点</strong>
哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：</p>
<div><pre><code><span>typedef</span> <span>struct</span> <span>dictEntry</span> <span>{</span>

    <span>// 键</span>
    <span>void</span> <span>*</span>key<span>;</span>

    <span>// 值</span>
    <span>union</span> <span>{</span>
        <span>void</span> <span>*</span>val<span>;</span> 
        <span>uint64_t</span> u64<span>;</span> <span>//uint64_t整数</span>
        <span>int64_t</span> s64<span>;</span> <span>//int64_t整数</span>
    <span>}</span> v<span>;</span>

    <span>// 指向下个哈希表节点，形成链表</span>
    <span>struct</span> <span>dictEntry</span> <span>*</span>next<span>;</span>

<span>}</span> dictEntry<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="https://img-blog.csdnimg.cn/20200616155419279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>有没有注意到，上图有个冲突，俩个键在同一个节点，这就是 Redis <strong>解决键冲突</strong> ，Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p>
</blockquote>
<p><strong>字典</strong>
Redis 中的字典由 dict.h/dict 结构表示：</p>
<div><pre><code><span>typedef</span> <span>struct</span> <span>dict</span> <span>{</span>

    <span>// 类型特定函数</span>
    dictType <span>*</span>type<span>;</span>

    <span>// 私有数据</span>
    <span>void</span> <span>*</span>privdata<span>;</span>

    <span>// 哈希表</span>
    dictht ht<span>[</span><span>2</span><span>]</span><span>;</span>

    <span>// rehash 索引</span>
    <span>// 当 rehash 不在进行时，值为 -1</span>
    <span>int</span> rehashidx<span>;</span> <span>/* rehashing not in progress if rehashidx == -1 */</span>

<span>}</span> dict<span>;</span>

<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>分割线<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>

<span>typedef</span> <span>struct</span> <span>dictType</span> <span>{</span>

    <span>// 计算哈希值的函数</span>
    <span>unsigned</span> <span>int</span> <span>(</span><span>*</span>hashFunction<span>)</span><span>(</span><span>const</span> <span>void</span> <span>*</span>key<span>)</span><span>;</span>

    <span>// 复制键的函数</span>
    <span>void</span> <span>*</span><span>(</span><span>*</span>keyDup<span>)</span><span>(</span><span>void</span> <span>*</span>privdata<span>,</span> <span>const</span> <span>void</span> <span>*</span>key<span>)</span><span>;</span>

    <span>// 复制值的函数</span>
    <span>void</span> <span>*</span><span>(</span><span>*</span>valDup<span>)</span><span>(</span><span>void</span> <span>*</span>privdata<span>,</span> <span>const</span> <span>void</span> <span>*</span>obj<span>)</span><span>;</span>

    <span>// 对比键的函数</span>
    <span>int</span> <span>(</span><span>*</span>keyCompare<span>)</span><span>(</span><span>void</span> <span>*</span>privdata<span>,</span> <span>const</span> <span>void</span> <span>*</span>key1<span>,</span> <span>const</span> <span>void</span> <span>*</span>key2<span>)</span><span>;</span>

    <span>// 销毁键的函数</span>
    <span>void</span> <span>(</span><span>*</span>keyDestructor<span>)</span><span>(</span><span>void</span> <span>*</span>privdata<span>,</span> <span>void</span> <span>*</span>key<span>)</span><span>;</span>

    <span>// 销毁值的函数</span>
    <span>void</span> <span>(</span><span>*</span>valDestructor<span>)</span><span>(</span><span>void</span> <span>*</span>privdata<span>,</span> <span>void</span> <span>*</span>obj<span>)</span><span>;</span>

<span>}</span> dictType<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>​	ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 <strong>dictht</strong> 哈希表， 一般情况下， 字典只使用 <strong>ht[0]</strong> 哈希表， <strong>ht[1]</strong> 哈希表只会在对 <strong>ht[0]</strong> 哈希表进行 <strong>rehash</strong> 时使用。</p>
<p><img src="https://img-blog.csdnimg.cn/20200616155431351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h4 id="_4-3-2-redis-rehash-重新散列" tabindex="-1"> 4.3.2.Redis rehash(重新散列)</h4>
<p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的**<span color=#159957>负载因子</span>**（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。</p>
<blockquote>
<p>在对哈希表进行扩展或者收缩操作时，reash 过程并不是一次性地完成的，而是**<span color=#159957>渐进式</span>**地完成的。</p>
</blockquote>
<div><pre><code>以下是哈希表渐进式 rehash 的详细步骤：

为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。
在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。
在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。
随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="_4-3-3-重点" tabindex="-1"> 4.3.3.重点</h4>
<ul>
<li>字典被广泛用于实现 Redis 的各种功能， 其中包括数据库和哈希键。</li>
<li>Redis 中的字典使用哈希表作为底层实现， 每个字典带有两个哈希表， 一个用于平时使用， 另一个仅在进行 <code>rehash</code> 时使用。</li>
<li>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</li>
<li>哈希表使用链地址法来解决键冲突， 被分配到同一个索引上的多个键值对会连接成一个单向链表。</li>
<li>在对哈希表进行扩展或者收缩操作时， 程序需要将现有哈希表包含的所有键值对 <code>rehash</code> 到新哈希表里面， 并且这个 rehash 过程并不是一次性地完成的， 而是渐进式地完成的。</li>
</ul>
<h3 id="_4-4-跳跃表" tabindex="-1"> 4.4.跳跃表</h3>
<h4 id="_4-4-1-跳跃表" tabindex="-1"> 4.4.1.跳跃表</h4>
<p>Redis 的跳跃表由 <code>redis.h/zskiplistNode</code> 和 <code>redis.h/zskiplist</code> 两个结构定义， 其中 <code>zskiplistNode</code> 结构用于表示跳跃表节点， 而 <code>zskiplist</code> 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向**<span color=#159957>表头节点和表尾节点</span>**的指针， 等等。</p>
<p><strong>跳跃表节点</strong></p>
<div><pre><code><span>typedef</span> <span>struct</span> <span>zskiplistNode</span> <span>{</span>

    <span>// 后退指针</span>
    <span>struct</span> <span>zskiplistNode</span> <span>*</span>backward<span>;</span>

    <span>// 分值</span>
    <span>double</span> score<span>;</span>

    <span>// 成员对象</span>
    robj <span>*</span>obj<span>;</span>

    <span>// 层</span>
    <span>struct</span> <span>zskiplistLevel</span> <span>{</span>

        <span>// 前进指针</span>
        <span>struct</span> <span>zskiplistNode</span> <span>*</span>forward<span>;</span>

        <span>// 跨度</span>
        <span>unsigned</span> <span>int</span> span<span>;</span>

    <span>}</span> level<span>[</span><span>]</span><span>;</span>

<span>}</span> zskiplistNode<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>zskiplistNode 不同层高节点</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200616155501710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， <strong><span color=#159957>层的数量越多</span></strong>， 访问其他节点的**<span color=#159957>速度就越快</span>**。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200616155511703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>看到这里，如果还有疑惑，不理解什么是跳跃表，传送一篇不错的跳跃表介绍文章：<a href="https://www.cnblogs.com/hunternet/p/11248192.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/hunternet/p/11248192.html</a></p>
</blockquote>
<h4 id="_4-4-2-重点" tabindex="-1"> 4.4.2.重点</h4>
<ol>
<li>跳跃表是有序集合的底层实现之一， 除此之外它在 Redis 中没有其他应用。</li>
<li>Redis 的跳跃表实现由 zskiplist 和 zskiplistNode 两个结构组成， 其中 zskiplist 用于保存**<span color=#159957>跳跃表信息</span><strong>（比如表头节点、表尾节点、长度）， 而 zskiplistNode 则用于表示</strong><span color=#159957>跳跃表节点</span>**。</li>
<li>每个跳跃表节点的层高都是 <strong><span color=#159957>1 至 32</span></strong> 之间的**<span color=#159957>随机数</span>**。</li>
<li>在同一个跳跃表中， 多个节点可以包含**<span color=#159957>相同的分值</span><strong>， 但每个节点的</strong><span color=#159957>成员对象必须是唯一</span>**的。</li>
<li>跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。</li>
</ol>
<h3 id="_4-5-整数集合" tabindex="-1"> 4.5.整数集合</h3>
<ul>
<li><strong>整数集合</strong>是**<span color=#159957>集合键(set)</span>**的底层实现之一。</li>
<li>整数集合的底层实现为**<span color=#159957>数组</span><strong>， 这个数组以</strong><span color=#159957>有序、无重复</span><strong>的方式保存集合元素，在有需要时， 程序会根据</strong><span color=#159957>新添加元素</span>**的类型， <strong><span color=#159957>改变这个数组的类型</span></strong>。</li>
<li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地<strong>节约了内存</strong>。</li>
<li>整数集合**<span color=#159957>只支持升级</span>**操作， 不支持降级操作。</li>
</ul>
<p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 的整数值， 并且保证集合中不会出现**<span color=#159957>重复元素</span>**。</p>
<p>数据结构：</p>
<div><pre><code><span>typedef</span> <span>struct</span> <span>intset</span> <span>{</span>

    <span>// 编码方式</span>
    <span>uint32_t</span> encoding<span>;</span>

    <span>// 集合包含的元素数量</span>
    <span>uint32_t</span> length<span>;</span>

    <span>// 保存元素的数组</span>
    <span>int8_t</span> contents<span>[</span><span>]</span><span>;</span>

<span>}</span> intset<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="https://img-blog.csdnimg.cn/20200616155827825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="_4-6-压缩列表" tabindex="-1"> 4.6.压缩列表</h3>
<h4 id="_4-6-1-前言" tabindex="-1"> 4.6.1.前言</h4>
<blockquote>
<p>同整数集合一样压缩列表也不是基础数据结构，而是 <strong>Redis</strong> 自己设计的一种数据存储结构。它有点儿类似数组，通过一片**<span color=#159957>连续的内存空间</span>**，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。</p>
</blockquote>
<p>我们知道，数组要求每个元素大大小相同，如果要存储长度不同的字符串，那就需要用**<span color=#159957>最大长度</span>**的字符串大小作为元素的大小。以最大长度为标准，就会浪费一部分存储空间。</p>
<p>数组的优势占用一片**<span color=#159957>连续的空间</span>**可以很好的利用CPU缓存访问数据。如果我们想要保留这种优势，又想节省存储空间我们可以对数组进行压缩。</p>
<p>那就需要给每个节点增加一个 <code>lenght</code> 的属性。</p>
<h4 id="_4-6-2-redis-压缩列表" tabindex="-1"> 4.6.2.Redis 压缩列表</h4>
<p><em>压缩列表(zip1ist)是 Redis 列表和 Redis 哈希的底层实现之一。</em></p>
<ul>
<li>
<p>当一个列表只包含少量列表项,并且每个列表项要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做列表的底层实现。</p>
</li>
<li>
<p>当一个哈希只包含少量键值对,比且每个键值对的键和值要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做哈希的底层实现。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200616155926449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/hunternet/p/11306690.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/hunternet/p/11306690.html</a></p>
</blockquote>
<ol>
<li>表是Redis为节约内存自己设计的一种顺序型数据结构。</li>
<li>表被用作列表键和哈希键的底层实现之一。</li>
<li>压缩列表可以包含多个节点,每个节点可以保存一个字节数组或者整数值。</li>
<li>添加新节点到压缩列表,或者从压缩列表中删除节点,可能会引发连锁更新操作,但这种操作出现的几率并不高。</li>
</ol>
<h3 id="_4-7-redis的对象" tabindex="-1"> 4.7.Redis的对象</h3>
<h4 id="_4-7-1-redis的对象" tabindex="-1"> 4.7.1.Redis的对象</h4>
<p>Redis 中当我们创建一个键值对时，我们至少会创建俩个对象，一个用作键(键对象)，一个用作值(值对象)。</p>
<ul>
<li>Redis 对象结构</li>
</ul>
<div><pre><code><span>typedef</span> <span>struct</span> <span>redisObject</span> <span>{</span>

    <span>// 类型</span>
    <span>unsigned</span> type<span>:</span><span>4</span><span>;</span>

    <span>// 编码</span>
    <span>unsigned</span> encoding<span>:</span><span>4</span><span>;</span>

    <span>// 指向底层实现数据结构的指针</span>
    <span>void</span> <span>*</span>ptr<span>;</span>

    <span>// ...</span>

<span>}</span> robj<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li><strong>Redis 内存回收</strong></li>
</ul>
<blockquote>
<p>值得一提的是 redis 内存回收，因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个**<span color=#159957>引用计数</span><strong>（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行</strong><span color=#159957>内存回收</span>**。每个对象的引用计数信息由 <code>redisObject</code> 结构的 <code>refcount</code> 属性记录：</p>
</blockquote>
<div><pre><code><span>typedef</span> <span>struct</span> <span>redisObject</span> <span>{</span>

    <span>// ...</span>

    <span>// 引用计数</span>
    <span>int</span> refcount<span>;</span>

    <span>// ...</span>

<span>}</span> robj<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li><strong>Redis 对象共享</strong></li>
</ul>
<blockquote>
<p>举个例子， 假设键 A 创建了一个包含整数值 100 的字符串对象作为值对象，如果这时键 B 也要创建一个同样保存了整数值 100 的字符串对象作为值对象。</p>
</blockquote>
<p>在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：</p>
<ol>
<li>将数据库键的值指针指向一个现有的值对象；</li>
<li>将被共享的值对象的引用计数增一。</li>
</ol>
<p><code>目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。</code></p>
<ul>
<li><strong>Redis 对象的空转时长</strong></li>
</ul>
<blockquote>
<p>除了前面介绍过的 <strong><span color=#159957>type 、 encoding 、 ptr 和 refcount</span></strong> 四个属性之外， redisObject 结构包含的最后一个属性为 <strong><span color=#159957>lru</span></strong> 属性， 该属性记录了对象最后一次被命令程序访问的时间：</p>
</blockquote>
<div><pre><code><span>typedef</span> <span>struct</span> <span>redisObject</span> <span>{</span>

    <span>// ...</span>

    <span>unsigned</span> lru<span>:</span><span>22</span><span>;</span>

    <span>// ...</span>

<span>}</span> robj<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="_4-7-2-重点" tabindex="-1"> 4.7.2.重点</h4>
<blockquote>
<p>内存回收和对象的空转时长涉及到 Redis 配置文件(内存的算法 volatile-lru、allkeys-lru等其他知识点)，后面单独一篇详细讲解。</p>
</blockquote>
<ul>
<li>Redis 数据库中的每个键值对的键和值都是一个对象。</li>
<li>Redis 共有字**<span color=#159957>符串、列表、哈希、集合、有序集合</span>**五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
<li>服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。</li>
<li>Redis 的对象系统带有引用计数实现的**<span color=#159957>内存回收机制</span>**， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。</li>
<li>Redis 会共享值为 0 到 9999 的字符串对象。</li>
<li>对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的**<span color=#159957>空转时间</span>**。</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/20200616155217399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzc0NjA0,size_16,color_FFFFFF,t_70" type="image/"/>
    </item>
    <item>
      <title>rodert单排学习redis进阶【白银一】</title>
      <link>https://dearlocation.com/posts/redis/learn-redis-03.html</link>
      <guid>https://dearlocation.com/posts/redis/learn-redis-03.html</guid>
      <source url="https://dearlocation.com/rss.xml">rodert单排学习redis进阶【白银一】</source>
      <description>rodert单排学习redis进阶【白银一】
</description>
      <category>redis</category>
      <pubDate>Mon, 25 Apr 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>rodert单排学习redis进阶【白银一】</p>

<p>redis之白银一</p>
<p><code>说些题外话，最近帝都疫情又严重，大家都身处时代洪流中，这不是个别人能左右的，希望你能保护好自己，天天开心。</code></p>
<p>@[toc]</p>
<h3 id="前言" tabindex="-1"> 前言</h3>
<blockquote>
<p>声明：参考来源互联网，有任何争议可以留言。站在前人的肩上，我们才能看的更远。</p>
</blockquote>
<p><code>前文推荐阅读：</code></p>
<p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzNDUyOTY0Nw==&amp;action=getalbum&amp;album_id=1389304118178840577&amp;subscene=126&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzUzNDUyOTY0Nw%3D%3D%26mid%3D2247484050%26idx%3D1%26sn%3D5b76110a20c22959fdbbe1f8f367a709%26chksm%3Dfa921192cde59884bd8c810eba099e3d371f7f77f9481d167e76753739fce4ed0111ca343a35%26scene%3D126%26sessionid%3D1593072726%26key%3D2e8f81eda3e54fad73caa3aec9e546eec371260ca3b30cbb0e97ee0d569806699c0e6ac6bc8f1a0a04974a4f03d1e9ce9ae1bc838e0c06e3ac25f682055eca28db3fc0078943eafe783bb4e5e6816f33%26ascene%3D1%26uin%3DMTk1NDc4MzM2Mg%253D%253D%26devicetype%3DWindows%2B10%2Bx64%26version%3D62090070%26lang%3Dzh_CN%26exportkey%3DAYmXGhQITcjoyZn4ey%252Bxo5Q%253D%26pass_ticket%3DguqlwSdMxkC7XLyNJjPoGkvn0U9XOSyfcXnMeGtUYAn8EAUS8reK0TbBSbbW9Nss%26winzoom%3D1#wechat_redirect" target="_blank" rel="noopener noreferrer">rodert单排学习redis入门【黑铁】</a></p>
<p><a href="https://mp.weixin.qq.com/s/S2qZiJG-_HgW3ET9Sl0EAg" target="_blank" rel="noopener noreferrer">yangchunjian 单排学习 redis 进阶【青铜】</a></p>
<h3 id="_1-redis-客户端" tabindex="-1"> 1.Redis 客户端</h3>
<h4 id="_1-1-redis-desktop-manager" tabindex="-1"> 1.1.Redis Desktop Manager</h4>
<p>使用称手的工具，做起事来 <code>事半功倍</code> ，用 <code>redis-cli</code> 自然不错。我推荐一款我经常用的 <code>Redis</code> <strong>可视化</strong>工具，<code>Redis Desktop Manager</code> 。</p>
<p>启动界面如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC81MzEyMWYwMGVkNDg0ZTJlYWFkYTZlYWM2NGMzMjE1NC5wbmc?x-oss-process=image/format,png" alt="" loading="lazy"></p>
<p>至于安装方式是 <code>一键安装</code> 。</p>
<blockquote>
<p>官网下载地址：<a href="https://redisdesktop.com/pricing" target="_blank" rel="noopener noreferrer">https://redisdesktop.com/pricing</a></p>
</blockquote>
<blockquote>
<p>学生和学习者可以公众号后台回复：【666】，免费获取。</p>
</blockquote>
<h3 id="_2-redis-连接池" tabindex="-1"> 2.Redis 连接池</h3>
<h4 id="_2-2-0-连接池" tabindex="-1"> 2.2.0.连接池</h4>
<blockquote>
<p>池技术被广泛使用在系统开发中，像 <code>JDBC</code> 连接池、线程池等。连连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程使用。</p>
</blockquote>
<p>在处理一个任务时，我们大多情况要在数毫秒级别就完成，如果重复创建、关闭资源，会占用较长时间和大量系统资源。</p>
<ul>
<li><strong>使用连接池优势</strong></li>
</ul>
<ol>
<li><strong>减少连接创建时间</strong></li>
</ol>
<p>连接在系统初始化时就创建完成，需要时直接从池中取用，减少了时间开销。</p>
<ol start="2">
<li><strong>简化的编程模式</strong></li>
</ol>
<p>当使用连接池时，每一个单独的线程能够像创建了一个自己的 JDBC 连接一样操作。</p>
<ol start="3">
<li><strong>受控的资源使用</strong></li>
</ol>
<p>连接池能够控制一个模块的资源占用率，不会让一个模块资源占用过高，导致整个系统崩溃。</p>
<h4 id="_2-1-redis-连接池" tabindex="-1"> 2.1.Redis 连接池</h4>
<h5 id="_2-1-1-前言引入" tabindex="-1"> 2.1.1.前言引入</h5>
<blockquote>
<p><code>Redis</code> 修炼之连接池篇，前面讲了Redis入门篇：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzNDUyOTY0Nw==&amp;action=getalbum&amp;album_id=1389304118178840577&amp;subscene=126&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzUzNDUyOTY0Nw%3D%3D%26mid%3D2247484050%26idx%3D1%26sn%3D5b76110a20c22959fdbbe1f8f367a709%26chksm%3Dfa921192cde59884bd8c810eba099e3d371f7f77f9481d167e76753739fce4ed0111ca343a35%26scene%3D126%26sessionid%3D1593072726%26key%3D2e8f81eda3e54fad73caa3aec9e546eec371260ca3b30cbb0e97ee0d569806699c0e6ac6bc8f1a0a04974a4f03d1e9ce9ae1bc838e0c06e3ac25f682055eca28db3fc0078943eafe783bb4e5e6816f33%26ascene%3D1%26uin%3DMTk1NDc4MzM2Mg%253D%253D%26devicetype%3DWindows%2B10%2Bx64%26version%3D62090070%26lang%3Dzh_CN%26exportkey%3DAYmXGhQITcjoyZn4ey%252Bxo5Q%253D%26pass_ticket%3DguqlwSdMxkC7XLyNJjPoGkvn0U9XOSyfcXnMeGtUYAn8EAUS8reK0TbBSbbW9Nss%26winzoom%3D1#wechat_redirect" target="_blank" rel="noopener noreferrer">rodert单排学习redis入门【黑铁】</a>、<a href="https://mp.weixin.qq.com/s/S2qZiJG-_HgW3ET9Sl0EAg" target="_blank" rel="noopener noreferrer">yangchunjian 单排学习 redis 进阶【青铜】</a>，对 <code>Redis</code> 基本数据类型的操作做了讲解。</p>
</blockquote>
<p>在以前没有开源连接池时，很多人自写连接池工具，简单来说就是创建一个集合，存放一批连接，动态维护着。保证每个连接都是有效的。</p>
<h5 id="_2-1-2-redis-连接池" tabindex="-1"> 2.1.2.Redis 连接池</h5>
<blockquote>
<p>本教程涉及到的一些代码都是 Java 语言编写。</p>
</blockquote>
<p><code>maven</code> 依赖，引入 <code>pom.xml</code> 文件</p>
<ul>
<li><code>pom.xml</code></li>
</ul>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>redis.clients<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>jedis<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;</span>version</span><span>></span></span>3.3.0<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li><code>RedisUtil.java</code></li>
</ul>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>RedisUtil</span> <span>{</span>
    <span>//IP 地址</span>
    <span>private</span> <span>static</span> <span>String</span> ADDR <span>=</span> <span>"127.0.0.1"</span><span>;</span>
    <span>//端口号</span>
    <span>private</span> <span>static</span> <span>int</span> PORT <span>=</span> <span>6379</span><span>;</span>
    <span>//redis 服务端密码</span>
    <span>private</span> <span>static</span> <span>String</span> PWD <span>=</span> <span>"123456"</span><span>;</span>
    
    <span>//可用连接实例最大数目，默认为 8，若赋值 -1，表示不被限制</span>
    <span>private</span> <span>static</span> <span>Integer</span> MAX_TOTAL <span>=</span> <span>1024</span><span>;</span>
    <span>//控制一个连接池最多有多少个状态为空闲的 jedis 实例，默认值为 8</span>
    <span>private</span> <span>static</span> <span>Integer</span> MAX_IDLE <span>=</span> <span>200</span><span>;</span>
    
    <span>//等待可用连接最大的等待时间，单位 ms，默认值 -1，表示永不超时，若等待超时抛出 JedisConnectionException</span>
    <span>private</span> <span>static</span> <span>Integer</span> MAX_WAIT_MILLIS <span>=</span> <span>10000</span><span>;</span>
    <span>//超时</span>
    <span>private</span> <span>static</span> <span>Integer</span> TIMEOUT <span>=</span> <span>10000</span><span>;</span>
    
    <span>//在用一个 jedis 实例时，是否提前进行 validate 操作，若结果为 true 则 jedis 实例可用</span>
    <span>private</span> <span>static</span> <span>Boolean</span> TEST_ON_BORROW <span>=</span> <span>true</span><span>;</span>
    
    <span>//jedis 连接池</span>
    <span>private</span> <span>static</span> <span>JedisPool</span> jedisPool <span>=</span> <span>null</span><span>;</span>
    
    <span>/**
     * 初始化 jedis 连接池的静态块,RedisPool 第一次类加载时执行，以后便不再执行
     */</span>
    <span>static</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>JedisPoolConfig</span> conf <span>=</span> <span>new</span> <span>JedisPoolConfig</span><span>(</span><span>)</span><span>;</span>
            <span>/*
             * 高版本 jedis jar 中 JedisPoolConfig 没有 setMaxActive 和 setMaxWait 属性，因为官方在高版本			   * 中启用了此方法，用以下两个属性替换
             * maxActive ==> maxTotal
             * maxWait ==> maxWaitMillis
             */</span>
            <span>//设置连接实例最大数目</span>
            conf<span>.</span><span>setMaxTotal</span><span>(</span>MAX_TOTAL<span>)</span><span>;</span>
            <span>//设置最多多少空闲的 jedis 实例</span>
            conf<span>.</span><span>setMaxIdle</span><span>(</span>MAX_IDLE<span>)</span><span>;</span>
            <span>//设置等待可用连接的最大时间</span>
            conf<span>.</span><span>setMaxWaitMillis</span><span>(</span>MAX_WAIT_MILLIS<span>)</span><span>;</span>
            <span>//设置是否提前进行测试借用</span>
            conf<span>.</span><span>setTestOnBorrow</span><span>(</span>TEST_ON_BORROW<span>)</span><span>;</span>
            
            <span>//新建 jedis 连接池</span>
            jedisPool <span>=</span> <span>new</span> <span>JedisPool</span><span>(</span>conf<span>,</span> ADDR<span>,</span> PORT<span>,</span> TIMEOUT<span>,</span> PWD<span>)</span><span>;</span>
        <span>}</span>
        <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    
    <span>/*
     * 获取 jedis 实例来操作数据，每次使用完要将连接返回给连接池 jedis.close()
     * @return
     */</span>
    <span>public</span> <span>synchronized</span> <span>static</span> <span>Jedis</span> <span>getRedis</span><span>(</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>if</span><span>(</span>jedisPool <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                <span>//获取 jedis 实例</span>
                <span>Jedis</span> jedis <span>=</span> jedisPool<span>.</span><span>getResource</span><span>(</span><span>)</span><span>;</span>
                <span>return</span> jedis<span>;</span>
            <span>}</span>
            <span>else</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"没有找到 Jedis 连接池！"</span><span>)</span><span>;</span>
                <span>return</span> <span>null</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>
    <span>}</span>
    
    <span>/*
     * 用来回收 Jedis 对象资源，用户需要用到此方法释放资源，否则一直占用资源，在新版本中，`returnResource(jedis) 将被废弃不推荐使用，`直接调用 `jedis.close();` 归还连接到连接池。
     * @param Jedis jedis
     */</span>
    <span>public</span> <span>synchronized</span> <span>static</span> <span>void</span> <span>returnJedis</span><span>(</span><span>Jedis</span> jedis<span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>if</span><span>(</span>jedis <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                <span>//回收 jedis 对象资源</span>
                jedisPool<span>.</span><span>returnResource</span><span>(</span>jedis<span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Jedis 被成功回收！"</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li></li>
</ul>
<blockquote>
<p>本教程纯手打，致力于最实用教程，不需要什么奖励，只希望多多转发支持。
欢迎来我公众号，希望可以结识你，也可以催更，微信搜索：DearLocation</p>
</blockquote>
<blockquote>
<p>有任何问题都可以来谈谈 ！</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200625165207975.jpg" alt="在这里插入图片描述" loading="lazy"></p>
]]></content:encoded>
      <enclosure url="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC81MzEyMWYwMGVkNDg0ZTJlYWFkYTZlYWM2NGMzMjE1NC5wbmc?x-oss-process=image/format,png" type="image/"/>
    </item>
    <item>
      <title>Linux下redis安装</title>
      <link>https://dearlocation.com/posts/redis/redis-install-to-linux.html</link>
      <guid>https://dearlocation.com/posts/redis/redis-install-to-linux.html</guid>
      <source url="https://dearlocation.com/rss.xml">Linux下redis安装</source>
      <description>基于 centOS7 的 redis 安装
</description>
      <category>redis</category>
      <pubDate>Thu, 19 May 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>基于 centOS7 的 redis 安装</p>

<p>基于SpringBoot+VUE的后台管理系统免费开源，欢迎观赏。在线地址：<a href="http://liawan.javapub.net.cn/" target="_blank" rel="noopener noreferrer">http://liawan.javapub.net.cn/</a>。详细参考文档及视频同步更新。</p>
<h2 id="前言" tabindex="-1"> 前言</h2>
<p>安装环境：</p>
<p>centos7、redis5、</p>
<iframe src="//player.bilibili.com/player.html?bvid=BV1qR4y1c78t&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<h2 id="安装教程" tabindex="-1"> 安装教程</h2>
<h3 id="_1-下载" tabindex="-1"> 1. 下载</h3>
<p>国内镜像地址：<a href="https://mirrors.huaweicloud.com/redis/" target="_blank" rel="noopener noreferrer">https://mirrors.huaweicloud.com/redis/</a></p>
<p><img src="https://tva3.sinaimg.cn/large/007F3CC8ly1h2dguy49obj31hc0q1gzo.jpg" alt="image" loading="lazy"></p>
<h3 id="_2-安装" tabindex="-1"> 2. 安装</h3>
<p>解压：</p>
<blockquote>
<p>tar -zxvf redis-5.0.8.tar.gz</p>
</blockquote>
<p>编译：</p>
<div><pre><code><span>cd</span> redis-5.0.8

<span>make</span> <span>install</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h3 id="_3-修改配置" tabindex="-1"> 3. 修改配置</h3>
<p><code>修改redis.conf</code></p>
<p>开启外网访问</p>
<blockquote>
<p>bind 0.0.0.0</p>
</blockquote>
<p>关闭Redis的服务保护模式</p>
<blockquote>
<p>protected-mode no</p>
</blockquote>
<p>修改密码</p>
<blockquote>
<p>requirepass javapub</p>
</blockquote>
<h3 id="_4-启动" tabindex="-1"> 4. 启动</h3>
<blockquote>
<p>redis-server redis.conf</p>
</blockquote>
<p>后台启动：</p>
<blockquote>
<p>nohup redis-server redis.conf &amp;</p>
</blockquote>
<h3 id="_5-访问测试" tabindex="-1"> 5. 访问测试</h3>
<blockquote>
<p>注意，如果外网访问，要保证防火墙对应端口开放。</p>
</blockquote>
<p>原文：<a href="https://blog.csdn.net/qq_40374604/article/details/124857707" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_40374604/article/details/124857707</a></p>
]]></content:encoded>
      <enclosure url="https://tva3.sinaimg.cn/large/007F3CC8ly1h2dguy49obj31hc0q1gzo.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>主要功能与配置演示</title>
      <link>https://dearlocation.com/zh/guide/</link>
      <guid>https://dearlocation.com/zh/guide/</guid>
      <source url="https://dearlocation.com/rss.xml">主要功能与配置演示</source>
      <category>使用指南</category>
      <pubDate>Tue, 28 Jun 2022 11:46:24 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="主要功能与配置演示" tabindex="-1"> 主要功能与配置演示</h1>
<ul>
<li>
<p><a href="/zh/guide/page.html">页面展示</a></p>
</li>
<li>
<p><a href="/zh/guide/markdown.html">Markdown 展示</a></p>
</li>
<li>
<p><a href="/zh/guide/disable.html">禁用展示</a></p>
</li>
<li>
<p><a href="/zh/guide/encrypt.html">加密展示</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>组件禁用</title>
      <link>https://dearlocation.com/zh/guide/disable.html</link>
      <guid>https://dearlocation.com/zh/guide/disable.html</guid>
      <source url="https://dearlocation.com/rss.xml">组件禁用</source>
      <description>你可以通过设置页面的 Frontmatter，在页面禁用一些功能。
</description>
      <category>使用指南</category>
      <pubDate>Tue, 28 Jun 2022 11:46:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>你可以通过设置页面的 Frontmatter，在页面禁用一些功能。</p>

<p>本页面应当禁用了:</p>
<ul>
<li>导航栏</li>
<li>侧边栏</li>
<li>路径导航</li>
<li>页面信息</li>
<li>贡献者</li>
<li>编辑此页链接</li>
<li>更新时间</li>
<li>上一篇/下一篇 链接</li>
<li>评论</li>
<li>页脚</li>
<li>返回顶部按钮</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>密码加密的文章</title>
      <link>https://dearlocation.com/zh/guide/encrypt.html</link>
      <guid>https://dearlocation.com/zh/guide/encrypt.html</guid>
      <source url="https://dearlocation.com/rss.xml">密码加密的文章</source>
      <category>使用指南</category>
      <pubDate>Tue, 28 Jun 2022 11:46:24 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="密码加密的文章" tabindex="-1"> 密码加密的文章</h1>
<p>实际的文章内容。</p>
<p>段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。</p>
<p>段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Markdown 增强</title>
      <link>https://dearlocation.com/zh/guide/markdown.html</link>
      <guid>https://dearlocation.com/zh/guide/markdown.html</guid>
      <source url="https://dearlocation.com/rss.xml">Markdown 增强</source>
      <description>VuePress 的每个文档页面都是由 Markdown 渲染而成。所以你需要通过在相应路径创建编写 Markdown 建立你的文档或博客页面。
</description>
      <category>使用指南</category>
      <pubDate>Tue, 28 Jun 2022 11:46:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>VuePress 的每个文档页面都是由 Markdown 渲染而成。所以你需要通过在相应路径创建编写 Markdown 建立你的文档或博客页面。</p>

<h2 id="markdown-介绍" tabindex="-1"> Markdown 介绍</h2>
<p>如果你是一个新手，还不会编写 Markdown，请先阅读 <a href="https://vuepress-theme-hope.github.io/v2/zh/basic/markdown/README.html" target="_blank" rel="noopener noreferrer">Markdown 介绍</a> 和 <a href="https://vuepress-theme-hope.github.io/v2/zh/basic/markdown/demo.html" target="_blank" rel="noopener noreferrer">Markdown 演示</a>。</p>
<div><p>Frontmatter</p>
<p>Frontmatter 是 VuePress 中很重要的一个概念，如果你不了解它，你需要阅读 <a href="https://vuepress-theme-hope.github.io/v2/zh/basic/vuepress/page.html#front-matter" target="_blank" rel="noopener noreferrer">Frontmatter 介绍</a>。</p>
</div>
<h2 id="vuepress-扩展" tabindex="-1"> VuePress 扩展</h2>
<p>为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。</p>
<p>关于这些扩展，请阅读 <a href="https://vuepress-theme-hope.github.io/v2/zh/basic/vuepress/markdown.html" target="_blank" rel="noopener noreferrer">VuePress 中的 Markdown 扩展</a>。</p>
<h2 id="主题扩展" tabindex="-1"> 主题扩展</h2>
<h3 id="一键启用" tabindex="-1"> 一键启用</h3>
<p>你可以设置 <code>themeconfig.plugins.htmlEnhance.enableAll</code> 启用 <a href="https://vuepress-theme-hope.github.io/v2/md-enhance" target="_blank" rel="noopener noreferrer">md-enhance</a> 插件的所有功能。</p>
<div><pre><code>module.exports = {
  themeConfig: {
    plugins: {
      mdEnhance: {
        enableAll: true,
      },
    },
  },
};
</code></pre><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br></div><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="自定义容器" tabindex="-1"> 自定义容器</h3>
<div>
<p>安全的在 Markdown 中使用 {{ variable }}。</p>
</div>
<div><p>自定义标题</p>
<p>信息容器，包含 <code>代码</code> 与 。</p>
<div><pre><code><span>const</span> a <span>=</span> <span>1</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div></div>
<div><p>自定义标题</p>
<p>提示容器</p>
</div>
<div><p>自定义标题</p>
<p>警告容器</p>
</div>
<div><p>自定义标题</p>
<p>危险容器</p>
</div>
<details><summary>自定义标题</summary>
<p>详情容器</p>
</details>
<details><summary>代码</summary>
<div><pre><code>:::

安全的在 Markdown 中使用 {{ variable }}。

:::

::: info 自定义标题

信息容器

:::

::: tip 自定义标题

提示容器

:::

::: warning 自定义标题

警告容器

:::

::: danger 自定义标题

危险容器

:::

::: details 自定义标题

详情容器

:::
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/container.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="代码块" tabindex="-1"> 代码块</h3>
<p>:::: code-group</p>
<p>::: code-group-item yarn</p>
<div><pre><code><span>yarn</span> <span>add</span> -D vuepress-theme-hope
</code></pre><div aria-hidden="true"><div></div></div></div><p>:::</p>
<p>::: code-group-item npm:active</p>
<div><pre><code><span>npm</span> i -D vuepress-theme-hope
</code></pre><div aria-hidden="true"><div></div></div></div><p>:::</p>
<p>::::</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/code-group.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="自定义对齐" tabindex="-1"> 自定义对齐</h3>
<div style="text-align: center"><p>我是居中的</p>
</div>
<div style="text-align: right"><p>我在右对齐</p>
</div>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/align.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="上下角标" tabindex="-1"> 上下角标</h3>
<p>19<sup>th</sup> H<sub>2</sub>O</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/sup-sub.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="脚注" tabindex="-1"> 脚注</h3>
<p>此文字有脚注<sup></sup>.</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/footnote.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="标记" tabindex="-1"> 标记</h3>
<p>你可以标记 <mark>重要的内容</mark> 。</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/mark.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="任务列表" tabindex="-1"> 任务列表</h3>
<ul>
<li>
<p><input type="checkbox" id="task-item-0" checked="checked" disabled="disabled"><label for="task-item-0"> 计划 1</label></p>
</li>
<li>
<p><input type="checkbox" id="task-item-1" disabled="disabled"><label for="task-item-1"> 计划 2</label></p>
</li>
<li>
<p><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/tasklist.html" target="_blank" rel="noopener noreferrer">查看详情</a></p>
</li>
</ul>
<h3 id="图表" tabindex="-1"> 图表</h3>
<i>Content not supported</i><ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/chart.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="流程图" tabindex="-1"> 流程图</h3>
<i>Content not supported</i><ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/flowchart.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="mermaid" tabindex="-1"> Mermaid</h3>
<i>Content not supported</i><ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/mermaid.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="tex-语法" tabindex="-1"> Tex 语法</h3>
<p class='katex-block'><span><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:2.4em;vertical-align:-0.95em;"></span><span><span></span><span><span><span><span style="height:1.3714em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.05556em;">∂</span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.5904em;"><span style="top:-2.989em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.05556em;">∂</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="margin-right:0.1667em;"></span><span><span style="top:0em;"><span>(</span></span><span><span></span><span><span><span><span style="height:1.3414em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:3.0277em;vertical-align:-1.2777em;"></span><span><span style="top:0em;"><span>(</span></span><span><span></span><span><span><span><span style="height:1.3414em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.1667em;"></span><span><span style="top:0em;"><span>{</span></span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.03588em;">y</span><span><span>)</span><span><span><span><span style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span><span><span><span><span style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span style="top:-3.05em;"><span style="height:3.05em;"></span><span><span>∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span style="height:3.05em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span><span>​</span></span><span><span style="height:1.2777em;"><span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span><span></span><span><span><span><span style="height:1.5017em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.7507em;"><span style="top:-2.989em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span>(</span><span>−</span><span>1</span><span><span>)</span><span><span><span><span style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span></span></span></span></span><span style="margin-right:0.02778em;">r</span><span style="margin-right:0.1667em;"></span><span>⋯</span><span style="margin-right:0.1667em;"></span><span>(</span><span style="margin-right:0.02778em;">r</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span><span>i</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span><span>1</span><span>)</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.03588em;">y</span><span><span>)</span><span><span><span><span style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.02778em;">r</span><span>−</span><span>i</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>}</span></span></span></span></span></span></span></p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/tex.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="代码演示" tabindex="-1"> 代码演示</h3>
<p>::: demo 一个普通 Demo</p>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>VuePress Theme Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>"</span>very<span>"</span></span><span>></span></span>非常<span><span><span>&lt;/</span>span</span><span>></span></span>强大!<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><div><pre><code>document<span>.</span><span>querySelector</span><span>(</span><span>"#very"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>alert</span><span>(</span><span>"非常强大"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><div><pre><code><span>span</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>:::</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/demo.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="幻灯片" tabindex="-1"> 幻灯片</h3>
<i>Content not supported</i><ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/presentation.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<hr>
<section>
<ol>
<li id="footnote1"><p>这是脚注内容 </p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>页面配置</title>
      <link>https://dearlocation.com/zh/guide/page.html</link>
      <guid>https://dearlocation.com/zh/guide/page.html</guid>
      <source url="https://dearlocation.com/rss.xml">页面配置</source>
      <description>more 注释之前的内容被视为文章摘要。
</description>
      <category>使用指南</category>
      <pubDate>Wed, 01 Jan 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><code>more</code> 注释之前的内容被视为文章摘要。</p>

<h2 id="页面信息" tabindex="-1"> 页面信息</h2>
<p>你可以在 Markdown 的 Frontmatter 中设置页面信息。</p>
<ul>
<li>
<p>作者设置为 Ms.Hope。</p>
</li>
<li>
<p>写作时间应为 2020 年 1 月 1 日</p>
</li>
<li>
<p>分类为 “使用指南”</p>
</li>
<li>
<p>标签为 “页面配置” 和 “使用指南”</p>
</li>
</ul>
<h2 id="页面内容" tabindex="-1"> 页面内容</h2>
<p>你可以自由在这里书写你的 Markdown。</p>
<div><p>Tips</p>
<ul>
<li>
<p>Markdown 文件夹的图片请使用相对链接 <code>./</code> 进行引用。</p>
</li>
<li>
<p><code>.vuepress/public</code> 文件夹的图片，请使用绝对链接 <code>/</code> 进行引用</p>
</li>
</ul>
</div>
<p>主题包含了一个自定义徽章章可以使用:</p>
<blockquote>
<p>文字结尾应该有深蓝色的 徽章文字 徽章。 <i>Content not supported</i></p>
</blockquote>
<h2 id="页面结构" tabindex="-1"> 页面结构</h2>
<p>此页面应当包含：</p>
<ul>
<li>返回顶部按钮</li>
<li>路径导航</li>
<li>评论</li>
<li>页脚</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>文章 10</title>
      <link>https://dearlocation.com/zh/posts/article10.html</link>
      <guid>https://dearlocation.com/zh/posts/article10.html</guid>
      <source url="https://dearlocation.com/rss.xml">文章 10</source>
      <category>CategoryA</category>
      <category>CategoryB</category>
      <pubDate>Mon, 10 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="文章-10" tabindex="-1"> 文章 10</h1>
<h2 id="标题-2" tabindex="-1"> 标题 2</h2>
<p>这里是内容。</p>
<h3 id="标题-3" tabindex="-1"> 标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>文章 11</title>
      <link>https://dearlocation.com/zh/posts/article11.html</link>
      <guid>https://dearlocation.com/zh/posts/article11.html</guid>
      <source url="https://dearlocation.com/rss.xml">文章 11</source>
      <category>CategoryA</category>
      <category>CategoryB</category>
      <pubDate>Tue, 11 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="文章-11" tabindex="-1"> 文章 11</h1>
<h2 id="标题-2" tabindex="-1"> 标题 2</h2>
<p>这里是内容。</p>
<h3 id="标题-3" tabindex="-1"> 标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>文章 12</title>
      <link>https://dearlocation.com/zh/posts/article12.html</link>
      <guid>https://dearlocation.com/zh/posts/article12.html</guid>
      <source url="https://dearlocation.com/rss.xml">文章 12</source>
      <category>CategoryA</category>
      <category>CategoryB</category>
      <pubDate>Wed, 12 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="文章-12" tabindex="-1"> 文章 12</h1>
<h2 id="标题-2" tabindex="-1"> 标题 2</h2>
<p>这里是内容。</p>
<h3 id="标题-3" tabindex="-1"> 标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>文章 9</title>
      <link>https://dearlocation.com/zh/posts/article9.html</link>
      <guid>https://dearlocation.com/zh/posts/article9.html</guid>
      <source url="https://dearlocation.com/rss.xml">文章 9</source>
      <category>CategoryA</category>
      <category>CategoryB</category>
      <pubDate>Sun, 09 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="文章-9" tabindex="-1"> 文章 9</h1>
<h2 id="标题-2" tabindex="-1"> 标题 2</h2>
<p>这里是内容。</p>
<h3 id="标题-3" tabindex="-1"> 标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>文章 1</title>
      <link>https://dearlocation.com/zh/posts/article/article1.html</link>
      <guid>https://dearlocation.com/zh/posts/article/article1.html</guid>
      <source url="https://dearlocation.com/rss.xml">文章 1</source>
      <category>CategoryA</category>
      <pubDate>Sat, 01 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="文章-1" tabindex="-1"> 文章 1</h1>
<h2 id="标题-2" tabindex="-1"> 标题 2</h2>
<p>这里是内容。</p>
<h3 id="标题-3" tabindex="-1"> 标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>文章 2</title>
      <link>https://dearlocation.com/zh/posts/article/article2.html</link>
      <guid>https://dearlocation.com/zh/posts/article/article2.html</guid>
      <source url="https://dearlocation.com/rss.xml">文章 2</source>
      <category>CategoryA</category>
      <pubDate>Sun, 02 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="文章-2" tabindex="-1"> 文章 2</h1>
<h2 id="标题-2" tabindex="-1"> 标题 2</h2>
<p>这里是内容。</p>
<h3 id="标题-3" tabindex="-1"> 标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>文章 3</title>
      <link>https://dearlocation.com/zh/posts/article/article3.html</link>
      <guid>https://dearlocation.com/zh/posts/article/article3.html</guid>
      <source url="https://dearlocation.com/rss.xml">文章 3</source>
      <category>CategoryA</category>
      <category>CategoryB</category>
      <pubDate>Mon, 03 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="文章-3" tabindex="-1"> 文章 3</h1>
<h2 id="标题-2" tabindex="-1"> 标题 2</h2>
<p>这里是内容。</p>
<h3 id="标题-3" tabindex="-1"> 标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>文章 4</title>
      <link>https://dearlocation.com/zh/posts/article/article4.html</link>
      <guid>https://dearlocation.com/zh/posts/article/article4.html</guid>
      <source url="https://dearlocation.com/rss.xml">文章 4</source>
      <category>CategoryA</category>
      <category>CategoryB</category>
      <pubDate>Tue, 04 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="文章-4" tabindex="-1"> 文章 4</h1>
<h2 id="标题-2" tabindex="-1"> 标题 2</h2>
<p>这里是内容。</p>
<h3 id="标题-3" tabindex="-1"> 标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>文章 5</title>
      <link>https://dearlocation.com/zh/posts/article/article5.html</link>
      <guid>https://dearlocation.com/zh/posts/article/article5.html</guid>
      <source url="https://dearlocation.com/rss.xml">文章 5</source>
      <category>CategoryA</category>
      <category>CategoryB</category>
      <pubDate>Wed, 05 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="文章-5" tabindex="-1"> 文章 5</h1>
<h2 id="标题-2" tabindex="-1"> 标题 2</h2>
<p>这里是内容。</p>
<h3 id="标题-3" tabindex="-1"> 标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>文章 6</title>
      <link>https://dearlocation.com/zh/posts/article/article6.html</link>
      <guid>https://dearlocation.com/zh/posts/article/article6.html</guid>
      <source url="https://dearlocation.com/rss.xml">文章 6</source>
      <category>CategoryA</category>
      <category>CategoryB</category>
      <pubDate>Thu, 06 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="文章-6" tabindex="-1"> 文章 6</h1>
<h2 id="标题-2" tabindex="-1"> 标题 2</h2>
<p>这里是内容。</p>
<h3 id="标题-3" tabindex="-1"> 标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>文章 7</title>
      <link>https://dearlocation.com/zh/posts/article/article7.html</link>
      <guid>https://dearlocation.com/zh/posts/article/article7.html</guid>
      <source url="https://dearlocation.com/rss.xml">文章 7</source>
      <category>CategoryA</category>
      <category>CategoryB</category>
      <pubDate>Fri, 07 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="文章-7" tabindex="-1"> 文章 7</h1>
<h2 id="标题-2" tabindex="-1"> 标题 2</h2>
<p>这里是内容。</p>
<h3 id="标题-3" tabindex="-1"> 标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>文章 8</title>
      <link>https://dearlocation.com/zh/posts/article/article8.html</link>
      <guid>https://dearlocation.com/zh/posts/article/article8.html</guid>
      <source url="https://dearlocation.com/rss.xml">文章 8</source>
      <category>CategoryA</category>
      <category>CategoryB</category>
      <pubDate>Sat, 08 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="文章-8" tabindex="-1"> 文章 8</h1>
<h2 id="标题-2" tabindex="-1"> 标题 2</h2>
<p>这里是内容。</p>
<h3 id="标题-3" tabindex="-1"> 标题 3</h3>
<p>这里是内容。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>